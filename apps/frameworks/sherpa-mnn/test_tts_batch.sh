#!/usr/bin/env bash
#
# test_tts_batch.sh - Mac TTS Batch Testing Script
#
# This script tests the TTS capabilities of the sherpa-mnn framework
# Supports batch WAV file generation with multiple TTS models
#
# Usage:
#   ./test_tts_batch.sh                    # Test all downloaded models
#   ./test_tts_batch.sh --download         # Download all models
#   ./test_tts_batch.sh --download-only    # Only download models, don't run tests
#   ./test_tts_batch.sh --model kokoro-en  # Test a specific model
#   ./test_tts_batch.sh --text "Hello"     # Use custom text
#   ./test_tts_batch.sh --convert          # Convert ONNX models to MNN format
#   ./test_tts_batch.sh --play             # Play audio after generation
#

# Ensure complete PATH
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:$PATH"

set -e

# Script directory
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
BUILD_DIR="${SCRIPT_DIR}/build"
BIN_DIR="${BUILD_DIR}/bin"
MODELS_DIR="${SCRIPT_DIR}/tts-models"
OUTPUT_DIR="${SCRIPT_DIR}/tts-output"

# MNN library paths - try multiple possible locations
MNN_LIB_PATHS=(
    "${SCRIPT_DIR}/../../../apps/mnncli/test/build_unit"
    "${SCRIPT_DIR}/../../../apps/mnncli/test/build_system"
    "${SCRIPT_DIR}/../../../build/lib"
    "${SCRIPT_DIR}/../../../build_mnn_static/lib"
)

for path in "${MNN_LIB_PATHS[@]}"; do
    if [ -f "${path}/libMNN.dylib" ]; then
        export DYLD_LIBRARY_PATH="${path}:${DYLD_LIBRARY_PATH}"
        MNN_LIB_FOUND="${path}"
        break
    fi
done

# Executables
TTS_BIN="${BIN_DIR}/sherpa-mnn-offline-tts"
TTS_BIN_PLAY="${BIN_DIR}/sherpa-mnn-offline-tts-play"

# MNNConvert paths - try multiple possible locations
MNN_CONVERT_PATHS=(
    "${SCRIPT_DIR}/../../../build_converter/MNNConvert"
    "${SCRIPT_DIR}/../../../build/MNNConvert"
    "${SCRIPT_DIR}/../../../build_mnn_static/MNNConvert"
)

MNN_CONVERT=""
for path in "${MNN_CONVERT_PATHS[@]}"; do
    if [ -f "${path}" ]; then
        MNN_CONVERT="${path}"
        break
    fi
done

# Default parameters
DOWNLOAD_MODELS=false
DOWNLOAD_ONLY=false
CONVERT_MODELS=false
PLAY_AUDIO=false
SPECIFIC_MODEL=""
CUSTOM_TEXT=""
NUM_THREADS=2

# Colored output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Model configuration
# Format: "model_name|type|download_url|language|description"
declare -a TTS_MODELS=(
    "kokoro-en-v0_19|kokoro|https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/kokoro-en-v0_19.tar.bz2|en|Kokoro English TTS"
    "kokoro-multi-lang-v1_0|kokoro|https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/kokoro-multi-lang-v1_0.tar.bz2|zh-en|Kokoro Chinese+English TTS"
    "matcha-icefall-en_US-ljspeech|matcha|https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/matcha-icefall-en_US-ljspeech.tar.bz2|en|Matcha English TTS (LJSpeech)"
    "matcha-icefall-zh-baker|matcha|https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/matcha-icefall-zh-baker.tar.bz2|zh|Matcha Chinese TTS (Baker)"
)

# Vocoder configuration
VOCODER_URL="https://github.com/k2-fsa/sherpa-onnx/releases/download/vocoder-models/hifigan_v2.onnx"
VOCODER_FILE="hifigan_v2.onnx"

# Test text (avoid associative arrays for bash 3.x compatibility)
TEXT_EN="Today as always, men fall into two groups: slaves and free men. The quick brown fox jumps over the lazy dog."
TEXT_ZH="当夜幕降临，星光点点，伴随着微风拂面，我在静谧中感受着时光的流转。"
TEXT_ZH_EN="中英文语音合成测试。This is generated by sherpa-mnn TTS. 你觉得效果如何？"

show_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --download        Download all TTS models"
    echo "  --download-only   Only download models, don't run tests"
    echo "  --convert         Convert ONNX models to MNN format"
    echo "  --model NAME      Test a specific model (kokoro-en, kokoro-multi, matcha-en, matcha-zh)"
    echo "  --text TEXT       Use custom test text"
    echo "  --play            Play audio after generation"
    echo "  --list            List all supported models"
    echo "  --help            Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 --download                # Download all models"
    echo "  $0 --model kokoro-en --play  # Test Kokoro English model and play"
    echo "  $0 --text 'Hello World'      # Test all models with custom text"
}

list_models() {
    echo ""
    echo "Supported TTS Models:"
    echo "==============================================="
    printf "%-30s %-10s %-10s %s\n" "Model Name" "Type" "Language" "Status"
    echo "-----------------------------------------------"
    for model_info in "${TTS_MODELS[@]}"; do
        IFS='|' read -r name type url lang desc <<< "$model_info"
        local model_status=""
        if [ -d "${MODELS_DIR}/${name}" ]; then
            model_status="${GREEN}Downloaded${NC}"
        else
            model_status="${YELLOW}Not Downloaded${NC}"
        fi
        printf "%-30s %-10s %-10s %b\n" "$name" "$type" "$lang" "$model_status"
    done
    echo "==============================================="
}

download_model() {
    local name=$1
    local url=$2

    log_info "Downloading model: $name"

    mkdir -p "${MODELS_DIR}"
    cd "${MODELS_DIR}"

    local archive_name=$(basename "$url")

    if [ -d "$name" ]; then
        log_warning "Model $name already exists, skipping download"
        return 0
    fi

    if [ ! -f "$archive_name" ]; then
        log_info "Downloading $archive_name ..."
        curl -L -o "$archive_name" "$url"
    fi

    log_info "Extracting $archive_name ..."
    tar xf "$archive_name"
    rm -f "$archive_name"

    log_success "Model $name download completed"
}

download_vocoder() {
    mkdir -p "${MODELS_DIR}"
    cd "${MODELS_DIR}"

    if [ -f "$VOCODER_FILE" ]; then
        log_warning "Vocoder already exists, skipping download"
        return 0
    fi

    log_info "Downloading Vocoder: $VOCODER_FILE"
    curl -L -o "$VOCODER_FILE" "$VOCODER_URL"
    log_success "Vocoder download completed"
}

download_all_models() {
    log_info "Starting to download all TTS models..."

    for model_info in "${TTS_MODELS[@]}"; do
        IFS='|' read -r name type url lang desc <<< "$model_info"
        download_model "$name" "$url"
    done

    # Download vocoder required by Matcha
    download_vocoder

    log_success "All models downloaded!"
}

convert_onnx_to_mnn() {
    local onnx_file=$1
    local mnn_file=$2

    if [ -z "$MNN_CONVERT" ]; then
        log_error "MNNConvert not found, cannot convert model"
        log_warning "Please build MNNConvert first"
        return 1
    fi

    if [ ! -f "$MNN_CONVERT" ]; then
        log_error "MNNConvert does not exist: $MNN_CONVERT"
        return 1
    fi

    log_info "Converting $onnx_file -> $mnn_file"
    # Use DYLD_LIBRARY_PATH to ensure MNNConvert can find libraries
    export DYLD_LIBRARY_PATH="$(dirname "$MNN_CONVERT")/../lib:${DYLD_LIBRARY_PATH}"
    "$MNN_CONVERT" -f ONNX --modelFile "$onnx_file" --MNNModel "$mnn_file" --weightQuantBits=8 --weightQuantBlock=64
}

check_and_convert_model() {
    local model_dir=$1
    local onnx_name="model.onnx"
    local mnn_name="model.mnn"

    # Special handling for matcha models
    if [ -f "${model_dir}/model-steps-3.onnx" ]; then
        onnx_name="model-steps-3.onnx"
        mnn_name="model-steps-3.mnn"
    fi

    if [ ! -f "${model_dir}/${mnn_name}" ]; then
        if [ -f "${model_dir}/${onnx_name}" ]; then
            log_info "MNN model does not exist, attempting conversion: ${onnx_name} -> ${mnn_name}" >&2
            convert_onnx_to_mnn "${model_dir}/${onnx_name}" "${model_dir}/${mnn_name}" >&2
        else
            log_error "Cannot find original ONNX model: ${model_dir}/${onnx_name}" >&2
            return 1
        fi
    else
        log_info "Using existing MNN model: ${mnn_name}" >&2
    fi

    echo "${mnn_name}"
}

check_and_convert_vocoder() {
    local vocoder_path=$1
    local vocoder_dir=$(dirname "$vocoder_path")
    local vocoder_name=$(basename "$vocoder_path")
    local vocoder_mnn="${vocoder_name%.*}.mnn"

    if [ ! -f "${vocoder_dir}/${vocoder_mnn}" ]; then
        if [ -f "${vocoder_path}" ]; then
            log_info "MNN Vocoder does not exist, attempting conversion: ${vocoder_name} -> ${vocoder_mnn}" >&2
            convert_onnx_to_mnn "${vocoder_path}" "${vocoder_dir}/${vocoder_mnn}" >&2
        else
            log_error "Cannot find original Vocoder model: ${vocoder_path}" >&2
            return 1
        fi
    else
        log_info "Using existing MNN Vocoder: ${vocoder_mnn}" >&2
    fi

    echo "${vocoder_dir}/${vocoder_mnn}"
}

run_tts_kokoro_en() {
    local model_dir="${MODELS_DIR}/kokoro-en-v0_19"
    local output_file="${OUTPUT_DIR}/kokoro-en-output.wav"
    local text="${CUSTOM_TEXT:-${TEXT_EN}}"

    if [ ! -d "$model_dir" ]; then
        log_error "Model does not exist: $model_dir"
        return 1
    fi

    log_info "Running Kokoro English TTS..."
    log_info "Text: $text"

    local model_name=$(check_and_convert_model "$model_dir")

    local start_time=$(date +%s.%N)

    "$TTS_BIN" \
        --kokoro-model="${model_dir}/${model_name}" \
        --kokoro-voices="${model_dir}/voices.bin" \
        --kokoro-tokens="${model_dir}/tokens.txt" \
        --kokoro-data-dir="${model_dir}/espeak-ng-data" \
        --num-threads=$NUM_THREADS \
        --output-filename="$output_file" \
        "$text"

    local end_time=$(date +%s.%N)
    local elapsed=$(echo "$end_time - $start_time" | bc)

    log_success "Generation completed: $output_file (Time: ${elapsed}s)"

    if [ "$PLAY_AUDIO" = true ] && [ -f "$output_file" ]; then
        log_info "Playing audio..."
        afplay "$output_file" 2>/dev/null || open "$output_file"
    fi
}

run_tts_kokoro_multi() {
    local model_dir="${MODELS_DIR}/kokoro-multi-lang-v1_0"
    local output_file="${OUTPUT_DIR}/kokoro-multi-output.wav"
    local text="${CUSTOM_TEXT:-${TEXT_ZH_EN}}"

    if [ ! -d "$model_dir" ]; then
        log_error "Model does not exist: $model_dir"
        return 1
    fi

    log_info "Running Kokoro Chinese-English Mixed TTS..."
    log_info "Text: $text"

    local model_name=$(check_and_convert_model "$model_dir")

    local start_time=$(date +%s.%N)

    "$TTS_BIN" \
        --kokoro-model="${model_dir}/${model_name}" \
        --kokoro-voices="${model_dir}/voices.bin" \
        --kokoro-tokens="${model_dir}/tokens.txt" \
        --kokoro-data-dir="${model_dir}/espeak-ng-data" \
        --kokoro-dict-dir="${model_dir}/dict" \
        --kokoro-lexicon="${model_dir}/lexicon-us-en.txt,${model_dir}/lexicon-zh.txt" \
        --num-threads=$NUM_THREADS \
        --sid=50 \
        --output-filename="$output_file" \
        "$text"

    local end_time=$(date +%s.%N)
    local elapsed=$(echo "$end_time - $start_time" | bc)

    log_success "Generation completed: $output_file (Time: ${elapsed}s)"

    if [ "$PLAY_AUDIO" = true ] && [ -f "$output_file" ]; then
        log_info "Playing audio..."
        afplay "$output_file" 2>/dev/null || open "$output_file"
    fi
}

run_tts_matcha_en() {
    local model_dir="${MODELS_DIR}/matcha-icefall-en_US-ljspeech"
    local vocoder="${MODELS_DIR}/${VOCODER_FILE}"
    local output_file="${OUTPUT_DIR}/matcha-en-output.wav"
    local text="${CUSTOM_TEXT:-${TEXT_EN}}"

    if [ ! -d "$model_dir" ]; then
        log_error "Model does not exist: $model_dir"
        return 1
    fi

    if [ ! -f "$vocoder" ]; then
        log_error "Vocoder does not exist: $vocoder"
        log_warning "Please run --download to download vocoder"
        return 1
    fi

    log_info "Running Matcha English TTS..."
    log_info "Text: $text"

    local model_name=$(check_and_convert_model "$model_dir")
    local vocoder_mnn=$(check_and_convert_vocoder "$vocoder")

    local start_time=$(date +%s.%N)

    "$TTS_BIN" \
        --matcha-acoustic-model="${model_dir}/${model_name}" \
        --matcha-vocoder="$vocoder_mnn" \
        --matcha-tokens="${model_dir}/tokens.txt" \
        --matcha-data-dir="${model_dir}/espeak-ng-data" \
        --num-threads=$NUM_THREADS \
        --output-filename="$output_file" \
        "$text"

    local end_time=$(date +%s.%N)
    local elapsed=$(echo "$end_time - $start_time" | bc)

    log_success "Generation completed: $output_file (Time: ${elapsed}s)"

    if [ "$PLAY_AUDIO" = true ] && [ -f "$output_file" ]; then
        log_info "Playing audio..."
        afplay "$output_file" 2>/dev/null || open "$output_file"
    fi
}

run_tts_matcha_zh() {
    local model_dir="${MODELS_DIR}/matcha-icefall-zh-baker"
    local vocoder="${MODELS_DIR}/${VOCODER_FILE}"
    local output_file="${OUTPUT_DIR}/matcha-zh-output.wav"
    local text="${CUSTOM_TEXT:-${TEXT_ZH}}"

    if [ ! -d "$model_dir" ]; then
        log_error "Model does not exist: $model_dir"
        return 1
    fi

    if [ ! -f "$vocoder" ]; then
        log_error "Vocoder does not exist: $vocoder"
        log_warning "Please run --download to download vocoder"
        return 1
    fi

    log_info "Running Matcha Chinese TTS..."
    log_info "Text: $text"

    local model_name=$(check_and_convert_model "$model_dir")
    local vocoder_mnn=$(check_and_convert_vocoder "$vocoder")

    local start_time=$(date +%s.%N)

    "$TTS_BIN" \
        --matcha-acoustic-model="${model_dir}/${model_name}" \
        --matcha-vocoder="$vocoder_mnn" \
        --matcha-lexicon="${model_dir}/lexicon.txt" \
        --matcha-tokens="${model_dir}/tokens.txt" \
        --matcha-dict-dir="${model_dir}/dict" \
        --tts-rule-fsts="${model_dir}/phone.fst,${model_dir}/date.fst,${model_dir}/number.fst" \
        --num-threads=$NUM_THREADS \
        --output-filename="$output_file" \
        "$text"

    local end_time=$(date +%s.%N)
    local elapsed=$(echo "$end_time - $start_time" | bc)

    log_success "Generation completed: $output_file (Time: ${elapsed}s)"

    if [ "$PLAY_AUDIO" = true ] && [ -f "$output_file" ]; then
        log_info "Playing audio..."
        afplay "$output_file" 2>/dev/null || open "$output_file"
    fi
}

run_single_model() {
    local model=$1

    case "$model" in
        kokoro-en|kokoro-en-v0_19)
            run_tts_kokoro_en
            ;;
        kokoro-multi|kokoro-multi-lang-v1_0)
            run_tts_kokoro_multi
            ;;
        matcha-en|matcha-icefall-en_US-ljspeech)
            run_tts_matcha_en
            ;;
        matcha-zh|matcha-icefall-zh-baker)
            run_tts_matcha_zh
            ;;
        *)
            log_error "Unknown model: $model"
            log_warning "Use --list to see supported models"
            return 1
            ;;
    esac
}

run_all_available_models() {
    log_info "Running tests on all available models..."

    local success_count=0
    local fail_count=0
    local results=()

    # Kokoro English
    if [ -d "${MODELS_DIR}/kokoro-en-v0_19" ]; then
        if run_tts_kokoro_en; then
            ((success_count++))
            results+=("${GREEN}✓${NC} kokoro-en")
        else
            ((fail_count++))
            results+=("${RED}✗${NC} kokoro-en")
        fi
    fi

    # Kokoro Multi-lang
    if [ -d "${MODELS_DIR}/kokoro-multi-lang-v1_0" ]; then
        if run_tts_kokoro_multi; then
            ((success_count++))
            results+=("${GREEN}✓${NC} kokoro-multi")
        else
            ((fail_count++))
            results+=("${RED}✗${NC} kokoro-multi")
        fi
    fi

    # Matcha English
    if [ -d "${MODELS_DIR}/matcha-icefall-en_US-ljspeech" ]; then
        if run_tts_matcha_en; then
            ((success_count++))
            results+=("${GREEN}✓${NC} matcha-en")
        else
            ((fail_count++))
            results+=("${RED}✗${NC} matcha-en")
        fi
    fi

    # Matcha Chinese
    if [ -d "${MODELS_DIR}/matcha-icefall-zh-baker" ]; then
        if run_tts_matcha_zh; then
            ((success_count++))
            results+=("${GREEN}✓${NC} matcha-zh")
        else
            ((fail_count++))
            results+=("${RED}✗${NC} matcha-zh")
        fi
    fi

    echo ""
    echo "==============================================="
    echo "Test Results Summary"
    echo "==============================================="
    for result in "${results[@]}"; do
        echo -e "  $result"
    done
    echo "-----------------------------------------------"
    echo -e "Success: ${GREEN}$success_count${NC}, Failed: ${RED}$fail_count${NC}"
    echo ""

    if [ $success_count -eq 0 ]; then
        log_warning "No available models found, please run --download to download models first"
        return 1
    fi

    log_info "Generated WAV files located at: $OUTPUT_DIR"
    ls -la "$OUTPUT_DIR"/*.wav 2>/dev/null || true
}

check_environment() {
    log_info "TTS_BIN: $TTS_BIN"
    log_info "MNN_CONVERT: $MNN_CONVERT"

    if [ ! -f "$TTS_BIN" ]; then
        log_error "TTS executable does not exist: $TTS_BIN"
        log_warning "Please build sherpa-mnn first"
        exit 1
    fi

    if [ -n "$MNN_LIB_FOUND" ]; then
        log_info "Found MNN library: $MNN_LIB_FOUND"
    else
        log_warning "libMNN.dylib not found, may need to manually set DYLD_LIBRARY_PATH"
    fi

    mkdir -p "$OUTPUT_DIR"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --download)
            DOWNLOAD_MODELS=true
            shift
            ;;
        --download-only)
            DOWNLOAD_MODELS=true
            DOWNLOAD_ONLY=true
            shift
            ;;
        --convert)
            CONVERT_MODELS=true
            shift
            ;;
        --model)
            SPECIFIC_MODEL="$2"
            shift 2
            ;;
        --text)
            CUSTOM_TEXT="$2"
            shift 2
            ;;
        --play)
            PLAY_AUDIO=true
            shift
            ;;
        --list)
            list_models
            exit 0
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# Main flow
echo ""
echo "=============================================="
echo "  sherpa-mnn Mac TTS Batch Testing"
echo "=============================================="
echo ""

check_environment

if [ "$DOWNLOAD_MODELS" = true ]; then
    download_all_models
    if [ "$DOWNLOAD_ONLY" = true ]; then
        exit 0
    fi
fi

if [ -n "$SPECIFIC_MODEL" ]; then
    run_single_model "$SPECIFIC_MODEL"
else
    run_all_available_models
fi

log_success "TTS testing completed!"
