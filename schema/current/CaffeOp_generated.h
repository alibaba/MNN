// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CAFFEOP_MNN_H_
#define FLATBUFFERS_GENERATED_CAFFEOP_MNN_H_


#include "Tensor_generated.h"
#include "Type_generated.h"

namespace MNN {

struct Convolution2DCommon;
struct Convolution2DCommonT;

struct Convolution3DCommon;
struct Convolution3DCommonT;

struct IDSTQuan;
struct IDSTQuanT;

struct QuantizedFloatParam;
struct QuantizedFloatParamT;

struct Convolution2D;
struct Convolution2DT;

struct Convolution3D;
struct Convolution3DT;

struct InnerProduct;
struct InnerProductT;

struct Pool;
struct PoolT;

struct Pool3D;
struct Pool3DT;

struct Relu;
struct ReluT;

struct Relu6;
struct Relu6T;

struct PRelu;
struct PReluT;

struct ELU;
struct ELUT;

struct LRN;
struct LRNT;

struct ArgMax;
struct ArgMaxT;

struct Axis;
struct AxisT;

struct Input;
struct InputT;

struct LSTM;
struct LSTMT;

struct Slice;
struct SliceT;

struct BatchNorm;
struct BatchNormT;

struct Scale;
struct ScaleT;

struct Eltwise;
struct EltwiseT;

struct Flatten;
struct FlattenT;

struct Permute;
struct PermuteT;

struct Reshape;
struct ReshapeT;

struct DetectionOutput;
struct DetectionOutputT;

struct RoiPooling;
struct RoiPoolingT;

struct Proposal;
struct ProposalT;

struct Interp;
struct InterpT;

struct Resize;
struct ResizeT;

struct PriorBox;
struct PriorBoxT;

struct Normalize;
struct NormalizeT;

struct EltwiseInt8;
struct EltwiseInt8T;

inline const flatbuffers::TypeTable *Convolution2DCommonTypeTable();

inline const flatbuffers::TypeTable *Convolution3DCommonTypeTable();

inline const flatbuffers::TypeTable *IDSTQuanTypeTable();

inline const flatbuffers::TypeTable *QuantizedFloatParamTypeTable();

inline const flatbuffers::TypeTable *Convolution2DTypeTable();

inline const flatbuffers::TypeTable *Convolution3DTypeTable();

inline const flatbuffers::TypeTable *InnerProductTypeTable();

inline const flatbuffers::TypeTable *PoolTypeTable();

inline const flatbuffers::TypeTable *Pool3DTypeTable();

inline const flatbuffers::TypeTable *ReluTypeTable();

inline const flatbuffers::TypeTable *Relu6TypeTable();

inline const flatbuffers::TypeTable *PReluTypeTable();

inline const flatbuffers::TypeTable *ELUTypeTable();

inline const flatbuffers::TypeTable *LRNTypeTable();

inline const flatbuffers::TypeTable *ArgMaxTypeTable();

inline const flatbuffers::TypeTable *AxisTypeTable();

inline const flatbuffers::TypeTable *InputTypeTable();

inline const flatbuffers::TypeTable *LSTMTypeTable();

inline const flatbuffers::TypeTable *SliceTypeTable();

inline const flatbuffers::TypeTable *BatchNormTypeTable();

inline const flatbuffers::TypeTable *ScaleTypeTable();

inline const flatbuffers::TypeTable *EltwiseTypeTable();

inline const flatbuffers::TypeTable *FlattenTypeTable();

inline const flatbuffers::TypeTable *PermuteTypeTable();

inline const flatbuffers::TypeTable *ReshapeTypeTable();

inline const flatbuffers::TypeTable *DetectionOutputTypeTable();

inline const flatbuffers::TypeTable *RoiPoolingTypeTable();

inline const flatbuffers::TypeTable *ProposalTypeTable();

inline const flatbuffers::TypeTable *InterpTypeTable();

inline const flatbuffers::TypeTable *ResizeTypeTable();

inline const flatbuffers::TypeTable *PriorBoxTypeTable();

inline const flatbuffers::TypeTable *NormalizeTypeTable();

inline const flatbuffers::TypeTable *EltwiseInt8TypeTable();

enum PadMode {
  PadMode_CAFFE = 0,
  PadMode_VALID = 1,
  PadMode_SAME = 2,
  PadMode_MIN = PadMode_CAFFE,
  PadMode_MAX = PadMode_SAME
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_CAFFE,
    PadMode_VALID,
    PadMode_SAME
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (e < PadMode_CAFFE || e > PadMode_SAME) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPadMode()[index];
}

enum PoolType {
  PoolType_MAXPOOL = 0,
  PoolType_AVEPOOL = 1,
  PoolType_MIN = PoolType_MAXPOOL,
  PoolType_MAX = PoolType_AVEPOOL
};

inline const PoolType (&EnumValuesPoolType())[2] {
  static const PoolType values[] = {
    PoolType_MAXPOOL,
    PoolType_AVEPOOL
  };
  return values;
}

inline const char * const *EnumNamesPoolType() {
  static const char * const names[] = {
    "MAXPOOL",
    "AVEPOOL",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolType(PoolType e) {
  if (e < PoolType_MAXPOOL || e > PoolType_AVEPOOL) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPoolType()[index];
}

enum PoolPadType {
  PoolPadType_CAFFE = 0,
  PoolPadType_VALID = 1,
  PoolPadType_SAME = 2,
  PoolPadType_MIN = PoolPadType_CAFFE,
  PoolPadType_MAX = PoolPadType_SAME
};

inline const PoolPadType (&EnumValuesPoolPadType())[3] {
  static const PoolPadType values[] = {
    PoolPadType_CAFFE,
    PoolPadType_VALID,
    PoolPadType_SAME
  };
  return values;
}

inline const char * const *EnumNamesPoolPadType() {
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolPadType(PoolPadType e) {
  if (e < PoolPadType_CAFFE || e > PoolPadType_SAME) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPoolPadType()[index];
}

enum EltwiseType {
  EltwiseType_PROD = 0,
  EltwiseType_SUM = 1,
  EltwiseType_MAXIMUM = 2,
  EltwiseType_SUB = 3,
  EltwiseType_MIN = EltwiseType_PROD,
  EltwiseType_MAX = EltwiseType_SUB
};

inline const EltwiseType (&EnumValuesEltwiseType())[4] {
  static const EltwiseType values[] = {
    EltwiseType_PROD,
    EltwiseType_SUM,
    EltwiseType_MAXIMUM,
    EltwiseType_SUB
  };
  return values;
}

inline const char * const *EnumNamesEltwiseType() {
  static const char * const names[] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "SUB",
    nullptr
  };
  return names;
}

inline const char *EnumNameEltwiseType(EltwiseType e) {
  if (e < EltwiseType_PROD || e > EltwiseType_SUB) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesEltwiseType()[index];
}

struct Convolution2DCommonT : public flatbuffers::NativeTable {
  typedef Convolution2DCommon TableType;
  int32_t padX;
  int32_t padY;
  int32_t kernelX;
  int32_t kernelY;
  int32_t strideX;
  int32_t strideY;
  int32_t dilateX;
  int32_t dilateY;
  PadMode padMode;
  int32_t group;
  int32_t outputCount;
  int32_t inputCount;
  bool relu;
  bool relu6;
  Convolution2DCommonT()
      : padX(0),
        padY(0),
        kernelX(1),
        kernelY(1),
        strideX(1),
        strideY(1),
        dilateX(1),
        dilateY(1),
        padMode(PadMode_CAFFE),
        group(1),
        outputCount(0),
        inputCount(0),
        relu(false),
        relu6(false) {
  }
};

struct Convolution2DCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution2DCommonT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution2DCommonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADX = 4,
    VT_PADY = 6,
    VT_KERNELX = 8,
    VT_KERNELY = 10,
    VT_STRIDEX = 12,
    VT_STRIDEY = 14,
    VT_DILATEX = 16,
    VT_DILATEY = 18,
    VT_PADMODE = 20,
    VT_GROUP = 22,
    VT_OUTPUTCOUNT = 24,
    VT_INPUTCOUNT = 26,
    VT_RELU = 28,
    VT_RELU6 = 30
  };
  int32_t padX() const {
    return GetField<int32_t>(VT_PADX, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(VT_PADY, 0);
  }
  int32_t kernelX() const {
    return GetField<int32_t>(VT_KERNELX, 1);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(VT_KERNELY, 1);
  }
  int32_t strideX() const {
    return GetField<int32_t>(VT_STRIDEX, 1);
  }
  int32_t strideY() const {
    return GetField<int32_t>(VT_STRIDEY, 1);
  }
  int32_t dilateX() const {
    return GetField<int32_t>(VT_DILATEX, 1);
  }
  int32_t dilateY() const {
    return GetField<int32_t>(VT_DILATEY, 1);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t inputCount() const {
    return GetField<int32_t>(VT_INPUTCOUNT, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(VT_RELU, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(VT_RELU6, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PADX) &&
           VerifyField<int32_t>(verifier, VT_PADY) &&
           VerifyField<int32_t>(verifier, VT_KERNELX) &&
           VerifyField<int32_t>(verifier, VT_KERNELY) &&
           VerifyField<int32_t>(verifier, VT_STRIDEX) &&
           VerifyField<int32_t>(verifier, VT_STRIDEY) &&
           VerifyField<int32_t>(verifier, VT_DILATEX) &&
           VerifyField<int32_t>(verifier, VT_DILATEY) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT) &&
           VerifyField<int32_t>(verifier, VT_INPUTCOUNT) &&
           VerifyField<uint8_t>(verifier, VT_RELU) &&
           VerifyField<uint8_t>(verifier, VT_RELU6) &&
           verifier.EndTable();
  }
  Convolution2DCommonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution2DCommonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution2DCommon> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution2DCommonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_PADX, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_PADY, padY, 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_KERNELX, kernelX, 1);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_KERNELY, kernelY, 1);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_STRIDEX, strideX, 1);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_STRIDEY, strideY, 1);
  }
  void add_dilateX(int32_t dilateX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_DILATEX, dilateX, 1);
  }
  void add_dilateY(int32_t dilateY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_DILATEY, dilateY, 1);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Convolution2DCommon::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_GROUP, group, 1);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_INPUTCOUNT, inputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(Convolution2DCommon::VT_RELU, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(Convolution2DCommon::VT_RELU6, static_cast<uint8_t>(relu6), 0);
  }
  explicit Convolution2DCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Convolution2DCommonBuilder &operator=(const Convolution2DCommonBuilder &);
  flatbuffers::Offset<Convolution2DCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution2DCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    PadMode padMode = PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false) {
  Convolution2DCommonBuilder builder_(_fbb);
  builder_.add_inputCount(inputCount);
  builder_.add_outputCount(outputCount);
  builder_.add_group(group);
  builder_.add_dilateY(dilateY);
  builder_.add_dilateX(dilateX);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Convolution3DCommonT : public flatbuffers::NativeTable {
  typedef Convolution3DCommon TableType;
  std::vector<int32_t> dilates;
  std::vector<int32_t> strides;
  std::vector<int32_t> kernels;
  std::vector<int32_t> pads;
  PadMode padMode;
  int32_t inputCount;
  int32_t outputCount;
  bool relu;
  bool relu6;
  Convolution3DCommonT()
      : padMode(PadMode_CAFFE),
        inputCount(0),
        outputCount(0),
        relu(false),
        relu6(false) {
  }
};

struct Convolution3DCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution3DCommonT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution3DCommonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DILATES = 4,
    VT_STRIDES = 6,
    VT_KERNELS = 8,
    VT_PADS = 10,
    VT_PADMODE = 12,
    VT_INPUTCOUNT = 14,
    VT_OUTPUTCOUNT = 16,
    VT_RELU = 18,
    VT_RELU6 = 20
  };
  const flatbuffers::Vector<int32_t> *dilates() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DILATES);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  const flatbuffers::Vector<int32_t> *kernels() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNELS);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t inputCount() const {
    return GetField<int32_t>(VT_INPUTCOUNT, 0);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(VT_RELU, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(VT_RELU6, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DILATES) &&
           verifier.VerifyVector(dilates()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyVector(kernels()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_INPUTCOUNT) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT) &&
           VerifyField<uint8_t>(verifier, VT_RELU) &&
           VerifyField<uint8_t>(verifier, VT_RELU6) &&
           verifier.EndTable();
  }
  Convolution3DCommonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution3DCommonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution3DCommon> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution3DCommonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dilates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilates) {
    fbb_.AddOffset(Convolution3DCommon::VT_DILATES, dilates);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Convolution3DCommon::VT_STRIDES, strides);
  }
  void add_kernels(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels) {
    fbb_.AddOffset(Convolution3DCommon::VT_KERNELS, kernels);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Convolution3DCommon::VT_PADS, pads);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Convolution3DCommon::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(Convolution3DCommon::VT_INPUTCOUNT, inputCount, 0);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(Convolution3DCommon::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(Convolution3DCommon::VT_RELU, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(Convolution3DCommon::VT_RELU6, static_cast<uint8_t>(relu6), 0);
  }
  explicit Convolution3DCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Convolution3DCommonBuilder &operator=(const Convolution3DCommonBuilder &);
  flatbuffers::Offset<Convolution3DCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution3DCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilates = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    PadMode padMode = PadMode_CAFFE,
    int32_t inputCount = 0,
    int32_t outputCount = 0,
    bool relu = false,
    bool relu6 = false) {
  Convolution3DCommonBuilder builder_(_fbb);
  builder_.add_outputCount(outputCount);
  builder_.add_inputCount(inputCount);
  builder_.add_pads(pads);
  builder_.add_kernels(kernels);
  builder_.add_strides(strides);
  builder_.add_dilates(dilates);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dilates = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    const std::vector<int32_t> *kernels = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    PadMode padMode = PadMode_CAFFE,
    int32_t inputCount = 0,
    int32_t outputCount = 0,
    bool relu = false,
    bool relu6 = false) {
  auto dilates__ = dilates ? _fbb.CreateVector<int32_t>(*dilates) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto kernels__ = kernels ? _fbb.CreateVector<int32_t>(*kernels) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return MNN::CreateConvolution3DCommon(
      _fbb,
      dilates__,
      strides__,
      kernels__,
      pads__,
      padMode,
      inputCount,
      outputCount,
      relu,
      relu6);
}

flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IDSTQuanT : public flatbuffers::NativeTable {
  typedef IDSTQuan TableType;
  std::vector<int8_t> buffer;
  std::vector<float> alpha;
  int32_t type;
  bool useInt32;
  float quantScale;
  float scaleIn;
  float scaleOut;
  int32_t aMax;
  int32_t aMin;
  int32_t readType;
  bool has_scaleInt;
  IDSTQuanT()
      : type(0),
        useInt32(false),
        quantScale(0.0f),
        scaleIn(0.0f),
        scaleOut(0.0f),
        aMax(0),
        aMin(0),
        readType(0),
        has_scaleInt(false) {
  }
};

struct IDSTQuan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IDSTQuanT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IDSTQuanTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4,
    VT_ALPHA = 6,
    VT_TYPE = 8,
    VT_USEINT32 = 10,
    VT_QUANTSCALE = 12,
    VT_SCALEIN = 14,
    VT_SCALEOUT = 16,
    VT_AMAX = 18,
    VT_AMIN = 20,
    VT_READTYPE = 22,
    VT_HAS_SCALEINT = 24
  };
  const flatbuffers::Vector<int8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_BUFFER);
  }
  const flatbuffers::Vector<float> *alpha() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ALPHA);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool useInt32() const {
    return GetField<uint8_t>(VT_USEINT32, 0) != 0;
  }
  float quantScale() const {
    return GetField<float>(VT_QUANTSCALE, 0.0f);
  }
  float scaleIn() const {
    return GetField<float>(VT_SCALEIN, 0.0f);
  }
  float scaleOut() const {
    return GetField<float>(VT_SCALEOUT, 0.0f);
  }
  int32_t aMax() const {
    return GetField<int32_t>(VT_AMAX, 0);
  }
  int32_t aMin() const {
    return GetField<int32_t>(VT_AMIN, 0);
  }
  int32_t readType() const {
    return GetField<int32_t>(VT_READTYPE, 0);
  }
  bool has_scaleInt() const {
    return GetField<uint8_t>(VT_HAS_SCALEINT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyVector(alpha()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_USEINT32) &&
           VerifyField<float>(verifier, VT_QUANTSCALE) &&
           VerifyField<float>(verifier, VT_SCALEIN) &&
           VerifyField<float>(verifier, VT_SCALEOUT) &&
           VerifyField<int32_t>(verifier, VT_AMAX) &&
           VerifyField<int32_t>(verifier, VT_AMIN) &&
           VerifyField<int32_t>(verifier, VT_READTYPE) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SCALEINT) &&
           verifier.EndTable();
  }
  IDSTQuanT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IDSTQuanT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IDSTQuan> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IDSTQuanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer) {
    fbb_.AddOffset(IDSTQuan::VT_BUFFER, buffer);
  }
  void add_alpha(flatbuffers::Offset<flatbuffers::Vector<float>> alpha) {
    fbb_.AddOffset(IDSTQuan::VT_ALPHA, alpha);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_TYPE, type, 0);
  }
  void add_useInt32(bool useInt32) {
    fbb_.AddElement<uint8_t>(IDSTQuan::VT_USEINT32, static_cast<uint8_t>(useInt32), 0);
  }
  void add_quantScale(float quantScale) {
    fbb_.AddElement<float>(IDSTQuan::VT_QUANTSCALE, quantScale, 0.0f);
  }
  void add_scaleIn(float scaleIn) {
    fbb_.AddElement<float>(IDSTQuan::VT_SCALEIN, scaleIn, 0.0f);
  }
  void add_scaleOut(float scaleOut) {
    fbb_.AddElement<float>(IDSTQuan::VT_SCALEOUT, scaleOut, 0.0f);
  }
  void add_aMax(int32_t aMax) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_AMAX, aMax, 0);
  }
  void add_aMin(int32_t aMin) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_AMIN, aMin, 0);
  }
  void add_readType(int32_t readType) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_READTYPE, readType, 0);
  }
  void add_has_scaleInt(bool has_scaleInt) {
    fbb_.AddElement<uint8_t>(IDSTQuan::VT_HAS_SCALEINT, static_cast<uint8_t>(has_scaleInt), 0);
  }
  explicit IDSTQuanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IDSTQuanBuilder &operator=(const IDSTQuanBuilder &);
  flatbuffers::Offset<IDSTQuan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IDSTQuan>(end);
    return o;
  }
};

inline flatbuffers::Offset<IDSTQuan> CreateIDSTQuan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> alpha = 0,
    int32_t type = 0,
    bool useInt32 = false,
    float quantScale = 0.0f,
    float scaleIn = 0.0f,
    float scaleOut = 0.0f,
    int32_t aMax = 0,
    int32_t aMin = 0,
    int32_t readType = 0,
    bool has_scaleInt = false) {
  IDSTQuanBuilder builder_(_fbb);
  builder_.add_readType(readType);
  builder_.add_aMin(aMin);
  builder_.add_aMax(aMax);
  builder_.add_scaleOut(scaleOut);
  builder_.add_scaleIn(scaleIn);
  builder_.add_quantScale(quantScale);
  builder_.add_type(type);
  builder_.add_alpha(alpha);
  builder_.add_buffer(buffer);
  builder_.add_has_scaleInt(has_scaleInt);
  builder_.add_useInt32(useInt32);
  return builder_.Finish();
}

inline flatbuffers::Offset<IDSTQuan> CreateIDSTQuanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *buffer = nullptr,
    const std::vector<float> *alpha = nullptr,
    int32_t type = 0,
    bool useInt32 = false,
    float quantScale = 0.0f,
    float scaleIn = 0.0f,
    float scaleOut = 0.0f,
    int32_t aMax = 0,
    int32_t aMin = 0,
    int32_t readType = 0,
    bool has_scaleInt = false) {
  auto buffer__ = buffer ? _fbb.CreateVector<int8_t>(*buffer) : 0;
  auto alpha__ = alpha ? _fbb.CreateVector<float>(*alpha) : 0;
  return MNN::CreateIDSTQuan(
      _fbb,
      buffer__,
      alpha__,
      type,
      useInt32,
      quantScale,
      scaleIn,
      scaleOut,
      aMax,
      aMin,
      readType,
      has_scaleInt);
}

flatbuffers::Offset<IDSTQuan> CreateIDSTQuan(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizedFloatParamT : public flatbuffers::NativeTable {
  typedef QuantizedFloatParam TableType;
  std::vector<int8_t> weight;
  std::vector<int32_t> bias;
  std::vector<float> scale;
  std::vector<float> tensorScale;
  QuantizedFloatParamT() {
  }
};

struct QuantizedFloatParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizedFloatParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantizedFloatParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEIGHT = 4,
    VT_BIAS = 6,
    VT_SCALE = 8,
    VT_TENSORSCALE = 10
  };
  const flatbuffers::Vector<int8_t> *weight() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<int32_t> *bias() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BIAS);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  const flatbuffers::Vector<float> *tensorScale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_TENSORSCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, VT_TENSORSCALE) &&
           verifier.VerifyVector(tensorScale()) &&
           verifier.EndTable();
  }
  QuantizedFloatParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizedFloatParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizedFloatParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizedFloatParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<int8_t>> weight) {
    fbb_.AddOffset(QuantizedFloatParam::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<int32_t>> bias) {
    fbb_.AddOffset(QuantizedFloatParam::VT_BIAS, bias);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(QuantizedFloatParam::VT_SCALE, scale);
  }
  void add_tensorScale(flatbuffers::Offset<flatbuffers::Vector<float>> tensorScale) {
    fbb_.AddOffset(QuantizedFloatParam::VT_TENSORSCALE, tensorScale);
  }
  explicit QuantizedFloatParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizedFloatParamBuilder &operator=(const QuantizedFloatParamBuilder &);
  flatbuffers::Offset<QuantizedFloatParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizedFloatParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> tensorScale = 0) {
  QuantizedFloatParamBuilder builder_(_fbb);
  builder_.add_tensorScale(tensorScale);
  builder_.add_scale(scale);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *weight = nullptr,
    const std::vector<int32_t> *bias = nullptr,
    const std::vector<float> *scale = nullptr,
    const std::vector<float> *tensorScale = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<int8_t>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<int32_t>(*bias) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto tensorScale__ = tensorScale ? _fbb.CreateVector<float>(*tensorScale) : 0;
  return MNN::CreateQuantizedFloatParam(
      _fbb,
      weight__,
      bias__,
      scale__,
      tensorScale__);
}

flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParam(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Convolution2DT : public flatbuffers::NativeTable {
  typedef Convolution2D TableType;
  std::unique_ptr<Convolution2DCommonT> common;
  std::vector<float> weight;
  std::vector<float> bias;
  std::unique_ptr<IDSTQuanT> quanParameter;
  std::unique_ptr<QuantizedFloatParamT> symmetricQuan;
  Convolution2DT() {
  }
};

struct Convolution2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution2DT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution2DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_QUANPARAMETER = 10,
    VT_SYMMETRICQUAN = 12
  };
  const Convolution2DCommon *common() const {
    return GetPointer<const Convolution2DCommon *>(VT_COMMON);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  const IDSTQuan *quanParameter() const {
    return GetPointer<const IDSTQuan *>(VT_QUANPARAMETER);
  }
  const QuantizedFloatParam *symmetricQuan() const {
    return GetPointer<const QuantizedFloatParam *>(VT_SYMMETRICQUAN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, VT_QUANPARAMETER) &&
           verifier.VerifyTable(quanParameter()) &&
           VerifyOffset(verifier, VT_SYMMETRICQUAN) &&
           verifier.VerifyTable(symmetricQuan()) &&
           verifier.EndTable();
  }
  Convolution2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<Convolution2DCommon> common) {
    fbb_.AddOffset(Convolution2D::VT_COMMON, common);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(Convolution2D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(Convolution2D::VT_BIAS, bias);
  }
  void add_quanParameter(flatbuffers::Offset<IDSTQuan> quanParameter) {
    fbb_.AddOffset(Convolution2D::VT_QUANPARAMETER, quanParameter);
  }
  void add_symmetricQuan(flatbuffers::Offset<QuantizedFloatParam> symmetricQuan) {
    fbb_.AddOffset(Convolution2D::VT_SYMMETRICQUAN, symmetricQuan);
  }
  explicit Convolution2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Convolution2DBuilder &operator=(const Convolution2DBuilder &);
  flatbuffers::Offset<Convolution2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution2D> CreateConvolution2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Convolution2DCommon> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    flatbuffers::Offset<IDSTQuan> quanParameter = 0,
    flatbuffers::Offset<QuantizedFloatParam> symmetricQuan = 0) {
  Convolution2DBuilder builder_(_fbb);
  builder_.add_symmetricQuan(symmetricQuan);
  builder_.add_quanParameter(quanParameter);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<Convolution2D> CreateConvolution2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Convolution2DCommon> common = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    flatbuffers::Offset<IDSTQuan> quanParameter = 0,
    flatbuffers::Offset<QuantizedFloatParam> symmetricQuan = 0) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return MNN::CreateConvolution2D(
      _fbb,
      common,
      weight__,
      bias__,
      quanParameter,
      symmetricQuan);
}

flatbuffers::Offset<Convolution2D> CreateConvolution2D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Convolution3DT : public flatbuffers::NativeTable {
  typedef Convolution3D TableType;
  std::unique_ptr<Convolution3DCommonT> common;
  std::vector<float> weight;
  std::vector<float> bias;
  Convolution3DT() {
  }
};

struct Convolution3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution3DT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution3DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8
  };
  const Convolution3DCommon *common() const {
    return GetPointer<const Convolution3DCommon *>(VT_COMMON);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           verifier.EndTable();
  }
  Convolution3DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution3DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution3D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution3DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<Convolution3DCommon> common) {
    fbb_.AddOffset(Convolution3D::VT_COMMON, common);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(Convolution3D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(Convolution3D::VT_BIAS, bias);
  }
  explicit Convolution3DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Convolution3DBuilder &operator=(const Convolution3DBuilder &);
  flatbuffers::Offset<Convolution3D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution3D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution3D> CreateConvolution3D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Convolution3DCommon> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0) {
  Convolution3DBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<Convolution3D> CreateConvolution3DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Convolution3DCommon> common = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return MNN::CreateConvolution3D(
      _fbb,
      common,
      weight__,
      bias__);
}

flatbuffers::Offset<Convolution3D> CreateConvolution3D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InnerProductT : public flatbuffers::NativeTable {
  typedef InnerProduct TableType;
  int32_t outputCount;
  int32_t biasTerm;
  int32_t weightSize;
  std::vector<float> weight;
  std::vector<float> bias;
  int32_t axis;
  bool transpose;
  std::unique_ptr<IDSTQuanT> quanParameter;
  InnerProductT()
      : outputCount(0),
        biasTerm(0),
        weightSize(0),
        axis(0),
        transpose(false) {
  }
};

struct InnerProduct FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InnerProductT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InnerProductTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTCOUNT = 4,
    VT_BIASTERM = 6,
    VT_WEIGHTSIZE = 8,
    VT_WEIGHT = 10,
    VT_BIAS = 12,
    VT_AXIS = 14,
    VT_TRANSPOSE = 16,
    VT_QUANPARAMETER = 18
  };
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t biasTerm() const {
    return GetField<int32_t>(VT_BIASTERM, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(VT_WEIGHTSIZE, 0);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool transpose() const {
    return GetField<uint8_t>(VT_TRANSPOSE, 0) != 0;
  }
  const IDSTQuan *quanParameter() const {
    return GetPointer<const IDSTQuan *>(VT_QUANPARAMETER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT) &&
           VerifyField<int32_t>(verifier, VT_BIASTERM) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTSIZE) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE) &&
           VerifyOffset(verifier, VT_QUANPARAMETER) &&
           verifier.VerifyTable(quanParameter()) &&
           verifier.EndTable();
  }
  InnerProductT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InnerProductT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InnerProduct> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InnerProductBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_biasTerm(int32_t biasTerm) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_BIASTERM, biasTerm, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_WEIGHTSIZE, weightSize, 0);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(InnerProduct::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(InnerProduct::VT_BIAS, bias);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_AXIS, axis, 0);
  }
  void add_transpose(bool transpose) {
    fbb_.AddElement<uint8_t>(InnerProduct::VT_TRANSPOSE, static_cast<uint8_t>(transpose), 0);
  }
  void add_quanParameter(flatbuffers::Offset<IDSTQuan> quanParameter) {
    fbb_.AddOffset(InnerProduct::VT_QUANPARAMETER, quanParameter);
  }
  explicit InnerProductBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InnerProductBuilder &operator=(const InnerProductBuilder &);
  flatbuffers::Offset<InnerProduct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InnerProduct>(end);
    return o;
  }
};

inline flatbuffers::Offset<InnerProduct> CreateInnerProduct(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    int32_t axis = 0,
    bool transpose = false,
    flatbuffers::Offset<IDSTQuan> quanParameter = 0) {
  InnerProductBuilder builder_(_fbb);
  builder_.add_quanParameter(quanParameter);
  builder_.add_axis(axis);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_weightSize(weightSize);
  builder_.add_biasTerm(biasTerm);
  builder_.add_outputCount(outputCount);
  builder_.add_transpose(transpose);
  return builder_.Finish();
}

inline flatbuffers::Offset<InnerProduct> CreateInnerProductDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    int32_t axis = 0,
    bool transpose = false,
    flatbuffers::Offset<IDSTQuan> quanParameter = 0) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return MNN::CreateInnerProduct(
      _fbb,
      outputCount,
      biasTerm,
      weightSize,
      weight__,
      bias__,
      axis,
      transpose,
      quanParameter);
}

flatbuffers::Offset<InnerProduct> CreateInnerProduct(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoolT : public flatbuffers::NativeTable {
  typedef Pool TableType;
  int32_t padX;
  int32_t padY;
  bool isGlobal;
  int32_t kernelX;
  int32_t kernelY;
  int32_t strideX;
  int32_t strideY;
  PoolType type;
  PoolPadType padType;
  DataType dataType;
  bool ceilModel;
  PoolT()
      : padX(0),
        padY(0),
        isGlobal(false),
        kernelX(0),
        kernelY(0),
        strideX(0),
        strideY(0),
        type(PoolType_MAXPOOL),
        padType(PoolPadType_CAFFE),
        dataType(DataType_DT_FLOAT),
        ceilModel(true) {
  }
};

struct Pool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoolT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PoolTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADX = 4,
    VT_PADY = 6,
    VT_ISGLOBAL = 8,
    VT_KERNELX = 10,
    VT_KERNELY = 12,
    VT_STRIDEX = 14,
    VT_STRIDEY = 16,
    VT_TYPE = 18,
    VT_PADTYPE = 20,
    VT_DATATYPE = 22,
    VT_CEILMODEL = 24
  };
  int32_t padX() const {
    return GetField<int32_t>(VT_PADX, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(VT_PADY, 0);
  }
  bool isGlobal() const {
    return GetField<uint8_t>(VT_ISGLOBAL, 0) != 0;
  }
  int32_t kernelX() const {
    return GetField<int32_t>(VT_KERNELX, 0);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(VT_KERNELY, 0);
  }
  int32_t strideX() const {
    return GetField<int32_t>(VT_STRIDEX, 0);
  }
  int32_t strideY() const {
    return GetField<int32_t>(VT_STRIDEY, 0);
  }
  PoolType type() const {
    return static_cast<PoolType>(GetField<int8_t>(VT_TYPE, 0));
  }
  PoolPadType padType() const {
    return static_cast<PoolPadType>(GetField<int8_t>(VT_PADTYPE, 0));
  }
  DataType dataType() const {
    return static_cast<DataType>(GetField<int32_t>(VT_DATATYPE, 1));
  }
  bool ceilModel() const {
    return GetField<uint8_t>(VT_CEILMODEL, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PADX) &&
           VerifyField<int32_t>(verifier, VT_PADY) &&
           VerifyField<uint8_t>(verifier, VT_ISGLOBAL) &&
           VerifyField<int32_t>(verifier, VT_KERNELX) &&
           VerifyField<int32_t>(verifier, VT_KERNELY) &&
           VerifyField<int32_t>(verifier, VT_STRIDEX) &&
           VerifyField<int32_t>(verifier, VT_STRIDEY) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int8_t>(verifier, VT_PADTYPE) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyField<uint8_t>(verifier, VT_CEILMODEL) &&
           verifier.EndTable();
  }
  PoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(Pool::VT_PADX, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(Pool::VT_PADY, padY, 0);
  }
  void add_isGlobal(bool isGlobal) {
    fbb_.AddElement<uint8_t>(Pool::VT_ISGLOBAL, static_cast<uint8_t>(isGlobal), 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(Pool::VT_KERNELX, kernelX, 0);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(Pool::VT_KERNELY, kernelY, 0);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(Pool::VT_STRIDEX, strideX, 0);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(Pool::VT_STRIDEY, strideY, 0);
  }
  void add_type(PoolType type) {
    fbb_.AddElement<int8_t>(Pool::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_padType(PoolPadType padType) {
    fbb_.AddElement<int8_t>(Pool::VT_PADTYPE, static_cast<int8_t>(padType), 0);
  }
  void add_dataType(DataType dataType) {
    fbb_.AddElement<int32_t>(Pool::VT_DATATYPE, static_cast<int32_t>(dataType), 1);
  }
  void add_ceilModel(bool ceilModel) {
    fbb_.AddElement<uint8_t>(Pool::VT_CEILMODEL, static_cast<uint8_t>(ceilModel), 1);
  }
  explicit PoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolBuilder &operator=(const PoolBuilder &);
  flatbuffers::Offset<Pool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool> CreatePool(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    bool isGlobal = false,
    int32_t kernelX = 0,
    int32_t kernelY = 0,
    int32_t strideX = 0,
    int32_t strideY = 0,
    PoolType type = PoolType_MAXPOOL,
    PoolPadType padType = PoolPadType_CAFFE,
    DataType dataType = DataType_DT_FLOAT,
    bool ceilModel = true) {
  PoolBuilder builder_(_fbb);
  builder_.add_dataType(dataType);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_ceilModel(ceilModel);
  builder_.add_padType(padType);
  builder_.add_type(type);
  builder_.add_isGlobal(isGlobal);
  return builder_.Finish();
}

flatbuffers::Offset<Pool> CreatePool(flatbuffers::FlatBufferBuilder &_fbb, const PoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool3DT : public flatbuffers::NativeTable {
  typedef Pool3D TableType;
  std::vector<int32_t> strides;
  std::vector<int32_t> kernels;
  std::vector<int32_t> pads;
  PoolType type;
  PoolPadType padType;
  Pool3DT()
      : type(PoolType_MAXPOOL),
        padType(PoolPadType_CAFFE) {
  }
};

struct Pool3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pool3DT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pool3DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIDES = 4,
    VT_KERNELS = 6,
    VT_PADS = 8,
    VT_TYPE = 10,
    VT_PADTYPE = 12
  };
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  const flatbuffers::Vector<int32_t> *kernels() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNELS);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  PoolType type() const {
    return static_cast<PoolType>(GetField<int8_t>(VT_TYPE, 0));
  }
  PoolPadType padType() const {
    return static_cast<PoolPadType>(GetField<int8_t>(VT_PADTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyVector(kernels()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int8_t>(verifier, VT_PADTYPE) &&
           verifier.EndTable();
  }
  Pool3DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool3DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool3D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool3DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Pool3D::VT_STRIDES, strides);
  }
  void add_kernels(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels) {
    fbb_.AddOffset(Pool3D::VT_KERNELS, kernels);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Pool3D::VT_PADS, pads);
  }
  void add_type(PoolType type) {
    fbb_.AddElement<int8_t>(Pool3D::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_padType(PoolPadType padType) {
    fbb_.AddElement<int8_t>(Pool3D::VT_PADTYPE, static_cast<int8_t>(padType), 0);
  }
  explicit Pool3DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Pool3DBuilder &operator=(const Pool3DBuilder &);
  flatbuffers::Offset<Pool3D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool3D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool3D> CreatePool3D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    PoolType type = PoolType_MAXPOOL,
    PoolPadType padType = PoolPadType_CAFFE) {
  Pool3DBuilder builder_(_fbb);
  builder_.add_pads(pads);
  builder_.add_kernels(kernels);
  builder_.add_strides(strides);
  builder_.add_padType(padType);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pool3D> CreatePool3DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *strides = nullptr,
    const std::vector<int32_t> *kernels = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    PoolType type = PoolType_MAXPOOL,
    PoolPadType padType = PoolPadType_CAFFE) {
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto kernels__ = kernels ? _fbb.CreateVector<int32_t>(*kernels) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return MNN::CreatePool3D(
      _fbb,
      strides__,
      kernels__,
      pads__,
      type,
      padType);
}

flatbuffers::Offset<Pool3D> CreatePool3D(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReluT : public flatbuffers::NativeTable {
  typedef Relu TableType;
  float slope;
  ReluT()
      : slope(0.0f) {
  }
};

struct Relu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReluT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReluTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPE = 4
  };
  float slope() const {
    return GetField<float>(VT_SLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SLOPE) &&
           verifier.EndTable();
  }
  ReluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Relu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slope(float slope) {
    fbb_.AddElement<float>(Relu::VT_SLOPE, slope, 0.0f);
  }
  explicit ReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReluBuilder &operator=(const ReluBuilder &);
  flatbuffers::Offset<Relu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu> CreateRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float slope = 0.0f) {
  ReluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  return builder_.Finish();
}

flatbuffers::Offset<Relu> CreateRelu(flatbuffers::FlatBufferBuilder &_fbb, const ReluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Relu6T : public flatbuffers::NativeTable {
  typedef Relu6 TableType;
  float slope;
  Relu6T()
      : slope(0.0f) {
  }
};

struct Relu6 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Relu6T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Relu6TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPE = 4
  };
  float slope() const {
    return GetField<float>(VT_SLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SLOPE) &&
           verifier.EndTable();
  }
  Relu6T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Relu6T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Relu6> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Relu6Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slope(float slope) {
    fbb_.AddElement<float>(Relu6::VT_SLOPE, slope, 0.0f);
  }
  explicit Relu6Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Relu6Builder &operator=(const Relu6Builder &);
  flatbuffers::Offset<Relu6> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu6>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu6> CreateRelu6(
    flatbuffers::FlatBufferBuilder &_fbb,
    float slope = 0.0f) {
  Relu6Builder builder_(_fbb);
  builder_.add_slope(slope);
  return builder_.Finish();
}

flatbuffers::Offset<Relu6> CreateRelu6(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PReluT : public flatbuffers::NativeTable {
  typedef PRelu TableType;
  int32_t slopeCount;
  std::vector<float> slope;
  PReluT()
      : slopeCount(0) {
  }
};

struct PRelu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PReluT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PReluTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPECOUNT = 4,
    VT_SLOPE = 6
  };
  int32_t slopeCount() const {
    return GetField<int32_t>(VT_SLOPECOUNT, 0);
  }
  const flatbuffers::Vector<float> *slope() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SLOPECOUNT) &&
           VerifyOffset(verifier, VT_SLOPE) &&
           verifier.VerifyVector(slope()) &&
           verifier.EndTable();
  }
  PReluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PReluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PRelu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PReluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slopeCount(int32_t slopeCount) {
    fbb_.AddElement<int32_t>(PRelu::VT_SLOPECOUNT, slopeCount, 0);
  }
  void add_slope(flatbuffers::Offset<flatbuffers::Vector<float>> slope) {
    fbb_.AddOffset(PRelu::VT_SLOPE, slope);
  }
  explicit PReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PReluBuilder &operator=(const PReluBuilder &);
  flatbuffers::Offset<PRelu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PRelu>(end);
    return o;
  }
};

inline flatbuffers::Offset<PRelu> CreatePRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slopeCount = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slope = 0) {
  PReluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  builder_.add_slopeCount(slopeCount);
  return builder_.Finish();
}

inline flatbuffers::Offset<PRelu> CreatePReluDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slopeCount = 0,
    const std::vector<float> *slope = nullptr) {
  auto slope__ = slope ? _fbb.CreateVector<float>(*slope) : 0;
  return MNN::CreatePRelu(
      _fbb,
      slopeCount,
      slope__);
}

flatbuffers::Offset<PRelu> CreatePRelu(flatbuffers::FlatBufferBuilder &_fbb, const PReluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ELUT : public flatbuffers::NativeTable {
  typedef ELU TableType;
  float alpha;
  ELUT()
      : alpha(0.0f) {
  }
};

struct ELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ELUT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ELUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
  ELUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ELUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ELU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ELUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ELUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ELU::VT_ALPHA, alpha, 0.0f);
  }
  explicit ELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ELUBuilder &operator=(const ELUBuilder &);
  flatbuffers::Offset<ELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ELU>(end);
    return o;
  }
};

inline flatbuffers::Offset<ELU> CreateELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  ELUBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<ELU> CreateELU(flatbuffers::FlatBufferBuilder &_fbb, const ELUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LRNT : public flatbuffers::NativeTable {
  typedef LRN TableType;
  int32_t regionType;
  int32_t localSize;
  float alpha;
  float beta;
  LRNT()
      : regionType(0),
        localSize(0),
        alpha(0.0f),
        beta(0.0f) {
  }
};

struct LRN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LRNT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LRNTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGIONTYPE = 4,
    VT_LOCALSIZE = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t regionType() const {
    return GetField<int32_t>(VT_REGIONTYPE, 0);
  }
  int32_t localSize() const {
    return GetField<int32_t>(VT_LOCALSIZE, 0);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REGIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_LOCALSIZE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  LRNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LRN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LRNBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_regionType(int32_t regionType) {
    fbb_.AddElement<int32_t>(LRN::VT_REGIONTYPE, regionType, 0);
  }
  void add_localSize(int32_t localSize) {
    fbb_.AddElement<int32_t>(LRN::VT_LOCALSIZE, localSize, 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LRN::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LRN::VT_BETA, beta, 0.0f);
  }
  explicit LRNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LRNBuilder &operator=(const LRNBuilder &);
  flatbuffers::Offset<LRN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LRN>(end);
    return o;
  }
};

inline flatbuffers::Offset<LRN> CreateLRN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t regionType = 0,
    int32_t localSize = 0,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LRNBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_localSize(localSize);
  builder_.add_regionType(regionType);
  return builder_.Finish();
}

flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxT : public flatbuffers::NativeTable {
  typedef ArgMax TableType;
  int32_t outMaxVal;
  int32_t topK;
  int32_t axis;
  int32_t softmaxThreshold;
  ArgMaxT()
      : outMaxVal(0),
        topK(0),
        axis(0),
        softmaxThreshold(0) {
  }
};

struct ArgMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMaxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTMAXVAL = 4,
    VT_TOPK = 6,
    VT_AXIS = 8,
    VT_SOFTMAXTHRESHOLD = 10
  };
  int32_t outMaxVal() const {
    return GetField<int32_t>(VT_OUTMAXVAL, 0);
  }
  int32_t topK() const {
    return GetField<int32_t>(VT_TOPK, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t softmaxThreshold() const {
    return GetField<int32_t>(VT_SOFTMAXTHRESHOLD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTMAXVAL) &&
           VerifyField<int32_t>(verifier, VT_TOPK) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_SOFTMAXTHRESHOLD) &&
           verifier.EndTable();
  }
  ArgMaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outMaxVal(int32_t outMaxVal) {
    fbb_.AddElement<int32_t>(ArgMax::VT_OUTMAXVAL, outMaxVal, 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(ArgMax::VT_TOPK, topK, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMax::VT_AXIS, axis, 0);
  }
  void add_softmaxThreshold(int32_t softmaxThreshold) {
    fbb_.AddElement<int32_t>(ArgMax::VT_SOFTMAXTHRESHOLD, softmaxThreshold, 0);
  }
  explicit ArgMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxBuilder &operator=(const ArgMaxBuilder &);
  flatbuffers::Offset<ArgMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMax> CreateArgMax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outMaxVal = 0,
    int32_t topK = 0,
    int32_t axis = 0,
    int32_t softmaxThreshold = 0) {
  ArgMaxBuilder builder_(_fbb);
  builder_.add_softmaxThreshold(softmaxThreshold);
  builder_.add_axis(axis);
  builder_.add_topK(topK);
  builder_.add_outMaxVal(outMaxVal);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMax> CreateArgMax(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AxisT : public flatbuffers::NativeTable {
  typedef Axis TableType;
  int32_t axis;
  AxisT()
      : axis(0) {
  }
};

struct Axis FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AxisT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AxisTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  AxisT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AxisT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Axis> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AxisT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AxisBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Axis::VT_AXIS, axis, 0);
  }
  explicit AxisBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AxisBuilder &operator=(const AxisBuilder &);
  flatbuffers::Offset<Axis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Axis>(end);
    return o;
  }
};

inline flatbuffers::Offset<Axis> CreateAxis(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  AxisBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Axis> CreateAxis(flatbuffers::FlatBufferBuilder &_fbb, const AxisT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputT : public flatbuffers::NativeTable {
  typedef Input TableType;
  std::vector<int32_t> dims;
  DataType dtype;
  MNN_DATA_FORMAT dformat;
  InputT()
      : dtype(DataType_DT_FLOAT),
        dformat(MNN_DATA_FORMAT_NC4HW4) {
  }
};

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DTYPE = 6,
    VT_DFORMAT = 8
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  DataType dtype() const {
    return static_cast<DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  MNN_DATA_FORMAT dformat() const {
    return static_cast<MNN_DATA_FORMAT>(GetField<int8_t>(VT_DFORMAT, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_DTYPE) &&
           VerifyField<int8_t>(verifier, VT_DFORMAT) &&
           verifier.EndTable();
  }
  InputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Input> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Input::VT_DIMS, dims);
  }
  void add_dtype(DataType dtype) {
    fbb_.AddElement<int32_t>(Input::VT_DTYPE, static_cast<int32_t>(dtype), 1);
  }
  void add_dformat(MNN_DATA_FORMAT dformat) {
    fbb_.AddElement<int8_t>(Input::VT_DFORMAT, static_cast<int8_t>(dformat), 2);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputBuilder &operator=(const InputBuilder &);
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    DataType dtype = DataType_DT_FLOAT,
    MNN_DATA_FORMAT dformat = MNN_DATA_FORMAT_NC4HW4) {
  InputBuilder builder_(_fbb);
  builder_.add_dtype(dtype);
  builder_.add_dims(dims);
  builder_.add_dformat(dformat);
  return builder_.Finish();
}

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr,
    DataType dtype = DataType_DT_FLOAT,
    MNN_DATA_FORMAT dformat = MNN_DATA_FORMAT_NC4HW4) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return MNN::CreateInput(
      _fbb,
      dims__,
      dtype,
      dformat);
}

flatbuffers::Offset<Input> CreateInput(flatbuffers::FlatBufferBuilder &_fbb, const InputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMT : public flatbuffers::NativeTable {
  typedef LSTM TableType;
  int32_t outputCount;
  int32_t weightSize;
  float clippingThreshold;
  std::unique_ptr<BlobT> weightI;
  std::unique_ptr<BlobT> weightH;
  std::unique_ptr<BlobT> bias;
  std::unique_ptr<BlobT> weightIQ;
  std::unique_ptr<BlobT> weightIA;
  float quantScale;
  LSTMT()
      : outputCount(0),
        weightSize(0),
        clippingThreshold(0.0f),
        quantScale(0.0f) {
  }
};

struct LSTM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LSTMTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTCOUNT = 4,
    VT_WEIGHTSIZE = 6,
    VT_CLIPPINGTHRESHOLD = 8,
    VT_WEIGHTI = 10,
    VT_WEIGHTH = 12,
    VT_BIAS = 14,
    VT_WEIGHTIQ = 16,
    VT_WEIGHTIA = 18,
    VT_QUANTSCALE = 20
  };
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(VT_WEIGHTSIZE, 0);
  }
  float clippingThreshold() const {
    return GetField<float>(VT_CLIPPINGTHRESHOLD, 0.0f);
  }
  const Blob *weightI() const {
    return GetPointer<const Blob *>(VT_WEIGHTI);
  }
  const Blob *weightH() const {
    return GetPointer<const Blob *>(VT_WEIGHTH);
  }
  const Blob *bias() const {
    return GetPointer<const Blob *>(VT_BIAS);
  }
  const Blob *weightIQ() const {
    return GetPointer<const Blob *>(VT_WEIGHTIQ);
  }
  const Blob *weightIA() const {
    return GetPointer<const Blob *>(VT_WEIGHTIA);
  }
  float quantScale() const {
    return GetField<float>(VT_QUANTSCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTSIZE) &&
           VerifyField<float>(verifier, VT_CLIPPINGTHRESHOLD) &&
           VerifyOffset(verifier, VT_WEIGHTI) &&
           verifier.VerifyTable(weightI()) &&
           VerifyOffset(verifier, VT_WEIGHTH) &&
           verifier.VerifyTable(weightH()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyTable(bias()) &&
           VerifyOffset(verifier, VT_WEIGHTIQ) &&
           verifier.VerifyTable(weightIQ()) &&
           VerifyOffset(verifier, VT_WEIGHTIA) &&
           verifier.VerifyTable(weightIA()) &&
           VerifyField<float>(verifier, VT_QUANTSCALE) &&
           verifier.EndTable();
  }
  LSTMT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSTM> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(LSTM::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(LSTM::VT_WEIGHTSIZE, weightSize, 0);
  }
  void add_clippingThreshold(float clippingThreshold) {
    fbb_.AddElement<float>(LSTM::VT_CLIPPINGTHRESHOLD, clippingThreshold, 0.0f);
  }
  void add_weightI(flatbuffers::Offset<Blob> weightI) {
    fbb_.AddOffset(LSTM::VT_WEIGHTI, weightI);
  }
  void add_weightH(flatbuffers::Offset<Blob> weightH) {
    fbb_.AddOffset(LSTM::VT_WEIGHTH, weightH);
  }
  void add_bias(flatbuffers::Offset<Blob> bias) {
    fbb_.AddOffset(LSTM::VT_BIAS, bias);
  }
  void add_weightIQ(flatbuffers::Offset<Blob> weightIQ) {
    fbb_.AddOffset(LSTM::VT_WEIGHTIQ, weightIQ);
  }
  void add_weightIA(flatbuffers::Offset<Blob> weightIA) {
    fbb_.AddOffset(LSTM::VT_WEIGHTIA, weightIA);
  }
  void add_quantScale(float quantScale) {
    fbb_.AddElement<float>(LSTM::VT_QUANTSCALE, quantScale, 0.0f);
  }
  explicit LSTMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSTMBuilder &operator=(const LSTMBuilder &);
  flatbuffers::Offset<LSTM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTM>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTM> CreateLSTM(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t weightSize = 0,
    float clippingThreshold = 0.0f,
    flatbuffers::Offset<Blob> weightI = 0,
    flatbuffers::Offset<Blob> weightH = 0,
    flatbuffers::Offset<Blob> bias = 0,
    flatbuffers::Offset<Blob> weightIQ = 0,
    flatbuffers::Offset<Blob> weightIA = 0,
    float quantScale = 0.0f) {
  LSTMBuilder builder_(_fbb);
  builder_.add_quantScale(quantScale);
  builder_.add_weightIA(weightIA);
  builder_.add_weightIQ(weightIQ);
  builder_.add_bias(bias);
  builder_.add_weightH(weightH);
  builder_.add_weightI(weightI);
  builder_.add_clippingThreshold(clippingThreshold);
  builder_.add_weightSize(weightSize);
  builder_.add_outputCount(outputCount);
  return builder_.Finish();
}

flatbuffers::Offset<LSTM> CreateLSTM(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceT : public flatbuffers::NativeTable {
  typedef Slice TableType;
  int32_t axis;
  std::vector<int32_t> slicePoints;
  NetSource sourceType;
  SliceT()
      : axis(0),
        sourceType(NetSource_CAFFE) {
  }
};

struct Slice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SliceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_SLICEPOINTS = 6,
    VT_SOURCETYPE = 8
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *slicePoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SLICEPOINTS);
  }
  NetSource sourceType() const {
    return static_cast<NetSource>(GetField<int8_t>(VT_SOURCETYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_SLICEPOINTS) &&
           verifier.VerifyVector(slicePoints()) &&
           VerifyField<int8_t>(verifier, VT_SOURCETYPE) &&
           verifier.EndTable();
  }
  SliceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Slice> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Slice::VT_AXIS, axis, 0);
  }
  void add_slicePoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> slicePoints) {
    fbb_.AddOffset(Slice::VT_SLICEPOINTS, slicePoints);
  }
  void add_sourceType(NetSource sourceType) {
    fbb_.AddElement<int8_t>(Slice::VT_SOURCETYPE, static_cast<int8_t>(sourceType), 0);
  }
  explicit SliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceBuilder &operator=(const SliceBuilder &);
  flatbuffers::Offset<Slice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Slice>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slice> CreateSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> slicePoints = 0,
    NetSource sourceType = NetSource_CAFFE) {
  SliceBuilder builder_(_fbb);
  builder_.add_slicePoints(slicePoints);
  builder_.add_axis(axis);
  builder_.add_sourceType(sourceType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Slice> CreateSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    const std::vector<int32_t> *slicePoints = nullptr,
    NetSource sourceType = NetSource_CAFFE) {
  auto slicePoints__ = slicePoints ? _fbb.CreateVector<int32_t>(*slicePoints) : 0;
  return MNN::CreateSlice(
      _fbb,
      axis,
      slicePoints__,
      sourceType);
}

flatbuffers::Offset<Slice> CreateSlice(flatbuffers::FlatBufferBuilder &_fbb, const SliceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchNormT : public flatbuffers::NativeTable {
  typedef BatchNorm TableType;
  int32_t channels;
  std::vector<float> slopeData;
  std::vector<float> meanData;
  std::vector<float> varData;
  std::vector<float> biasData;
  std::vector<float> Adata;
  std::vector<float> Bdata;
  float epsilon;
  BatchNormT()
      : channels(0),
        epsilon(0.001f) {
  }
};

struct BatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_SLOPEDATA = 6,
    VT_MEANDATA = 8,
    VT_VARDATA = 10,
    VT_BIASDATA = 12,
    VT_ADATA = 14,
    VT_BDATA = 16,
    VT_EPSILON = 18
  };
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  const flatbuffers::Vector<float> *slopeData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPEDATA);
  }
  const flatbuffers::Vector<float> *meanData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MEANDATA);
  }
  const flatbuffers::Vector<float> *varData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARDATA);
  }
  const flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIASDATA);
  }
  const flatbuffers::Vector<float> *Adata() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ADATA);
  }
  const flatbuffers::Vector<float> *Bdata() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BDATA);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.001f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS) &&
           VerifyOffset(verifier, VT_SLOPEDATA) &&
           verifier.VerifyVector(slopeData()) &&
           VerifyOffset(verifier, VT_MEANDATA) &&
           verifier.VerifyVector(meanData()) &&
           VerifyOffset(verifier, VT_VARDATA) &&
           verifier.VerifyVector(varData()) &&
           VerifyOffset(verifier, VT_BIASDATA) &&
           verifier.VerifyVector(biasData()) &&
           VerifyOffset(verifier, VT_ADATA) &&
           verifier.VerifyVector(Adata()) &&
           VerifyOffset(verifier, VT_BDATA) &&
           verifier.VerifyVector(Bdata()) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
  BatchNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchNormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(BatchNorm::VT_CHANNELS, channels, 0);
  }
  void add_slopeData(flatbuffers::Offset<flatbuffers::Vector<float>> slopeData) {
    fbb_.AddOffset(BatchNorm::VT_SLOPEDATA, slopeData);
  }
  void add_meanData(flatbuffers::Offset<flatbuffers::Vector<float>> meanData) {
    fbb_.AddOffset(BatchNorm::VT_MEANDATA, meanData);
  }
  void add_varData(flatbuffers::Offset<flatbuffers::Vector<float>> varData) {
    fbb_.AddOffset(BatchNorm::VT_VARDATA, varData);
  }
  void add_biasData(flatbuffers::Offset<flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(BatchNorm::VT_BIASDATA, biasData);
  }
  void add_Adata(flatbuffers::Offset<flatbuffers::Vector<float>> Adata) {
    fbb_.AddOffset(BatchNorm::VT_ADATA, Adata);
  }
  void add_Bdata(flatbuffers::Offset<flatbuffers::Vector<float>> Bdata) {
    fbb_.AddOffset(BatchNorm::VT_BDATA, Bdata);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNorm::VT_EPSILON, epsilon, 0.001f);
  }
  explicit BatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchNormBuilder &operator=(const BatchNormBuilder &);
  flatbuffers::Offset<BatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slopeData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> meanData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> varData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> biasData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Adata = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Bdata = 0,
    float epsilon = 0.001f) {
  BatchNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_Bdata(Bdata);
  builder_.add_Adata(Adata);
  builder_.add_biasData(biasData);
  builder_.add_varData(varData);
  builder_.add_meanData(meanData);
  builder_.add_slopeData(slopeData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchNorm> CreateBatchNormDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    const std::vector<float> *slopeData = nullptr,
    const std::vector<float> *meanData = nullptr,
    const std::vector<float> *varData = nullptr,
    const std::vector<float> *biasData = nullptr,
    const std::vector<float> *Adata = nullptr,
    const std::vector<float> *Bdata = nullptr,
    float epsilon = 0.001f) {
  auto slopeData__ = slopeData ? _fbb.CreateVector<float>(*slopeData) : 0;
  auto meanData__ = meanData ? _fbb.CreateVector<float>(*meanData) : 0;
  auto varData__ = varData ? _fbb.CreateVector<float>(*varData) : 0;
  auto biasData__ = biasData ? _fbb.CreateVector<float>(*biasData) : 0;
  auto Adata__ = Adata ? _fbb.CreateVector<float>(*Adata) : 0;
  auto Bdata__ = Bdata ? _fbb.CreateVector<float>(*Bdata) : 0;
  return MNN::CreateBatchNorm(
      _fbb,
      channels,
      slopeData__,
      meanData__,
      varData__,
      biasData__,
      Adata__,
      Bdata__,
      epsilon);
}

flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScaleT : public flatbuffers::NativeTable {
  typedef Scale TableType;
  int32_t channels;
  std::vector<float> scaleData;
  std::vector<float> biasData;
  ScaleT()
      : channels(0) {
  }
};

struct Scale FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScaleT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScaleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_SCALEDATA = 6,
    VT_BIASDATA = 8
  };
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  const flatbuffers::Vector<float> *scaleData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALEDATA);
  }
  const flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIASDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS) &&
           VerifyOffset(verifier, VT_SCALEDATA) &&
           verifier.VerifyVector(scaleData()) &&
           VerifyOffset(verifier, VT_BIASDATA) &&
           verifier.VerifyVector(biasData()) &&
           verifier.EndTable();
  }
  ScaleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScaleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Scale> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScaleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(Scale::VT_CHANNELS, channels, 0);
  }
  void add_scaleData(flatbuffers::Offset<flatbuffers::Vector<float>> scaleData) {
    fbb_.AddOffset(Scale::VT_SCALEDATA, scaleData);
  }
  void add_biasData(flatbuffers::Offset<flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(Scale::VT_BIASDATA, biasData);
  }
  explicit ScaleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScaleBuilder &operator=(const ScaleBuilder &);
  flatbuffers::Offset<Scale> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scale>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scale> CreateScale(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scaleData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> biasData = 0) {
  ScaleBuilder builder_(_fbb);
  builder_.add_biasData(biasData);
  builder_.add_scaleData(scaleData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<Scale> CreateScaleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    const std::vector<float> *scaleData = nullptr,
    const std::vector<float> *biasData = nullptr) {
  auto scaleData__ = scaleData ? _fbb.CreateVector<float>(*scaleData) : 0;
  auto biasData__ = biasData ? _fbb.CreateVector<float>(*biasData) : 0;
  return MNN::CreateScale(
      _fbb,
      channels,
      scaleData__,
      biasData__);
}

flatbuffers::Offset<Scale> CreateScale(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EltwiseT : public flatbuffers::NativeTable {
  typedef Eltwise TableType;
  EltwiseType type;
  std::vector<float> coeff;
  EltwiseT()
      : type(EltwiseType_PROD) {
  }
};

struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EltwiseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_COEFF = 6
  };
  EltwiseType type() const {
    return static_cast<EltwiseType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<float> *coeff() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_COEFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_COEFF) &&
           verifier.VerifyVector(coeff()) &&
           verifier.EndTable();
  }
  EltwiseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Eltwise> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EltwiseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(EltwiseType type) {
    fbb_.AddElement<int8_t>(Eltwise::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_coeff(flatbuffers::Offset<flatbuffers::Vector<float>> coeff) {
    fbb_.AddOffset(Eltwise::VT_COEFF, coeff);
  }
  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EltwiseBuilder &operator=(const EltwiseBuilder &);
  flatbuffers::Offset<Eltwise> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Eltwise>(end);
    return o;
  }
};

inline flatbuffers::Offset<Eltwise> CreateEltwise(
    flatbuffers::FlatBufferBuilder &_fbb,
    EltwiseType type = EltwiseType_PROD,
    flatbuffers::Offset<flatbuffers::Vector<float>> coeff = 0) {
  EltwiseBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Eltwise> CreateEltwiseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    EltwiseType type = EltwiseType_PROD,
    const std::vector<float> *coeff = nullptr) {
  auto coeff__ = coeff ? _fbb.CreateVector<float>(*coeff) : 0;
  return MNN::CreateEltwise(
      _fbb,
      type,
      coeff__);
}

flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenT : public flatbuffers::NativeTable {
  typedef Flatten TableType;
  int32_t axis;
  int32_t endAxis;
  FlattenT()
      : axis(0),
        endAxis(0) {
  }
};

struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlattenTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ENDAXIS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t endAxis() const {
    return GetField<int32_t>(VT_ENDAXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_ENDAXIS) &&
           verifier.EndTable();
  }
  FlattenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Flatten> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Flatten::VT_AXIS, axis, 0);
  }
  void add_endAxis(int32_t endAxis) {
    fbb_.AddElement<int32_t>(Flatten::VT_ENDAXIS, endAxis, 0);
  }
  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlattenBuilder &operator=(const FlattenBuilder &);
  flatbuffers::Offset<Flatten> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Flatten>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flatten> CreateFlatten(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t endAxis = 0) {
  FlattenBuilder builder_(_fbb);
  builder_.add_endAxis(endAxis);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PermuteT : public flatbuffers::NativeTable {
  typedef Permute TableType;
  std::vector<int32_t> dims;
  PermuteT() {
  }
};

struct Permute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PermuteT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PermuteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  PermuteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PermuteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Permute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PermuteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Permute::VT_DIMS, dims);
  }
  explicit PermuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PermuteBuilder &operator=(const PermuteBuilder &);
  flatbuffers::Offset<Permute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Permute>(end);
    return o;
  }
};

inline flatbuffers::Offset<Permute> CreatePermute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  PermuteBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<Permute> CreatePermuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return MNN::CreatePermute(
      _fbb,
      dims__);
}

flatbuffers::Offset<Permute> CreatePermute(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeT : public flatbuffers::NativeTable {
  typedef Reshape TableType;
  std::vector<int32_t> dims;
  MNN_DATA_FORMAT dimType;
  ReshapeT()
      : dimType(MNN_DATA_FORMAT_NCHW) {
  }
};

struct Reshape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReshapeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DIMTYPE = 6
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  MNN_DATA_FORMAT dimType() const {
    return static_cast<MNN_DATA_FORMAT>(GetField<int8_t>(VT_DIMTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int8_t>(verifier, VT_DIMTYPE) &&
           verifier.EndTable();
  }
  ReshapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reshape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Reshape::VT_DIMS, dims);
  }
  void add_dimType(MNN_DATA_FORMAT dimType) {
    fbb_.AddElement<int8_t>(Reshape::VT_DIMTYPE, static_cast<int8_t>(dimType), 0);
  }
  explicit ReshapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeBuilder &operator=(const ReshapeBuilder &);
  flatbuffers::Offset<Reshape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reshape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reshape> CreateReshape(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    MNN_DATA_FORMAT dimType = MNN_DATA_FORMAT_NCHW) {
  ReshapeBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_dimType(dimType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reshape> CreateReshapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr,
    MNN_DATA_FORMAT dimType = MNN_DATA_FORMAT_NCHW) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return MNN::CreateReshape(
      _fbb,
      dims__,
      dimType);
}

flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionOutputT : public flatbuffers::NativeTable {
  typedef DetectionOutput TableType;
  int32_t classCount;
  float nmsThresholdold;
  int32_t nmsTopK;
  int32_t keepTopK;
  float confidenceThreshold;
  int32_t shareLocation;
  int32_t backgroundLable;
  int32_t varianceEncodedTarget;
  int32_t codeType;
  float objectnessScore;
  DetectionOutputT()
      : classCount(0),
        nmsThresholdold(0.0f),
        nmsTopK(0),
        keepTopK(0),
        confidenceThreshold(0.0f),
        shareLocation(0),
        backgroundLable(0),
        varianceEncodedTarget(0),
        codeType(0),
        objectnessScore(0.01f) {
  }
};

struct DetectionOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionOutputT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DetectionOutputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASSCOUNT = 4,
    VT_NMSTHRESHOLDOLD = 6,
    VT_NMSTOPK = 8,
    VT_KEEPTOPK = 10,
    VT_CONFIDENCETHRESHOLD = 12,
    VT_SHARELOCATION = 14,
    VT_BACKGROUNDLABLE = 16,
    VT_VARIANCEENCODEDTARGET = 18,
    VT_CODETYPE = 20,
    VT_OBJECTNESSSCORE = 22
  };
  int32_t classCount() const {
    return GetField<int32_t>(VT_CLASSCOUNT, 0);
  }
  float nmsThresholdold() const {
    return GetField<float>(VT_NMSTHRESHOLDOLD, 0.0f);
  }
  int32_t nmsTopK() const {
    return GetField<int32_t>(VT_NMSTOPK, 0);
  }
  int32_t keepTopK() const {
    return GetField<int32_t>(VT_KEEPTOPK, 0);
  }
  float confidenceThreshold() const {
    return GetField<float>(VT_CONFIDENCETHRESHOLD, 0.0f);
  }
  int32_t shareLocation() const {
    return GetField<int32_t>(VT_SHARELOCATION, 0);
  }
  int32_t backgroundLable() const {
    return GetField<int32_t>(VT_BACKGROUNDLABLE, 0);
  }
  int32_t varianceEncodedTarget() const {
    return GetField<int32_t>(VT_VARIANCEENCODEDTARGET, 0);
  }
  int32_t codeType() const {
    return GetField<int32_t>(VT_CODETYPE, 0);
  }
  float objectnessScore() const {
    return GetField<float>(VT_OBJECTNESSSCORE, 0.01f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLASSCOUNT) &&
           VerifyField<float>(verifier, VT_NMSTHRESHOLDOLD) &&
           VerifyField<int32_t>(verifier, VT_NMSTOPK) &&
           VerifyField<int32_t>(verifier, VT_KEEPTOPK) &&
           VerifyField<float>(verifier, VT_CONFIDENCETHRESHOLD) &&
           VerifyField<int32_t>(verifier, VT_SHARELOCATION) &&
           VerifyField<int32_t>(verifier, VT_BACKGROUNDLABLE) &&
           VerifyField<int32_t>(verifier, VT_VARIANCEENCODEDTARGET) &&
           VerifyField<int32_t>(verifier, VT_CODETYPE) &&
           VerifyField<float>(verifier, VT_OBJECTNESSSCORE) &&
           verifier.EndTable();
  }
  DetectionOutputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionOutputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectionOutput> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionOutputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classCount(int32_t classCount) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_CLASSCOUNT, classCount, 0);
  }
  void add_nmsThresholdold(float nmsThresholdold) {
    fbb_.AddElement<float>(DetectionOutput::VT_NMSTHRESHOLDOLD, nmsThresholdold, 0.0f);
  }
  void add_nmsTopK(int32_t nmsTopK) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_NMSTOPK, nmsTopK, 0);
  }
  void add_keepTopK(int32_t keepTopK) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_KEEPTOPK, keepTopK, 0);
  }
  void add_confidenceThreshold(float confidenceThreshold) {
    fbb_.AddElement<float>(DetectionOutput::VT_CONFIDENCETHRESHOLD, confidenceThreshold, 0.0f);
  }
  void add_shareLocation(int32_t shareLocation) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_SHARELOCATION, shareLocation, 0);
  }
  void add_backgroundLable(int32_t backgroundLable) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_BACKGROUNDLABLE, backgroundLable, 0);
  }
  void add_varianceEncodedTarget(int32_t varianceEncodedTarget) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_VARIANCEENCODEDTARGET, varianceEncodedTarget, 0);
  }
  void add_codeType(int32_t codeType) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_CODETYPE, codeType, 0);
  }
  void add_objectnessScore(float objectnessScore) {
    fbb_.AddElement<float>(DetectionOutput::VT_OBJECTNESSSCORE, objectnessScore, 0.01f);
  }
  explicit DetectionOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DetectionOutputBuilder &operator=(const DetectionOutputBuilder &);
  flatbuffers::Offset<DetectionOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionOutput>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionOutput> CreateDetectionOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t classCount = 0,
    float nmsThresholdold = 0.0f,
    int32_t nmsTopK = 0,
    int32_t keepTopK = 0,
    float confidenceThreshold = 0.0f,
    int32_t shareLocation = 0,
    int32_t backgroundLable = 0,
    int32_t varianceEncodedTarget = 0,
    int32_t codeType = 0,
    float objectnessScore = 0.01f) {
  DetectionOutputBuilder builder_(_fbb);
  builder_.add_objectnessScore(objectnessScore);
  builder_.add_codeType(codeType);
  builder_.add_varianceEncodedTarget(varianceEncodedTarget);
  builder_.add_backgroundLable(backgroundLable);
  builder_.add_shareLocation(shareLocation);
  builder_.add_confidenceThreshold(confidenceThreshold);
  builder_.add_keepTopK(keepTopK);
  builder_.add_nmsTopK(nmsTopK);
  builder_.add_nmsThresholdold(nmsThresholdold);
  builder_.add_classCount(classCount);
  return builder_.Finish();
}

flatbuffers::Offset<DetectionOutput> CreateDetectionOutput(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoiPoolingT : public flatbuffers::NativeTable {
  typedef RoiPooling TableType;
  int32_t pooledWidth;
  int32_t pooledHeight;
  float spatialScale;
  RoiPoolingT()
      : pooledWidth(0),
        pooledHeight(0),
        spatialScale(0.0f) {
  }
};

struct RoiPooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoiPoolingT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RoiPoolingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOLEDWIDTH = 4,
    VT_POOLEDHEIGHT = 6,
    VT_SPATIALSCALE = 8
  };
  int32_t pooledWidth() const {
    return GetField<int32_t>(VT_POOLEDWIDTH, 0);
  }
  int32_t pooledHeight() const {
    return GetField<int32_t>(VT_POOLEDHEIGHT, 0);
  }
  float spatialScale() const {
    return GetField<float>(VT_SPATIALSCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POOLEDWIDTH) &&
           VerifyField<int32_t>(verifier, VT_POOLEDHEIGHT) &&
           VerifyField<float>(verifier, VT_SPATIALSCALE) &&
           verifier.EndTable();
  }
  RoiPoolingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoiPoolingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoiPooling> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoiPoolingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pooledWidth(int32_t pooledWidth) {
    fbb_.AddElement<int32_t>(RoiPooling::VT_POOLEDWIDTH, pooledWidth, 0);
  }
  void add_pooledHeight(int32_t pooledHeight) {
    fbb_.AddElement<int32_t>(RoiPooling::VT_POOLEDHEIGHT, pooledHeight, 0);
  }
  void add_spatialScale(float spatialScale) {
    fbb_.AddElement<float>(RoiPooling::VT_SPATIALSCALE, spatialScale, 0.0f);
  }
  explicit RoiPoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RoiPoolingBuilder &operator=(const RoiPoolingBuilder &);
  flatbuffers::Offset<RoiPooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoiPooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoiPooling> CreateRoiPooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pooledWidth = 0,
    int32_t pooledHeight = 0,
    float spatialScale = 0.0f) {
  RoiPoolingBuilder builder_(_fbb);
  builder_.add_spatialScale(spatialScale);
  builder_.add_pooledHeight(pooledHeight);
  builder_.add_pooledWidth(pooledWidth);
  return builder_.Finish();
}

flatbuffers::Offset<RoiPooling> CreateRoiPooling(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProposalT : public flatbuffers::NativeTable {
  typedef Proposal TableType;
  int32_t featStride;
  int32_t baseSize;
  int32_t preNmsTopN;
  int32_t afterNmsTopN;
  float nmsThreshold;
  int32_t minSize;
  std::unique_ptr<BlobT> ratios;
  std::unique_ptr<BlobT> scales;
  std::unique_ptr<BlobT> anchors;
  ProposalT()
      : featStride(0),
        baseSize(0),
        preNmsTopN(0),
        afterNmsTopN(0),
        nmsThreshold(0.0f),
        minSize(0) {
  }
};

struct Proposal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProposalT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProposalTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATSTRIDE = 4,
    VT_BASESIZE = 6,
    VT_PRENMSTOPN = 8,
    VT_AFTERNMSTOPN = 10,
    VT_NMSTHRESHOLD = 12,
    VT_MINSIZE = 14,
    VT_RATIOS = 16,
    VT_SCALES = 18,
    VT_ANCHORS = 20
  };
  int32_t featStride() const {
    return GetField<int32_t>(VT_FEATSTRIDE, 0);
  }
  int32_t baseSize() const {
    return GetField<int32_t>(VT_BASESIZE, 0);
  }
  int32_t preNmsTopN() const {
    return GetField<int32_t>(VT_PRENMSTOPN, 0);
  }
  int32_t afterNmsTopN() const {
    return GetField<int32_t>(VT_AFTERNMSTOPN, 0);
  }
  float nmsThreshold() const {
    return GetField<float>(VT_NMSTHRESHOLD, 0.0f);
  }
  int32_t minSize() const {
    return GetField<int32_t>(VT_MINSIZE, 0);
  }
  const Blob *ratios() const {
    return GetPointer<const Blob *>(VT_RATIOS);
  }
  const Blob *scales() const {
    return GetPointer<const Blob *>(VT_SCALES);
  }
  const Blob *anchors() const {
    return GetPointer<const Blob *>(VT_ANCHORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FEATSTRIDE) &&
           VerifyField<int32_t>(verifier, VT_BASESIZE) &&
           VerifyField<int32_t>(verifier, VT_PRENMSTOPN) &&
           VerifyField<int32_t>(verifier, VT_AFTERNMSTOPN) &&
           VerifyField<float>(verifier, VT_NMSTHRESHOLD) &&
           VerifyField<int32_t>(verifier, VT_MINSIZE) &&
           VerifyOffset(verifier, VT_RATIOS) &&
           verifier.VerifyTable(ratios()) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyTable(scales()) &&
           VerifyOffset(verifier, VT_ANCHORS) &&
           verifier.VerifyTable(anchors()) &&
           verifier.EndTable();
  }
  ProposalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProposalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Proposal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProposalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_featStride(int32_t featStride) {
    fbb_.AddElement<int32_t>(Proposal::VT_FEATSTRIDE, featStride, 0);
  }
  void add_baseSize(int32_t baseSize) {
    fbb_.AddElement<int32_t>(Proposal::VT_BASESIZE, baseSize, 0);
  }
  void add_preNmsTopN(int32_t preNmsTopN) {
    fbb_.AddElement<int32_t>(Proposal::VT_PRENMSTOPN, preNmsTopN, 0);
  }
  void add_afterNmsTopN(int32_t afterNmsTopN) {
    fbb_.AddElement<int32_t>(Proposal::VT_AFTERNMSTOPN, afterNmsTopN, 0);
  }
  void add_nmsThreshold(float nmsThreshold) {
    fbb_.AddElement<float>(Proposal::VT_NMSTHRESHOLD, nmsThreshold, 0.0f);
  }
  void add_minSize(int32_t minSize) {
    fbb_.AddElement<int32_t>(Proposal::VT_MINSIZE, minSize, 0);
  }
  void add_ratios(flatbuffers::Offset<Blob> ratios) {
    fbb_.AddOffset(Proposal::VT_RATIOS, ratios);
  }
  void add_scales(flatbuffers::Offset<Blob> scales) {
    fbb_.AddOffset(Proposal::VT_SCALES, scales);
  }
  void add_anchors(flatbuffers::Offset<Blob> anchors) {
    fbb_.AddOffset(Proposal::VT_ANCHORS, anchors);
  }
  explicit ProposalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalBuilder &operator=(const ProposalBuilder &);
  flatbuffers::Offset<Proposal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Proposal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Proposal> CreateProposal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t featStride = 0,
    int32_t baseSize = 0,
    int32_t preNmsTopN = 0,
    int32_t afterNmsTopN = 0,
    float nmsThreshold = 0.0f,
    int32_t minSize = 0,
    flatbuffers::Offset<Blob> ratios = 0,
    flatbuffers::Offset<Blob> scales = 0,
    flatbuffers::Offset<Blob> anchors = 0) {
  ProposalBuilder builder_(_fbb);
  builder_.add_anchors(anchors);
  builder_.add_scales(scales);
  builder_.add_ratios(ratios);
  builder_.add_minSize(minSize);
  builder_.add_nmsThreshold(nmsThreshold);
  builder_.add_afterNmsTopN(afterNmsTopN);
  builder_.add_preNmsTopN(preNmsTopN);
  builder_.add_baseSize(baseSize);
  builder_.add_featStride(featStride);
  return builder_.Finish();
}

flatbuffers::Offset<Proposal> CreateProposal(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InterpT : public flatbuffers::NativeTable {
  typedef Interp TableType;
  float widthScale;
  float heightScale;
  int32_t outputWidth;
  int32_t outputHeight;
  int32_t resizeType;
  bool alignCorners;
  bool halfPixelCenters;
  InterpT()
      : widthScale(0.0f),
        heightScale(0.0f),
        outputWidth(0),
        outputHeight(0),
        resizeType(0),
        alignCorners(false),
        halfPixelCenters(false) {
  }
};

struct Interp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InterpT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InterpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTHSCALE = 4,
    VT_HEIGHTSCALE = 6,
    VT_OUTPUTWIDTH = 8,
    VT_OUTPUTHEIGHT = 10,
    VT_RESIZETYPE = 12,
    VT_ALIGNCORNERS = 14,
    VT_HALFPIXELCENTERS = 16
  };
  float widthScale() const {
    return GetField<float>(VT_WIDTHSCALE, 0.0f);
  }
  float heightScale() const {
    return GetField<float>(VT_HEIGHTSCALE, 0.0f);
  }
  int32_t outputWidth() const {
    return GetField<int32_t>(VT_OUTPUTWIDTH, 0);
  }
  int32_t outputHeight() const {
    return GetField<int32_t>(VT_OUTPUTHEIGHT, 0);
  }
  int32_t resizeType() const {
    return GetField<int32_t>(VT_RESIZETYPE, 0);
  }
  bool alignCorners() const {
    return GetField<uint8_t>(VT_ALIGNCORNERS, 0) != 0;
  }
  bool halfPixelCenters() const {
    return GetField<uint8_t>(VT_HALFPIXELCENTERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WIDTHSCALE) &&
           VerifyField<float>(verifier, VT_HEIGHTSCALE) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTWIDTH) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTHEIGHT) &&
           VerifyField<int32_t>(verifier, VT_RESIZETYPE) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNCORNERS) &&
           VerifyField<uint8_t>(verifier, VT_HALFPIXELCENTERS) &&
           verifier.EndTable();
  }
  InterpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InterpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Interp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InterpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_widthScale(float widthScale) {
    fbb_.AddElement<float>(Interp::VT_WIDTHSCALE, widthScale, 0.0f);
  }
  void add_heightScale(float heightScale) {
    fbb_.AddElement<float>(Interp::VT_HEIGHTSCALE, heightScale, 0.0f);
  }
  void add_outputWidth(int32_t outputWidth) {
    fbb_.AddElement<int32_t>(Interp::VT_OUTPUTWIDTH, outputWidth, 0);
  }
  void add_outputHeight(int32_t outputHeight) {
    fbb_.AddElement<int32_t>(Interp::VT_OUTPUTHEIGHT, outputHeight, 0);
  }
  void add_resizeType(int32_t resizeType) {
    fbb_.AddElement<int32_t>(Interp::VT_RESIZETYPE, resizeType, 0);
  }
  void add_alignCorners(bool alignCorners) {
    fbb_.AddElement<uint8_t>(Interp::VT_ALIGNCORNERS, static_cast<uint8_t>(alignCorners), 0);
  }
  void add_halfPixelCenters(bool halfPixelCenters) {
    fbb_.AddElement<uint8_t>(Interp::VT_HALFPIXELCENTERS, static_cast<uint8_t>(halfPixelCenters), 0);
  }
  explicit InterpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InterpBuilder &operator=(const InterpBuilder &);
  flatbuffers::Offset<Interp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Interp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Interp> CreateInterp(
    flatbuffers::FlatBufferBuilder &_fbb,
    float widthScale = 0.0f,
    float heightScale = 0.0f,
    int32_t outputWidth = 0,
    int32_t outputHeight = 0,
    int32_t resizeType = 0,
    bool alignCorners = false,
    bool halfPixelCenters = false) {
  InterpBuilder builder_(_fbb);
  builder_.add_resizeType(resizeType);
  builder_.add_outputHeight(outputHeight);
  builder_.add_outputWidth(outputWidth);
  builder_.add_heightScale(heightScale);
  builder_.add_widthScale(widthScale);
  builder_.add_halfPixelCenters(halfPixelCenters);
  builder_.add_alignCorners(alignCorners);
  return builder_.Finish();
}

flatbuffers::Offset<Interp> CreateInterp(flatbuffers::FlatBufferBuilder &_fbb, const InterpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeT : public flatbuffers::NativeTable {
  typedef Resize TableType;
  float xScale;
  float yScale;
  ResizeT()
      : xScale(0.0f),
        yScale(0.0f) {
  }
};

struct Resize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResizeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XSCALE = 4,
    VT_YSCALE = 6
  };
  float xScale() const {
    return GetField<float>(VT_XSCALE, 0.0f);
  }
  float yScale() const {
    return GetField<float>(VT_YSCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_XSCALE) &&
           VerifyField<float>(verifier, VT_YSCALE) &&
           verifier.EndTable();
  }
  ResizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Resize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_xScale(float xScale) {
    fbb_.AddElement<float>(Resize::VT_XSCALE, xScale, 0.0f);
  }
  void add_yScale(float yScale) {
    fbb_.AddElement<float>(Resize::VT_YSCALE, yScale, 0.0f);
  }
  explicit ResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeBuilder &operator=(const ResizeBuilder &);
  flatbuffers::Offset<Resize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resize> CreateResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    float xScale = 0.0f,
    float yScale = 0.0f) {
  ResizeBuilder builder_(_fbb);
  builder_.add_yScale(yScale);
  builder_.add_xScale(xScale);
  return builder_.Finish();
}

flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PriorBoxT : public flatbuffers::NativeTable {
  typedef PriorBox TableType;
  std::vector<float> minSizes;
  std::vector<float> maxSizes;
  std::vector<float> aspectRatios;
  std::vector<float> variances;
  bool flip;
  bool clip;
  int32_t imageWidth;
  int32_t imageHeight;
  int32_t stepWidth;
  int32_t stepHeight;
  float offset;
  PriorBoxT()
      : flip(false),
        clip(false),
        imageWidth(0),
        imageHeight(0),
        stepWidth(0),
        stepHeight(0),
        offset(0.0f) {
  }
};

struct PriorBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PriorBoxT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PriorBoxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINSIZES = 4,
    VT_MAXSIZES = 6,
    VT_ASPECTRATIOS = 8,
    VT_VARIANCES = 10,
    VT_FLIP = 12,
    VT_CLIP = 14,
    VT_IMAGEWIDTH = 16,
    VT_IMAGEHEIGHT = 18,
    VT_STEPWIDTH = 20,
    VT_STEPHEIGHT = 22,
    VT_OFFSET = 24
  };
  const flatbuffers::Vector<float> *minSizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MINSIZES);
  }
  const flatbuffers::Vector<float> *maxSizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAXSIZES);
  }
  const flatbuffers::Vector<float> *aspectRatios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECTRATIOS);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  bool flip() const {
    return GetField<uint8_t>(VT_FLIP, 0) != 0;
  }
  bool clip() const {
    return GetField<uint8_t>(VT_CLIP, 0) != 0;
  }
  int32_t imageWidth() const {
    return GetField<int32_t>(VT_IMAGEWIDTH, 0);
  }
  int32_t imageHeight() const {
    return GetField<int32_t>(VT_IMAGEHEIGHT, 0);
  }
  int32_t stepWidth() const {
    return GetField<int32_t>(VT_STEPWIDTH, 0);
  }
  int32_t stepHeight() const {
    return GetField<int32_t>(VT_STEPHEIGHT, 0);
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MINSIZES) &&
           verifier.VerifyVector(minSizes()) &&
           VerifyOffset(verifier, VT_MAXSIZES) &&
           verifier.VerifyVector(maxSizes()) &&
           VerifyOffset(verifier, VT_ASPECTRATIOS) &&
           verifier.VerifyVector(aspectRatios()) &&
           VerifyOffset(verifier, VT_VARIANCES) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<uint8_t>(verifier, VT_FLIP) &&
           VerifyField<uint8_t>(verifier, VT_CLIP) &&
           VerifyField<int32_t>(verifier, VT_IMAGEWIDTH) &&
           VerifyField<int32_t>(verifier, VT_IMAGEHEIGHT) &&
           VerifyField<int32_t>(verifier, VT_STEPWIDTH) &&
           VerifyField<int32_t>(verifier, VT_STEPHEIGHT) &&
           VerifyField<float>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
  PriorBoxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PriorBox> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriorBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minSizes(flatbuffers::Offset<flatbuffers::Vector<float>> minSizes) {
    fbb_.AddOffset(PriorBox::VT_MINSIZES, minSizes);
  }
  void add_maxSizes(flatbuffers::Offset<flatbuffers::Vector<float>> maxSizes) {
    fbb_.AddOffset(PriorBox::VT_MAXSIZES, maxSizes);
  }
  void add_aspectRatios(flatbuffers::Offset<flatbuffers::Vector<float>> aspectRatios) {
    fbb_.AddOffset(PriorBox::VT_ASPECTRATIOS, aspectRatios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(PriorBox::VT_VARIANCES, variances);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_FLIP, static_cast<uint8_t>(flip), 0);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_CLIP, static_cast<uint8_t>(clip), 0);
  }
  void add_imageWidth(int32_t imageWidth) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGEWIDTH, imageWidth, 0);
  }
  void add_imageHeight(int32_t imageHeight) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGEHEIGHT, imageHeight, 0);
  }
  void add_stepWidth(int32_t stepWidth) {
    fbb_.AddElement<int32_t>(PriorBox::VT_STEPWIDTH, stepWidth, 0);
  }
  void add_stepHeight(int32_t stepHeight) {
    fbb_.AddElement<int32_t>(PriorBox::VT_STEPHEIGHT, stepHeight, 0);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(PriorBox::VT_OFFSET, offset, 0.0f);
  }
  explicit PriorBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PriorBoxBuilder &operator=(const PriorBoxBuilder &);
  flatbuffers::Offset<PriorBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorBox> CreatePriorBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> minSizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> maxSizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspectRatios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    bool flip = false,
    bool clip = false,
    int32_t imageWidth = 0,
    int32_t imageHeight = 0,
    int32_t stepWidth = 0,
    int32_t stepHeight = 0,
    float offset = 0.0f) {
  PriorBoxBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_stepHeight(stepHeight);
  builder_.add_stepWidth(stepWidth);
  builder_.add_imageHeight(imageHeight);
  builder_.add_imageWidth(imageWidth);
  builder_.add_variances(variances);
  builder_.add_aspectRatios(aspectRatios);
  builder_.add_maxSizes(maxSizes);
  builder_.add_minSizes(minSizes);
  builder_.add_clip(clip);
  builder_.add_flip(flip);
  return builder_.Finish();
}

inline flatbuffers::Offset<PriorBox> CreatePriorBoxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *minSizes = nullptr,
    const std::vector<float> *maxSizes = nullptr,
    const std::vector<float> *aspectRatios = nullptr,
    const std::vector<float> *variances = nullptr,
    bool flip = false,
    bool clip = false,
    int32_t imageWidth = 0,
    int32_t imageHeight = 0,
    int32_t stepWidth = 0,
    int32_t stepHeight = 0,
    float offset = 0.0f) {
  auto minSizes__ = minSizes ? _fbb.CreateVector<float>(*minSizes) : 0;
  auto maxSizes__ = maxSizes ? _fbb.CreateVector<float>(*maxSizes) : 0;
  auto aspectRatios__ = aspectRatios ? _fbb.CreateVector<float>(*aspectRatios) : 0;
  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
  return MNN::CreatePriorBox(
      _fbb,
      minSizes__,
      maxSizes__,
      aspectRatios__,
      variances__,
      flip,
      clip,
      imageWidth,
      imageHeight,
      stepWidth,
      stepHeight,
      offset);
}

flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NormalizeT : public flatbuffers::NativeTable {
  typedef Normalize TableType;
  int32_t acrossSpatial;
  int32_t channelShared;
  float eps;
  std::vector<float> scale;
  NormalizeT()
      : acrossSpatial(0),
        channelShared(0),
        eps(0.0f) {
  }
};

struct Normalize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormalizeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NormalizeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACROSSSPATIAL = 4,
    VT_CHANNELSHARED = 6,
    VT_EPS = 8,
    VT_SCALE = 10
  };
  int32_t acrossSpatial() const {
    return GetField<int32_t>(VT_ACROSSSPATIAL, 0);
  }
  int32_t channelShared() const {
    return GetField<int32_t>(VT_CHANNELSHARED, 0);
  }
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACROSSSPATIAL) &&
           VerifyField<int32_t>(verifier, VT_CHANNELSHARED) &&
           VerifyField<float>(verifier, VT_EPS) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           verifier.EndTable();
  }
  NormalizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NormalizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Normalize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NormalizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acrossSpatial(int32_t acrossSpatial) {
    fbb_.AddElement<int32_t>(Normalize::VT_ACROSSSPATIAL, acrossSpatial, 0);
  }
  void add_channelShared(int32_t channelShared) {
    fbb_.AddElement<int32_t>(Normalize::VT_CHANNELSHARED, channelShared, 0);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(Normalize::VT_EPS, eps, 0.0f);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(Normalize::VT_SCALE, scale);
  }
  explicit NormalizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NormalizeBuilder &operator=(const NormalizeBuilder &);
  flatbuffers::Offset<Normalize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Normalize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Normalize> CreateNormalize(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t acrossSpatial = 0,
    int32_t channelShared = 0,
    float eps = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0) {
  NormalizeBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_eps(eps);
  builder_.add_channelShared(channelShared);
  builder_.add_acrossSpatial(acrossSpatial);
  return builder_.Finish();
}

inline flatbuffers::Offset<Normalize> CreateNormalizeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t acrossSpatial = 0,
    int32_t channelShared = 0,
    float eps = 0.0f,
    const std::vector<float> *scale = nullptr) {
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  return MNN::CreateNormalize(
      _fbb,
      acrossSpatial,
      channelShared,
      eps,
      scale__);
}

flatbuffers::Offset<Normalize> CreateNormalize(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EltwiseInt8T : public flatbuffers::NativeTable {
  typedef EltwiseInt8 TableType;
  EltwiseType type;
  std::unique_ptr<QuantizedFloatParamT> inputQuan0;
  std::unique_ptr<QuantizedFloatParamT> inputQuan1;
  std::unique_ptr<QuantizedFloatParamT> outputQuan;
  EltwiseInt8T()
      : type(EltwiseType_PROD) {
  }
};

struct EltwiseInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseInt8T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EltwiseInt8TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_INPUTQUAN0 = 6,
    VT_INPUTQUAN1 = 8,
    VT_OUTPUTQUAN = 10
  };
  EltwiseType type() const {
    return static_cast<EltwiseType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const QuantizedFloatParam *inputQuan0() const {
    return GetPointer<const QuantizedFloatParam *>(VT_INPUTQUAN0);
  }
  const QuantizedFloatParam *inputQuan1() const {
    return GetPointer<const QuantizedFloatParam *>(VT_INPUTQUAN1);
  }
  const QuantizedFloatParam *outputQuan() const {
    return GetPointer<const QuantizedFloatParam *>(VT_OUTPUTQUAN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_INPUTQUAN0) &&
           verifier.VerifyTable(inputQuan0()) &&
           VerifyOffset(verifier, VT_INPUTQUAN1) &&
           verifier.VerifyTable(inputQuan1()) &&
           VerifyOffset(verifier, VT_OUTPUTQUAN) &&
           verifier.VerifyTable(outputQuan()) &&
           verifier.EndTable();
  }
  EltwiseInt8T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EltwiseInt8T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EltwiseInt8> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EltwiseInt8Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(EltwiseType type) {
    fbb_.AddElement<int8_t>(EltwiseInt8::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_inputQuan0(flatbuffers::Offset<QuantizedFloatParam> inputQuan0) {
    fbb_.AddOffset(EltwiseInt8::VT_INPUTQUAN0, inputQuan0);
  }
  void add_inputQuan1(flatbuffers::Offset<QuantizedFloatParam> inputQuan1) {
    fbb_.AddOffset(EltwiseInt8::VT_INPUTQUAN1, inputQuan1);
  }
  void add_outputQuan(flatbuffers::Offset<QuantizedFloatParam> outputQuan) {
    fbb_.AddOffset(EltwiseInt8::VT_OUTPUTQUAN, outputQuan);
  }
  explicit EltwiseInt8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EltwiseInt8Builder &operator=(const EltwiseInt8Builder &);
  flatbuffers::Offset<EltwiseInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EltwiseInt8>(end);
    return o;
  }
};

inline flatbuffers::Offset<EltwiseInt8> CreateEltwiseInt8(
    flatbuffers::FlatBufferBuilder &_fbb,
    EltwiseType type = EltwiseType_PROD,
    flatbuffers::Offset<QuantizedFloatParam> inputQuan0 = 0,
    flatbuffers::Offset<QuantizedFloatParam> inputQuan1 = 0,
    flatbuffers::Offset<QuantizedFloatParam> outputQuan = 0) {
  EltwiseInt8Builder builder_(_fbb);
  builder_.add_outputQuan(outputQuan);
  builder_.add_inputQuan1(inputQuan1);
  builder_.add_inputQuan0(inputQuan0);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<EltwiseInt8> CreateEltwiseInt8(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Convolution2DCommonT *Convolution2DCommon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Convolution2DCommonT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Convolution2DCommon::UnPackTo(Convolution2DCommonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; };
  { auto _e = padY(); _o->padY = _e; };
  { auto _e = kernelX(); _o->kernelX = _e; };
  { auto _e = kernelY(); _o->kernelY = _e; };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
  { auto _e = dilateX(); _o->dilateX = _e; };
  { auto _e = dilateY(); _o->dilateY = _e; };
  { auto _e = padMode(); _o->padMode = _e; };
  { auto _e = group(); _o->group = _e; };
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = inputCount(); _o->inputCount = _e; };
  { auto _e = relu(); _o->relu = _e; };
  { auto _e = relu6(); _o->relu6 = _e; };
}

inline flatbuffers::Offset<Convolution2DCommon> Convolution2DCommon::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution2DCommon(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution2DCommonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _dilateX = _o->dilateX;
  auto _dilateY = _o->dilateY;
  auto _padMode = _o->padMode;
  auto _group = _o->group;
  auto _outputCount = _o->outputCount;
  auto _inputCount = _o->inputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  return MNN::CreateConvolution2DCommon(
      _fbb,
      _padX,
      _padY,
      _kernelX,
      _kernelY,
      _strideX,
      _strideY,
      _dilateX,
      _dilateY,
      _padMode,
      _group,
      _outputCount,
      _inputCount,
      _relu,
      _relu6);
}

inline Convolution3DCommonT *Convolution3DCommon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Convolution3DCommonT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Convolution3DCommon::UnPackTo(Convolution3DCommonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dilates(); if (_e) { _o->dilates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilates[_i] = _e->Get(_i); } } };
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } };
  { auto _e = kernels(); if (_e) { _o->kernels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernels[_i] = _e->Get(_i); } } };
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } };
  { auto _e = padMode(); _o->padMode = _e; };
  { auto _e = inputCount(); _o->inputCount = _e; };
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = relu(); _o->relu = _e; };
  { auto _e = relu6(); _o->relu6 = _e; };
}

inline flatbuffers::Offset<Convolution3DCommon> Convolution3DCommon::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution3DCommon(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution3DCommonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dilates = _o->dilates.size() ? _fbb.CreateVector(_o->dilates) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _kernels = _o->kernels.size() ? _fbb.CreateVector(_o->kernels) : 0;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _padMode = _o->padMode;
  auto _inputCount = _o->inputCount;
  auto _outputCount = _o->outputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  return MNN::CreateConvolution3DCommon(
      _fbb,
      _dilates,
      _strides,
      _kernels,
      _pads,
      _padMode,
      _inputCount,
      _outputCount,
      _relu,
      _relu6);
}

inline IDSTQuanT *IDSTQuan::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IDSTQuanT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IDSTQuan::UnPackTo(IDSTQuanT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = buffer(); if (_e) { _o->buffer.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buffer[_i] = _e->Get(_i); } } };
  { auto _e = alpha(); if (_e) { _o->alpha.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->alpha[_i] = _e->Get(_i); } } };
  { auto _e = type(); _o->type = _e; };
  { auto _e = useInt32(); _o->useInt32 = _e; };
  { auto _e = quantScale(); _o->quantScale = _e; };
  { auto _e = scaleIn(); _o->scaleIn = _e; };
  { auto _e = scaleOut(); _o->scaleOut = _e; };
  { auto _e = aMax(); _o->aMax = _e; };
  { auto _e = aMin(); _o->aMin = _e; };
  { auto _e = readType(); _o->readType = _e; };
  { auto _e = has_scaleInt(); _o->has_scaleInt = _e; };
}

inline flatbuffers::Offset<IDSTQuan> IDSTQuan::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIDSTQuan(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IDSTQuan> CreateIDSTQuan(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IDSTQuanT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _buffer = _o->buffer.size() ? _fbb.CreateVector(_o->buffer) : 0;
  auto _alpha = _o->alpha.size() ? _fbb.CreateVector(_o->alpha) : 0;
  auto _type = _o->type;
  auto _useInt32 = _o->useInt32;
  auto _quantScale = _o->quantScale;
  auto _scaleIn = _o->scaleIn;
  auto _scaleOut = _o->scaleOut;
  auto _aMax = _o->aMax;
  auto _aMin = _o->aMin;
  auto _readType = _o->readType;
  auto _has_scaleInt = _o->has_scaleInt;
  return MNN::CreateIDSTQuan(
      _fbb,
      _buffer,
      _alpha,
      _type,
      _useInt32,
      _quantScale,
      _scaleIn,
      _scaleOut,
      _aMax,
      _aMin,
      _readType,
      _has_scaleInt);
}

inline QuantizedFloatParamT *QuantizedFloatParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QuantizedFloatParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void QuantizedFloatParam::UnPackTo(QuantizedFloatParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } };
  { auto _e = tensorScale(); if (_e) { _o->tensorScale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensorScale[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<QuantizedFloatParam> QuantizedFloatParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizedFloatParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParam(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizedFloatParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  auto _tensorScale = _o->tensorScale.size() ? _fbb.CreateVector(_o->tensorScale) : 0;
  return MNN::CreateQuantizedFloatParam(
      _fbb,
      _weight,
      _bias,
      _scale,
      _tensorScale);
}

inline Convolution2DT *Convolution2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Convolution2DT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Convolution2D::UnPackTo(Convolution2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = common(); if (_e) _o->common = std::unique_ptr<Convolution2DCommonT>(_e->UnPack(_resolver)); };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
  { auto _e = quanParameter(); if (_e) _o->quanParameter = std::unique_ptr<IDSTQuanT>(_e->UnPack(_resolver)); };
  { auto _e = symmetricQuan(); if (_e) _o->symmetricQuan = std::unique_ptr<QuantizedFloatParamT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Convolution2D> Convolution2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution2D> CreateConvolution2D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _common = _o->common ? CreateConvolution2DCommon(_fbb, _o->common.get(), _rehasher) : 0;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _quanParameter = _o->quanParameter ? CreateIDSTQuan(_fbb, _o->quanParameter.get(), _rehasher) : 0;
  auto _symmetricQuan = _o->symmetricQuan ? CreateQuantizedFloatParam(_fbb, _o->symmetricQuan.get(), _rehasher) : 0;
  return MNN::CreateConvolution2D(
      _fbb,
      _common,
      _weight,
      _bias,
      _quanParameter,
      _symmetricQuan);
}

inline Convolution3DT *Convolution3D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Convolution3DT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Convolution3D::UnPackTo(Convolution3DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = common(); if (_e) _o->common = std::unique_ptr<Convolution3DCommonT>(_e->UnPack(_resolver)); };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Convolution3D> Convolution3D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution3D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution3D> CreateConvolution3D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution3DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _common = _o->common ? CreateConvolution3DCommon(_fbb, _o->common.get(), _rehasher) : 0;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  return MNN::CreateConvolution3D(
      _fbb,
      _common,
      _weight,
      _bias);
}

inline InnerProductT *InnerProduct::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InnerProductT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InnerProduct::UnPackTo(InnerProductT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = biasTerm(); _o->biasTerm = _e; };
  { auto _e = weightSize(); _o->weightSize = _e; };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = transpose(); _o->transpose = _e; };
  { auto _e = quanParameter(); if (_e) _o->quanParameter = std::unique_ptr<IDSTQuanT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<InnerProduct> InnerProduct::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInnerProduct(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InnerProduct> CreateInnerProduct(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InnerProductT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputCount = _o->outputCount;
  auto _biasTerm = _o->biasTerm;
  auto _weightSize = _o->weightSize;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _axis = _o->axis;
  auto _transpose = _o->transpose;
  auto _quanParameter = _o->quanParameter ? CreateIDSTQuan(_fbb, _o->quanParameter.get(), _rehasher) : 0;
  return MNN::CreateInnerProduct(
      _fbb,
      _outputCount,
      _biasTerm,
      _weightSize,
      _weight,
      _bias,
      _axis,
      _transpose,
      _quanParameter);
}

inline PoolT *Pool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PoolT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Pool::UnPackTo(PoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; };
  { auto _e = padY(); _o->padY = _e; };
  { auto _e = isGlobal(); _o->isGlobal = _e; };
  { auto _e = kernelX(); _o->kernelX = _e; };
  { auto _e = kernelY(); _o->kernelY = _e; };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = padType(); _o->padType = _e; };
  { auto _e = dataType(); _o->dataType = _e; };
  { auto _e = ceilModel(); _o->ceilModel = _e; };
}

inline flatbuffers::Offset<Pool> Pool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool> CreatePool(flatbuffers::FlatBufferBuilder &_fbb, const PoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _isGlobal = _o->isGlobal;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _type = _o->type;
  auto _padType = _o->padType;
  auto _dataType = _o->dataType;
  auto _ceilModel = _o->ceilModel;
  return MNN::CreatePool(
      _fbb,
      _padX,
      _padY,
      _isGlobal,
      _kernelX,
      _kernelY,
      _strideX,
      _strideY,
      _type,
      _padType,
      _dataType,
      _ceilModel);
}

inline Pool3DT *Pool3D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Pool3DT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Pool3D::UnPackTo(Pool3DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } };
  { auto _e = kernels(); if (_e) { _o->kernels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernels[_i] = _e->Get(_i); } } };
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } };
  { auto _e = type(); _o->type = _e; };
  { auto _e = padType(); _o->padType = _e; };
}

inline flatbuffers::Offset<Pool3D> Pool3D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool3D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool3D> CreatePool3D(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool3DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _kernels = _o->kernels.size() ? _fbb.CreateVector(_o->kernels) : 0;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _type = _o->type;
  auto _padType = _o->padType;
  return MNN::CreatePool3D(
      _fbb,
      _strides,
      _kernels,
      _pads,
      _type,
      _padType);
}

inline ReluT *Relu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReluT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Relu::UnPackTo(ReluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slope(); _o->slope = _e; };
}

inline flatbuffers::Offset<Relu> Relu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Relu> CreateRelu(flatbuffers::FlatBufferBuilder &_fbb, const ReluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slope = _o->slope;
  return MNN::CreateRelu(
      _fbb,
      _slope);
}

inline Relu6T *Relu6::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Relu6T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Relu6::UnPackTo(Relu6T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slope(); _o->slope = _e; };
}

inline flatbuffers::Offset<Relu6> Relu6::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelu6(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Relu6> CreateRelu6(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Relu6T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slope = _o->slope;
  return MNN::CreateRelu6(
      _fbb,
      _slope);
}

inline PReluT *PRelu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PReluT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PRelu::UnPackTo(PReluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slopeCount(); _o->slopeCount = _e; };
  { auto _e = slope(); if (_e) { _o->slope.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slope[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<PRelu> PRelu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePRelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PRelu> CreatePRelu(flatbuffers::FlatBufferBuilder &_fbb, const PReluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PReluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slopeCount = _o->slopeCount;
  auto _slope = _o->slope.size() ? _fbb.CreateVector(_o->slope) : 0;
  return MNN::CreatePRelu(
      _fbb,
      _slopeCount,
      _slope);
}

inline ELUT *ELU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ELUT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ELU::UnPackTo(ELUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; };
}

inline flatbuffers::Offset<ELU> ELU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ELUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateELU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ELU> CreateELU(flatbuffers::FlatBufferBuilder &_fbb, const ELUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ELUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return MNN::CreateELU(
      _fbb,
      _alpha);
}

inline LRNT *LRN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LRNT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LRN::UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = regionType(); _o->regionType = _e; };
  { auto _e = localSize(); _o->localSize = _e; };
  { auto _e = alpha(); _o->alpha = _e; };
  { auto _e = beta(); _o->beta = _e; };
}

inline flatbuffers::Offset<LRN> LRN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLRN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LRNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _regionType = _o->regionType;
  auto _localSize = _o->localSize;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  return MNN::CreateLRN(
      _fbb,
      _regionType,
      _localSize,
      _alpha,
      _beta);
}

inline ArgMaxT *ArgMax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ArgMaxT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ArgMax::UnPackTo(ArgMaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outMaxVal(); _o->outMaxVal = _e; };
  { auto _e = topK(); _o->topK = _e; };
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = softmaxThreshold(); _o->softmaxThreshold = _e; };
}

inline flatbuffers::Offset<ArgMax> ArgMax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMax> CreateArgMax(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outMaxVal = _o->outMaxVal;
  auto _topK = _o->topK;
  auto _axis = _o->axis;
  auto _softmaxThreshold = _o->softmaxThreshold;
  return MNN::CreateArgMax(
      _fbb,
      _outMaxVal,
      _topK,
      _axis,
      _softmaxThreshold);
}

inline AxisT *Axis::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AxisT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Axis::UnPackTo(AxisT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<Axis> Axis::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AxisT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAxis(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Axis> CreateAxis(flatbuffers::FlatBufferBuilder &_fbb, const AxisT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AxisT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return MNN::CreateAxis(
      _fbb,
      _axis);
}

inline InputT *Input::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InputT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Input::UnPackTo(InputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } };
  { auto _e = dtype(); _o->dtype = _e; };
  { auto _e = dformat(); _o->dformat = _e; };
}

inline flatbuffers::Offset<Input> Input::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Input> CreateInput(flatbuffers::FlatBufferBuilder &_fbb, const InputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dtype = _o->dtype;
  auto _dformat = _o->dformat;
  return MNN::CreateInput(
      _fbb,
      _dims,
      _dtype,
      _dformat);
}

inline LSTMT *LSTM::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LSTMT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LSTM::UnPackTo(LSTMT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = weightSize(); _o->weightSize = _e; };
  { auto _e = clippingThreshold(); _o->clippingThreshold = _e; };
  { auto _e = weightI(); if (_e) _o->weightI = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = weightH(); if (_e) _o->weightH = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bias(); if (_e) _o->bias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = weightIQ(); if (_e) _o->weightIQ = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = weightIA(); if (_e) _o->weightIA = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = quantScale(); _o->quantScale = _e; };
}

inline flatbuffers::Offset<LSTM> LSTM::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSTM(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTM> CreateLSTM(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputCount = _o->outputCount;
  auto _weightSize = _o->weightSize;
  auto _clippingThreshold = _o->clippingThreshold;
  auto _weightI = _o->weightI ? CreateBlob(_fbb, _o->weightI.get(), _rehasher) : 0;
  auto _weightH = _o->weightH ? CreateBlob(_fbb, _o->weightH.get(), _rehasher) : 0;
  auto _bias = _o->bias ? CreateBlob(_fbb, _o->bias.get(), _rehasher) : 0;
  auto _weightIQ = _o->weightIQ ? CreateBlob(_fbb, _o->weightIQ.get(), _rehasher) : 0;
  auto _weightIA = _o->weightIA ? CreateBlob(_fbb, _o->weightIA.get(), _rehasher) : 0;
  auto _quantScale = _o->quantScale;
  return MNN::CreateLSTM(
      _fbb,
      _outputCount,
      _weightSize,
      _clippingThreshold,
      _weightI,
      _weightH,
      _bias,
      _weightIQ,
      _weightIA,
      _quantScale);
}

inline SliceT *Slice::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SliceT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Slice::UnPackTo(SliceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = slicePoints(); if (_e) { _o->slicePoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slicePoints[_i] = _e->Get(_i); } } };
  { auto _e = sourceType(); _o->sourceType = _e; };
}

inline flatbuffers::Offset<Slice> Slice::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSlice(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Slice> CreateSlice(flatbuffers::FlatBufferBuilder &_fbb, const SliceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _slicePoints = _o->slicePoints.size() ? _fbb.CreateVector(_o->slicePoints) : 0;
  auto _sourceType = _o->sourceType;
  return MNN::CreateSlice(
      _fbb,
      _axis,
      _slicePoints,
      _sourceType);
}

inline BatchNormT *BatchNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BatchNormT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BatchNorm::UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; };
  { auto _e = slopeData(); if (_e) { _o->slopeData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slopeData[_i] = _e->Get(_i); } } };
  { auto _e = meanData(); if (_e) { _o->meanData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meanData[_i] = _e->Get(_i); } } };
  { auto _e = varData(); if (_e) { _o->varData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->varData[_i] = _e->Get(_i); } } };
  { auto _e = biasData(); if (_e) { _o->biasData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->biasData[_i] = _e->Get(_i); } } };
  { auto _e = Adata(); if (_e) { _o->Adata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Adata[_i] = _e->Get(_i); } } };
  { auto _e = Bdata(); if (_e) { _o->Bdata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Bdata[_i] = _e->Get(_i); } } };
  { auto _e = epsilon(); _o->epsilon = _e; };
}

inline flatbuffers::Offset<BatchNorm> BatchNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _slopeData = _o->slopeData.size() ? _fbb.CreateVector(_o->slopeData) : 0;
  auto _meanData = _o->meanData.size() ? _fbb.CreateVector(_o->meanData) : 0;
  auto _varData = _o->varData.size() ? _fbb.CreateVector(_o->varData) : 0;
  auto _biasData = _o->biasData.size() ? _fbb.CreateVector(_o->biasData) : 0;
  auto _Adata = _o->Adata.size() ? _fbb.CreateVector(_o->Adata) : 0;
  auto _Bdata = _o->Bdata.size() ? _fbb.CreateVector(_o->Bdata) : 0;
  auto _epsilon = _o->epsilon;
  return MNN::CreateBatchNorm(
      _fbb,
      _channels,
      _slopeData,
      _meanData,
      _varData,
      _biasData,
      _Adata,
      _Bdata,
      _epsilon);
}

inline ScaleT *Scale::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ScaleT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Scale::UnPackTo(ScaleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; };
  { auto _e = scaleData(); if (_e) { _o->scaleData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scaleData[_i] = _e->Get(_i); } } };
  { auto _e = biasData(); if (_e) { _o->biasData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->biasData[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Scale> Scale::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScale(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Scale> CreateScale(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScaleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _scaleData = _o->scaleData.size() ? _fbb.CreateVector(_o->scaleData) : 0;
  auto _biasData = _o->biasData.size() ? _fbb.CreateVector(_o->biasData) : 0;
  return MNN::CreateScale(
      _fbb,
      _channels,
      _scaleData,
      _biasData);
}

inline EltwiseT *Eltwise::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EltwiseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Eltwise::UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = coeff(); if (_e) { _o->coeff.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->coeff[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Eltwise> Eltwise::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEltwise(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _coeff = _o->coeff.size() ? _fbb.CreateVector(_o->coeff) : 0;
  return MNN::CreateEltwise(
      _fbb,
      _type,
      _coeff);
}

inline FlattenT *Flatten::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FlattenT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Flatten::UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = endAxis(); _o->endAxis = _e; };
}

inline flatbuffers::Offset<Flatten> Flatten::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlatten(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _endAxis = _o->endAxis;
  return MNN::CreateFlatten(
      _fbb,
      _axis,
      _endAxis);
}

inline PermuteT *Permute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PermuteT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Permute::UnPackTo(PermuteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Permute> Permute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePermute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Permute> CreatePermute(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PermuteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return MNN::CreatePermute(
      _fbb,
      _dims);
}

inline ReshapeT *Reshape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReshapeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reshape::UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } };
  { auto _e = dimType(); _o->dimType = _e; };
}

inline flatbuffers::Offset<Reshape> Reshape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dimType = _o->dimType;
  return MNN::CreateReshape(
      _fbb,
      _dims,
      _dimType);
}

inline DetectionOutputT *DetectionOutput::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DetectionOutputT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DetectionOutput::UnPackTo(DetectionOutputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = classCount(); _o->classCount = _e; };
  { auto _e = nmsThresholdold(); _o->nmsThresholdold = _e; };
  { auto _e = nmsTopK(); _o->nmsTopK = _e; };
  { auto _e = keepTopK(); _o->keepTopK = _e; };
  { auto _e = confidenceThreshold(); _o->confidenceThreshold = _e; };
  { auto _e = shareLocation(); _o->shareLocation = _e; };
  { auto _e = backgroundLable(); _o->backgroundLable = _e; };
  { auto _e = varianceEncodedTarget(); _o->varianceEncodedTarget = _e; };
  { auto _e = codeType(); _o->codeType = _e; };
  { auto _e = objectnessScore(); _o->objectnessScore = _e; };
}

inline flatbuffers::Offset<DetectionOutput> DetectionOutput::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectionOutput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectionOutput> CreateDetectionOutput(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionOutputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _classCount = _o->classCount;
  auto _nmsThresholdold = _o->nmsThresholdold;
  auto _nmsTopK = _o->nmsTopK;
  auto _keepTopK = _o->keepTopK;
  auto _confidenceThreshold = _o->confidenceThreshold;
  auto _shareLocation = _o->shareLocation;
  auto _backgroundLable = _o->backgroundLable;
  auto _varianceEncodedTarget = _o->varianceEncodedTarget;
  auto _codeType = _o->codeType;
  auto _objectnessScore = _o->objectnessScore;
  return MNN::CreateDetectionOutput(
      _fbb,
      _classCount,
      _nmsThresholdold,
      _nmsTopK,
      _keepTopK,
      _confidenceThreshold,
      _shareLocation,
      _backgroundLable,
      _varianceEncodedTarget,
      _codeType,
      _objectnessScore);
}

inline RoiPoolingT *RoiPooling::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RoiPoolingT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RoiPooling::UnPackTo(RoiPoolingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pooledWidth(); _o->pooledWidth = _e; };
  { auto _e = pooledHeight(); _o->pooledHeight = _e; };
  { auto _e = spatialScale(); _o->spatialScale = _e; };
}

inline flatbuffers::Offset<RoiPooling> RoiPooling::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoiPooling(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoiPooling> CreateRoiPooling(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoiPoolingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pooledWidth = _o->pooledWidth;
  auto _pooledHeight = _o->pooledHeight;
  auto _spatialScale = _o->spatialScale;
  return MNN::CreateRoiPooling(
      _fbb,
      _pooledWidth,
      _pooledHeight,
      _spatialScale);
}

inline ProposalT *Proposal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProposalT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Proposal::UnPackTo(ProposalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = featStride(); _o->featStride = _e; };
  { auto _e = baseSize(); _o->baseSize = _e; };
  { auto _e = preNmsTopN(); _o->preNmsTopN = _e; };
  { auto _e = afterNmsTopN(); _o->afterNmsTopN = _e; };
  { auto _e = nmsThreshold(); _o->nmsThreshold = _e; };
  { auto _e = minSize(); _o->minSize = _e; };
  { auto _e = ratios(); if (_e) _o->ratios = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = scales(); if (_e) _o->scales = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = anchors(); if (_e) _o->anchors = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Proposal> Proposal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProposal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Proposal> CreateProposal(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProposalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _featStride = _o->featStride;
  auto _baseSize = _o->baseSize;
  auto _preNmsTopN = _o->preNmsTopN;
  auto _afterNmsTopN = _o->afterNmsTopN;
  auto _nmsThreshold = _o->nmsThreshold;
  auto _minSize = _o->minSize;
  auto _ratios = _o->ratios ? CreateBlob(_fbb, _o->ratios.get(), _rehasher) : 0;
  auto _scales = _o->scales ? CreateBlob(_fbb, _o->scales.get(), _rehasher) : 0;
  auto _anchors = _o->anchors ? CreateBlob(_fbb, _o->anchors.get(), _rehasher) : 0;
  return MNN::CreateProposal(
      _fbb,
      _featStride,
      _baseSize,
      _preNmsTopN,
      _afterNmsTopN,
      _nmsThreshold,
      _minSize,
      _ratios,
      _scales,
      _anchors);
}

inline InterpT *Interp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InterpT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Interp::UnPackTo(InterpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = widthScale(); _o->widthScale = _e; };
  { auto _e = heightScale(); _o->heightScale = _e; };
  { auto _e = outputWidth(); _o->outputWidth = _e; };
  { auto _e = outputHeight(); _o->outputHeight = _e; };
  { auto _e = resizeType(); _o->resizeType = _e; };
  { auto _e = alignCorners(); _o->alignCorners = _e; };
  { auto _e = halfPixelCenters(); _o->halfPixelCenters = _e; };
}

inline flatbuffers::Offset<Interp> Interp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInterp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Interp> CreateInterp(flatbuffers::FlatBufferBuilder &_fbb, const InterpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InterpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _widthScale = _o->widthScale;
  auto _heightScale = _o->heightScale;
  auto _outputWidth = _o->outputWidth;
  auto _outputHeight = _o->outputHeight;
  auto _resizeType = _o->resizeType;
  auto _alignCorners = _o->alignCorners;
  auto _halfPixelCenters = _o->halfPixelCenters;
  return MNN::CreateInterp(
      _fbb,
      _widthScale,
      _heightScale,
      _outputWidth,
      _outputHeight,
      _resizeType,
      _alignCorners,
      _halfPixelCenters);
}

inline ResizeT *Resize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResizeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Resize::UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = xScale(); _o->xScale = _e; };
  { auto _e = yScale(); _o->yScale = _e; };
}

inline flatbuffers::Offset<Resize> Resize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _xScale = _o->xScale;
  auto _yScale = _o->yScale;
  return MNN::CreateResize(
      _fbb,
      _xScale,
      _yScale);
}

inline PriorBoxT *PriorBox::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PriorBoxT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PriorBox::UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = minSizes(); if (_e) { _o->minSizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->minSizes[_i] = _e->Get(_i); } } };
  { auto _e = maxSizes(); if (_e) { _o->maxSizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->maxSizes[_i] = _e->Get(_i); } } };
  { auto _e = aspectRatios(); if (_e) { _o->aspectRatios.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aspectRatios[_i] = _e->Get(_i); } } };
  { auto _e = variances(); if (_e) { _o->variances.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variances[_i] = _e->Get(_i); } } };
  { auto _e = flip(); _o->flip = _e; };
  { auto _e = clip(); _o->clip = _e; };
  { auto _e = imageWidth(); _o->imageWidth = _e; };
  { auto _e = imageHeight(); _o->imageHeight = _e; };
  { auto _e = stepWidth(); _o->stepWidth = _e; };
  { auto _e = stepHeight(); _o->stepHeight = _e; };
  { auto _e = offset(); _o->offset = _e; };
}

inline flatbuffers::Offset<PriorBox> PriorBox::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriorBox(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PriorBoxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _minSizes = _o->minSizes.size() ? _fbb.CreateVector(_o->minSizes) : 0;
  auto _maxSizes = _o->maxSizes.size() ? _fbb.CreateVector(_o->maxSizes) : 0;
  auto _aspectRatios = _o->aspectRatios.size() ? _fbb.CreateVector(_o->aspectRatios) : 0;
  auto _variances = _o->variances.size() ? _fbb.CreateVector(_o->variances) : 0;
  auto _flip = _o->flip;
  auto _clip = _o->clip;
  auto _imageWidth = _o->imageWidth;
  auto _imageHeight = _o->imageHeight;
  auto _stepWidth = _o->stepWidth;
  auto _stepHeight = _o->stepHeight;
  auto _offset = _o->offset;
  return MNN::CreatePriorBox(
      _fbb,
      _minSizes,
      _maxSizes,
      _aspectRatios,
      _variances,
      _flip,
      _clip,
      _imageWidth,
      _imageHeight,
      _stepWidth,
      _stepHeight,
      _offset);
}

inline NormalizeT *Normalize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NormalizeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Normalize::UnPackTo(NormalizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acrossSpatial(); _o->acrossSpatial = _e; };
  { auto _e = channelShared(); _o->channelShared = _e; };
  { auto _e = eps(); _o->eps = _e; };
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Normalize> Normalize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNormalize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Normalize> CreateNormalize(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NormalizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _acrossSpatial = _o->acrossSpatial;
  auto _channelShared = _o->channelShared;
  auto _eps = _o->eps;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  return MNN::CreateNormalize(
      _fbb,
      _acrossSpatial,
      _channelShared,
      _eps,
      _scale);
}

inline EltwiseInt8T *EltwiseInt8::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EltwiseInt8T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EltwiseInt8::UnPackTo(EltwiseInt8T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = inputQuan0(); if (_e) _o->inputQuan0 = std::unique_ptr<QuantizedFloatParamT>(_e->UnPack(_resolver)); };
  { auto _e = inputQuan1(); if (_e) _o->inputQuan1 = std::unique_ptr<QuantizedFloatParamT>(_e->UnPack(_resolver)); };
  { auto _e = outputQuan(); if (_e) _o->outputQuan = std::unique_ptr<QuantizedFloatParamT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<EltwiseInt8> EltwiseInt8::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEltwiseInt8(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EltwiseInt8> CreateEltwiseInt8(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseInt8T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _inputQuan0 = _o->inputQuan0 ? CreateQuantizedFloatParam(_fbb, _o->inputQuan0.get(), _rehasher) : 0;
  auto _inputQuan1 = _o->inputQuan1 ? CreateQuantizedFloatParam(_fbb, _o->inputQuan1.get(), _rehasher) : 0;
  auto _outputQuan = _o->outputQuan ? CreateQuantizedFloatParam(_fbb, _o->outputQuan.get(), _rehasher) : 0;
  return MNN::CreateEltwiseInt8(
      _fbb,
      _type,
      _inputQuan0,
      _inputQuan1,
      _outputQuan);
}

inline const flatbuffers::TypeTable *PadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable
  };
  static const char * const names[] = {
    "MAXPOOL",
    "AVEPOOL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolPadTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolPadTypeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    EltwiseTypeTypeTable
  };
  static const char * const names[] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "SUB"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution2DCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "padX",
    "padY",
    "kernelX",
    "kernelY",
    "strideX",
    "strideY",
    "dilateX",
    "dilateY",
    "padMode",
    "group",
    "outputCount",
    "inputCount",
    "relu",
    "relu6"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution3DCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "dilates",
    "strides",
    "kernels",
    "pads",
    "padMode",
    "inputCount",
    "outputCount",
    "relu",
    "relu6"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IDSTQuanTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "buffer",
    "alpha",
    "type",
    "useInt32",
    "quantScale",
    "scaleIn",
    "scaleOut",
    "aMax",
    "aMin",
    "readType",
    "has_scaleInt"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantizedFloatParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "weight",
    "bias",
    "scale",
    "tensorScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Convolution2DCommonTypeTable,
    IDSTQuanTypeTable,
    QuantizedFloatParamTypeTable
  };
  static const char * const names[] = {
    "common",
    "weight",
    "bias",
    "quanParameter",
    "symmetricQuan"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution3DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Convolution3DCommonTypeTable
  };
  static const char * const names[] = {
    "common",
    "weight",
    "bias"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InnerProductTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    IDSTQuanTypeTable
  };
  static const char * const names[] = {
    "outputCount",
    "biasTerm",
    "weightSize",
    "weight",
    "bias",
    "axis",
    "transpose",
    "quanParameter"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, 2 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable,
    PoolPadTypeTypeTable,
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "padX",
    "padY",
    "isGlobal",
    "kernelX",
    "kernelY",
    "strideX",
    "strideY",
    "type",
    "padType",
    "dataType",
    "ceilModel"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pool3DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable,
    PoolPadTypeTypeTable
  };
  static const char * const names[] = {
    "strides",
    "kernels",
    "pads",
    "type",
    "padType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Relu6TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PReluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "slopeCount",
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ELUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LRNTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "regionType",
    "localSize",
    "alpha",
    "beta"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "outMaxVal",
    "topK",
    "axis",
    "softmaxThreshold"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AxisTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable,
    MNN_DATA_FORMATTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dtype",
    "dformat"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LSTMTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlobTypeTable
  };
  static const char * const names[] = {
    "outputCount",
    "weightSize",
    "clippingThreshold",
    "weightI",
    "weightH",
    "bias",
    "weightIQ",
    "weightIA",
    "quantScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SliceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    NetSourceTypeTable
  };
  static const char * const names[] = {
    "axis",
    "slicePoints",
    "sourceType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "channels",
    "slopeData",
    "meanData",
    "varData",
    "biasData",
    "Adata",
    "Bdata",
    "epsilon"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScaleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "channels",
    "scaleData",
    "biasData"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    EltwiseTypeTypeTable
  };
  static const char * const names[] = {
    "type",
    "coeff"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FlattenTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis",
    "endAxis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PermuteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReshapeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MNN_DATA_FORMATTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dimType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DetectionOutputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "classCount",
    "nmsThresholdold",
    "nmsTopK",
    "keepTopK",
    "confidenceThreshold",
    "shareLocation",
    "backgroundLable",
    "varianceEncodedTarget",
    "codeType",
    "objectnessScore"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoiPoolingTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "pooledWidth",
    "pooledHeight",
    "spatialScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProposalTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlobTypeTable
  };
  static const char * const names[] = {
    "featStride",
    "baseSize",
    "preNmsTopN",
    "afterNmsTopN",
    "nmsThreshold",
    "minSize",
    "ratios",
    "scales",
    "anchors"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InterpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "widthScale",
    "heightScale",
    "outputWidth",
    "outputHeight",
    "resizeType",
    "alignCorners",
    "halfPixelCenters"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "xScale",
    "yScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PriorBoxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "minSizes",
    "maxSizes",
    "aspectRatios",
    "variances",
    "flip",
    "clip",
    "imageWidth",
    "imageHeight",
    "stepWidth",
    "stepHeight",
    "offset"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NormalizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "acrossSpatial",
    "channelShared",
    "eps",
    "scale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseInt8TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    EltwiseTypeTypeTable,
    QuantizedFloatParamTypeTable
  };
  static const char * const names[] = {
    "type",
    "inputQuan0",
    "inputQuan1",
    "outputQuan"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace MNN

#endif  // FLATBUFFERS_GENERATED_CAFFEOP_MNN_H_
