// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CAFFEOP_MNN_H_
#define FLATBUFFERS_GENERATED_CAFFEOP_MNN_H_


#include "Tensor_generated.h"
#include "Type_generated.h"

namespace MNN {

struct Convolution2DCommon;
struct Convolution2DCommonT;

struct Convolution3DCommon;
struct Convolution3DCommonT;

struct SparseCommon;
struct SparseCommonT;

struct IDSTQuan;
struct IDSTQuanT;

struct QuantizedFloatParam;
struct QuantizedFloatParamT;

struct Convolution2D;
struct Convolution2DT;

struct Convolution3D;
struct Convolution3DT;

struct InnerProduct;
struct InnerProductT;

struct Pool;
struct PoolT;

struct Pool3D;
struct Pool3DT;

struct Relu;
struct ReluT;

struct Relu6;
struct Relu6T;

struct PRelu;
struct PReluT;

struct ELU;
struct ELUT;

struct LRN;
struct LRNT;

struct ArgMax;
struct ArgMaxT;

struct Axis;
struct AxisT;

struct Input;
struct InputT;

struct LSTM;
struct LSTMT;

struct Slice;
struct SliceT;

struct BatchNorm;
struct BatchNormT;

struct Scale;
struct ScaleT;

struct Eltwise;
struct EltwiseT;

struct Flatten;
struct FlattenT;

struct Permute;
struct PermuteT;

struct Reshape;
struct ReshapeT;

struct DetectionOutput;
struct DetectionOutputT;

struct RoiParameters;
struct RoiParametersT;

struct Proposal;
struct ProposalT;

struct Interp;
struct InterpT;

struct Resize;
struct ResizeT;

struct PriorBox;
struct PriorBoxT;

struct Normalize;
struct NormalizeT;

struct EltwiseInt8;
struct EltwiseInt8T;

struct CumSum;
struct CumSumT;

inline const flatbuffers::TypeTable *Convolution2DCommonTypeTable();

inline const flatbuffers::TypeTable *Convolution3DCommonTypeTable();

inline const flatbuffers::TypeTable *SparseCommonTypeTable();

inline const flatbuffers::TypeTable *IDSTQuanTypeTable();

inline const flatbuffers::TypeTable *QuantizedFloatParamTypeTable();

inline const flatbuffers::TypeTable *Convolution2DTypeTable();

inline const flatbuffers::TypeTable *Convolution3DTypeTable();

inline const flatbuffers::TypeTable *InnerProductTypeTable();

inline const flatbuffers::TypeTable *PoolTypeTable();

inline const flatbuffers::TypeTable *Pool3DTypeTable();

inline const flatbuffers::TypeTable *ReluTypeTable();

inline const flatbuffers::TypeTable *Relu6TypeTable();

inline const flatbuffers::TypeTable *PReluTypeTable();

inline const flatbuffers::TypeTable *ELUTypeTable();

inline const flatbuffers::TypeTable *LRNTypeTable();

inline const flatbuffers::TypeTable *ArgMaxTypeTable();

inline const flatbuffers::TypeTable *AxisTypeTable();

inline const flatbuffers::TypeTable *InputTypeTable();

inline const flatbuffers::TypeTable *LSTMTypeTable();

inline const flatbuffers::TypeTable *SliceTypeTable();

inline const flatbuffers::TypeTable *BatchNormTypeTable();

inline const flatbuffers::TypeTable *ScaleTypeTable();

inline const flatbuffers::TypeTable *EltwiseTypeTable();

inline const flatbuffers::TypeTable *FlattenTypeTable();

inline const flatbuffers::TypeTable *PermuteTypeTable();

inline const flatbuffers::TypeTable *ReshapeTypeTable();

inline const flatbuffers::TypeTable *DetectionOutputTypeTable();

inline const flatbuffers::TypeTable *RoiParametersTypeTable();

inline const flatbuffers::TypeTable *ProposalTypeTable();

inline const flatbuffers::TypeTable *InterpTypeTable();

inline const flatbuffers::TypeTable *ResizeTypeTable();

inline const flatbuffers::TypeTable *PriorBoxTypeTable();

inline const flatbuffers::TypeTable *NormalizeTypeTable();

inline const flatbuffers::TypeTable *EltwiseInt8TypeTable();

inline const flatbuffers::TypeTable *CumSumTypeTable();

enum PadMode {
  PadMode_CAFFE = 0,
  PadMode_VALID = 1,
  PadMode_SAME = 2,
  PadMode_MIN = PadMode_CAFFE,
  PadMode_MAX = PadMode_SAME
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_CAFFE,
    PadMode_VALID,
    PadMode_SAME
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (e < PadMode_CAFFE || e > PadMode_SAME) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPadMode()[index];
}

enum SparseAlgo {
  SparseAlgo_RANDOM = 0,
  SparseAlgo_SIMD_OC = 1,
  SparseAlgo_MIN = SparseAlgo_RANDOM,
  SparseAlgo_MAX = SparseAlgo_SIMD_OC
};

inline const SparseAlgo (&EnumValuesSparseAlgo())[2] {
  static const SparseAlgo values[] = {
    SparseAlgo_RANDOM,
    SparseAlgo_SIMD_OC
  };
  return values;
}

inline const char * const *EnumNamesSparseAlgo() {
  static const char * const names[] = {
    "RANDOM",
    "SIMD_OC",
    nullptr
  };
  return names;
}

inline const char *EnumNameSparseAlgo(SparseAlgo e) {
  if (e < SparseAlgo_RANDOM || e > SparseAlgo_SIMD_OC) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesSparseAlgo()[index];
}

enum QuantizeAlgo {
  QuantizeAlgo_DEFAULT = 0,
  QuantizeAlgo_OVERFLOW_AWARE = 1,
  QuantizeAlgo_WINOGRAD_AWARE = 2,
  QuantizeAlgo_MIN = QuantizeAlgo_DEFAULT,
  QuantizeAlgo_MAX = QuantizeAlgo_WINOGRAD_AWARE
};

inline const QuantizeAlgo (&EnumValuesQuantizeAlgo())[3] {
  static const QuantizeAlgo values[] = {
    QuantizeAlgo_DEFAULT,
    QuantizeAlgo_OVERFLOW_AWARE,
    QuantizeAlgo_WINOGRAD_AWARE
  };
  return values;
}

inline const char * const *EnumNamesQuantizeAlgo() {
  static const char * const names[] = {
    "DEFAULT",
    "OVERFLOW_AWARE",
    "WINOGRAD_AWARE",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizeAlgo(QuantizeAlgo e) {
  if (e < QuantizeAlgo_DEFAULT || e > QuantizeAlgo_WINOGRAD_AWARE) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesQuantizeAlgo()[index];
}

enum PoolType {
  PoolType_MAXPOOL = 0,
  PoolType_AVEPOOL = 1,
  PoolType_MIN = PoolType_MAXPOOL,
  PoolType_MAX = PoolType_AVEPOOL
};

inline const PoolType (&EnumValuesPoolType())[2] {
  static const PoolType values[] = {
    PoolType_MAXPOOL,
    PoolType_AVEPOOL
  };
  return values;
}

inline const char * const *EnumNamesPoolType() {
  static const char * const names[] = {
    "MAXPOOL",
    "AVEPOOL",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolType(PoolType e) {
  if (e < PoolType_MAXPOOL || e > PoolType_AVEPOOL) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPoolType()[index];
}

enum PoolPadType {
  PoolPadType_CAFFE = 0,
  PoolPadType_VALID = 1,
  PoolPadType_SAME = 2,
  PoolPadType_MIN = PoolPadType_CAFFE,
  PoolPadType_MAX = PoolPadType_SAME
};

inline const PoolPadType (&EnumValuesPoolPadType())[3] {
  static const PoolPadType values[] = {
    PoolPadType_CAFFE,
    PoolPadType_VALID,
    PoolPadType_SAME
  };
  return values;
}

inline const char * const *EnumNamesPoolPadType() {
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolPadType(PoolPadType e) {
  if (e < PoolPadType_CAFFE || e > PoolPadType_SAME) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPoolPadType()[index];
}

enum AvgPoolCountType {
  AvgPoolCountType_DEFAULT = 0,
  AvgPoolCountType_INCLUDE_PADDING = 1,
  AvgPoolCountType_EXCLUDE_PADDING = 2,
  AvgPoolCountType_MIN = AvgPoolCountType_DEFAULT,
  AvgPoolCountType_MAX = AvgPoolCountType_EXCLUDE_PADDING
};

inline const AvgPoolCountType (&EnumValuesAvgPoolCountType())[3] {
  static const AvgPoolCountType values[] = {
    AvgPoolCountType_DEFAULT,
    AvgPoolCountType_INCLUDE_PADDING,
    AvgPoolCountType_EXCLUDE_PADDING
  };
  return values;
}

inline const char * const *EnumNamesAvgPoolCountType() {
  static const char * const names[] = {
    "DEFAULT",
    "INCLUDE_PADDING",
    "EXCLUDE_PADDING",
    nullptr
  };
  return names;
}

inline const char *EnumNameAvgPoolCountType(AvgPoolCountType e) {
  if (e < AvgPoolCountType_DEFAULT || e > AvgPoolCountType_EXCLUDE_PADDING) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesAvgPoolCountType()[index];
}

enum EltwiseType {
  EltwiseType_PROD = 0,
  EltwiseType_SUM = 1,
  EltwiseType_MAXIMUM = 2,
  EltwiseType_SUB = 3,
  EltwiseType_MIN = EltwiseType_PROD,
  EltwiseType_MAX = EltwiseType_SUB
};

inline const EltwiseType (&EnumValuesEltwiseType())[4] {
  static const EltwiseType values[] = {
    EltwiseType_PROD,
    EltwiseType_SUM,
    EltwiseType_MAXIMUM,
    EltwiseType_SUB
  };
  return values;
}

inline const char * const *EnumNamesEltwiseType() {
  static const char * const names[] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "SUB",
    nullptr
  };
  return names;
}

inline const char *EnumNameEltwiseType(EltwiseType e) {
  if (e < EltwiseType_PROD || e > EltwiseType_SUB) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesEltwiseType()[index];
}

enum CoordinateTransformationMode {
  CoordinateTransformationMode_NotSet = 0,
  CoordinateTransformationMode_AlignCorners = 1,
  CoordinateTransformationMode_HalfPixels = 2,
  CoordinateTransformationMode_PytorchHalfPixels = 3,
  CoordinateTransformationMode_Asymmetric = 4,
  CoordinateTransformationMode_TensorflowHalfPixels = 5,
  CoordinateTransformationMode_TensorflowCropAndResize = 6,
  CoordinateTransformationMode_MIN = CoordinateTransformationMode_NotSet,
  CoordinateTransformationMode_MAX = CoordinateTransformationMode_TensorflowCropAndResize
};

inline const CoordinateTransformationMode (&EnumValuesCoordinateTransformationMode())[7] {
  static const CoordinateTransformationMode values[] = {
    CoordinateTransformationMode_NotSet,
    CoordinateTransformationMode_AlignCorners,
    CoordinateTransformationMode_HalfPixels,
    CoordinateTransformationMode_PytorchHalfPixels,
    CoordinateTransformationMode_Asymmetric,
    CoordinateTransformationMode_TensorflowHalfPixels,
    CoordinateTransformationMode_TensorflowCropAndResize
  };
  return values;
}

inline const char * const *EnumNamesCoordinateTransformationMode() {
  static const char * const names[] = {
    "NotSet",
    "AlignCorners",
    "HalfPixels",
    "PytorchHalfPixels",
    "Asymmetric",
    "TensorflowHalfPixels",
    "TensorflowCropAndResize",
    nullptr
  };
  return names;
}

inline const char *EnumNameCoordinateTransformationMode(CoordinateTransformationMode e) {
  if (e < CoordinateTransformationMode_NotSet || e > CoordinateTransformationMode_TensorflowCropAndResize) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesCoordinateTransformationMode()[index];
}

struct Convolution2DCommonT : public flatbuffers::NativeTable {
  typedef Convolution2DCommon TableType;
  int32_t padX;
  int32_t padY;
  int32_t kernelX;
  int32_t kernelY;
  int32_t strideX;
  int32_t strideY;
  int32_t dilateX;
  int32_t dilateY;
  PadMode padMode;
  int32_t group;
  int32_t outputCount;
  int32_t inputCount;
  bool relu;
  bool relu6;
  std::vector<int32_t> pads;
  std::vector<int32_t> outPads;
  bool hasOutputShape;
  Convolution2DCommonT()
      : padX(0),
        padY(0),
        kernelX(1),
        kernelY(1),
        strideX(1),
        strideY(1),
        dilateX(1),
        dilateY(1),
        padMode(PadMode_CAFFE),
        group(1),
        outputCount(0),
        inputCount(0),
        relu(false),
        relu6(false),
        hasOutputShape(false) {
  }
};

struct Convolution2DCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution2DCommonT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution2DCommonTypeTable();
  }
  int32_t padX() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t kernelX() const {
    return GetField<int32_t>(8, 1);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(10, 1);
  }
  int32_t strideX() const {
    return GetField<int32_t>(12, 1);
  }
  int32_t strideY() const {
    return GetField<int32_t>(14, 1);
  }
  int32_t dilateX() const {
    return GetField<int32_t>(16, 1);
  }
  int32_t dilateY() const {
    return GetField<int32_t>(18, 1);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(20, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(22, 1);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(24, 0);
  }
  int32_t inputCount() const {
    return GetField<int32_t>(26, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(28, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(30, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(32);
  }
  const flatbuffers::Vector<int32_t> *outPads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(34);
  }
  bool hasOutputShape() const {
    return GetField<uint8_t>(36, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           VerifyField<int32_t>(verifier, 18) &&
           VerifyField<int8_t>(verifier, 20) &&
           VerifyField<int32_t>(verifier, 22) &&
           VerifyField<int32_t>(verifier, 24) &&
           VerifyField<int32_t>(verifier, 26) &&
           VerifyField<uint8_t>(verifier, 28) &&
           VerifyField<uint8_t>(verifier, 30) &&
           VerifyOffset(verifier, 32) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, 34) &&
           verifier.VerifyVector(outPads()) &&
           VerifyField<uint8_t>(verifier, 36) &&
           verifier.EndTable();
  }
  Convolution2DCommonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution2DCommonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution2DCommon> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution2DCommonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(4, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(6, padY, 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(8, kernelX, 1);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(10, kernelY, 1);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(12, strideX, 1);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(14, strideY, 1);
  }
  void add_dilateX(int32_t dilateX) {
    fbb_.AddElement<int32_t>(16, dilateX, 1);
  }
  void add_dilateY(int32_t dilateY) {
    fbb_.AddElement<int32_t>(18, dilateY, 1);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(20, static_cast<int8_t>(padMode), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(22, group, 1);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(24, outputCount, 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(26, inputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(28, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(30, static_cast<uint8_t>(relu6), 0);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(32, pads);
  }
  void add_outPads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads) {
    fbb_.AddOffset(34, outPads);
  }
  void add_hasOutputShape(bool hasOutputShape) {
    fbb_.AddElement<uint8_t>(36, static_cast<uint8_t>(hasOutputShape), 0);
  }
  explicit Convolution2DCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Convolution2DCommonBuilder &operator=(const Convolution2DCommonBuilder &);
  flatbuffers::Offset<Convolution2DCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution2DCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    PadMode padMode = PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads = 0,
    bool hasOutputShape = false) {
  Convolution2DCommonBuilder builder_(_fbb);
  builder_.add_outPads(outPads);
  builder_.add_pads(pads);
  builder_.add_inputCount(inputCount);
  builder_.add_outputCount(outputCount);
  builder_.add_group(group);
  builder_.add_dilateY(dilateY);
  builder_.add_dilateX(dilateX);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_hasOutputShape(hasOutputShape);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Convolution3DCommonT : public flatbuffers::NativeTable {
  typedef Convolution3DCommon TableType;
  std::vector<int32_t> dilates;
  std::vector<int32_t> strides;
  std::vector<int32_t> kernels;
  std::vector<int32_t> pads;
  PadMode padMode;
  int32_t inputCount;
  int32_t outputCount;
  bool relu;
  bool relu6;
  int32_t group;
  std::vector<int32_t> outPads;
  bool hasOutputShape;
  Convolution3DCommonT()
      : padMode(PadMode_CAFFE),
        inputCount(0),
        outputCount(0),
        relu(false),
        relu6(false),
        group(1),
        hasOutputShape(false) {
  }
};

struct Convolution3DCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution3DCommonT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution3DCommonTypeTable();
  }
  const flatbuffers::Vector<int32_t> *dilates() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<int32_t> *kernels() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(10);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(12, 0));
  }
  int32_t inputCount() const {
    return GetField<int32_t>(14, 0);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(16, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(18, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(20, 0) != 0;
  }
  int32_t group() const {
    return GetField<int32_t>(22, 1);
  }
  const flatbuffers::Vector<int32_t> *outPads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(24);
  }
  bool hasOutputShape() const {
    return GetField<uint8_t>(26, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(dilates()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(kernels()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           VerifyField<uint8_t>(verifier, 18) &&
           VerifyField<uint8_t>(verifier, 20) &&
           VerifyField<int32_t>(verifier, 22) &&
           VerifyOffset(verifier, 24) &&
           verifier.VerifyVector(outPads()) &&
           VerifyField<uint8_t>(verifier, 26) &&
           verifier.EndTable();
  }
  Convolution3DCommonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution3DCommonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution3DCommon> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution3DCommonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dilates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilates) {
    fbb_.AddOffset(4, dilates);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(6, strides);
  }
  void add_kernels(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels) {
    fbb_.AddOffset(8, kernels);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(10, pads);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(12, static_cast<int8_t>(padMode), 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(14, inputCount, 0);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(16, outputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(18, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(20, static_cast<uint8_t>(relu6), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(22, group, 1);
  }
  void add_outPads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads) {
    fbb_.AddOffset(24, outPads);
  }
  void add_hasOutputShape(bool hasOutputShape) {
    fbb_.AddElement<uint8_t>(26, static_cast<uint8_t>(hasOutputShape), 0);
  }
  explicit Convolution3DCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Convolution3DCommonBuilder &operator=(const Convolution3DCommonBuilder &);
  flatbuffers::Offset<Convolution3DCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution3DCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilates = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    PadMode padMode = PadMode_CAFFE,
    int32_t inputCount = 0,
    int32_t outputCount = 0,
    bool relu = false,
    bool relu6 = false,
    int32_t group = 1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads = 0,
    bool hasOutputShape = false) {
  Convolution3DCommonBuilder builder_(_fbb);
  builder_.add_outPads(outPads);
  builder_.add_group(group);
  builder_.add_outputCount(outputCount);
  builder_.add_inputCount(inputCount);
  builder_.add_pads(pads);
  builder_.add_kernels(kernels);
  builder_.add_strides(strides);
  builder_.add_dilates(dilates);
  builder_.add_hasOutputShape(hasOutputShape);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseCommonT : public flatbuffers::NativeTable {
  typedef SparseCommon TableType;
  SparseAlgo method;
  std::vector<std::unique_ptr<AttributeT>> args;
  SparseCommonT()
      : method(SparseAlgo_RANDOM) {
  }
};

struct SparseCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseCommonT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseCommonTypeTable();
  }
  SparseAlgo method() const {
    return static_cast<SparseAlgo>(GetField<int8_t>(4, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Attribute>> *args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Attribute>> *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfTables(args()) &&
           verifier.EndTable();
  }
  SparseCommonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseCommonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparseCommon> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseCommonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method(SparseAlgo method) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(method), 0);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attribute>>> args) {
    fbb_.AddOffset(6, args);
  }
  explicit SparseCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseCommonBuilder &operator=(const SparseCommonBuilder &);
  flatbuffers::Offset<SparseCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseCommon> CreateSparseCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    SparseAlgo method = SparseAlgo_RANDOM,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attribute>>> args = 0) {
  SparseCommonBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_method(method);
  return builder_.Finish();
}

flatbuffers::Offset<SparseCommon> CreateSparseCommon(flatbuffers::FlatBufferBuilder &_fbb, const SparseCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IDSTQuanT : public flatbuffers::NativeTable {
  typedef IDSTQuan TableType;
  std::vector<int8_t> buffer;
  std::vector<float> alpha;
  int32_t type;
  bool useInt32;
  float quantScale;
  float scaleIn;
  float scaleOut;
  int32_t aMax;
  int32_t aMin;
  int32_t readType;
  bool has_scaleInt;
  bool shapeInt32;
  uint32_t weightSize;
  std::vector<uint32_t> index;
  IDSTQuanT()
      : type(0),
        useInt32(false),
        quantScale(0.0f),
        scaleIn(0.0f),
        scaleOut(0.0f),
        aMax(0),
        aMin(0),
        readType(0),
        has_scaleInt(false),
        shapeInt32(false),
        weightSize(0) {
  }
};

struct IDSTQuan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IDSTQuanT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IDSTQuanTypeTable();
  }
  const flatbuffers::Vector<int8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(4);
  }
  const flatbuffers::Vector<float> *alpha() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  int32_t type() const {
    return GetField<int32_t>(8, 0);
  }
  bool useInt32() const {
    return GetField<uint8_t>(10, 0) != 0;
  }
  float quantScale() const {
    return GetField<float>(12, 0.0f);
  }
  float scaleIn() const {
    return GetField<float>(14, 0.0f);
  }
  float scaleOut() const {
    return GetField<float>(16, 0.0f);
  }
  int32_t aMax() const {
    return GetField<int32_t>(18, 0);
  }
  int32_t aMin() const {
    return GetField<int32_t>(20, 0);
  }
  int32_t readType() const {
    return GetField<int32_t>(22, 0);
  }
  bool has_scaleInt() const {
    return GetField<uint8_t>(24, 0) != 0;
  }
  bool shapeInt32() const {
    return GetField<uint8_t>(26, 0) != 0;
  }
  uint32_t weightSize() const {
    return GetField<uint32_t>(28, 0);
  }
  const flatbuffers::Vector<uint32_t> *index() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(30);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(buffer()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(alpha()) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<uint8_t>(verifier, 10) &&
           VerifyField<float>(verifier, 12) &&
           VerifyField<float>(verifier, 14) &&
           VerifyField<float>(verifier, 16) &&
           VerifyField<int32_t>(verifier, 18) &&
           VerifyField<int32_t>(verifier, 20) &&
           VerifyField<int32_t>(verifier, 22) &&
           VerifyField<uint8_t>(verifier, 24) &&
           VerifyField<uint8_t>(verifier, 26) &&
           VerifyField<uint32_t>(verifier, 28) &&
           VerifyOffset(verifier, 30) &&
           verifier.VerifyVector(index()) &&
           verifier.EndTable();
  }
  IDSTQuanT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IDSTQuanT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IDSTQuan> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IDSTQuanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer) {
    fbb_.AddOffset(4, buffer);
  }
  void add_alpha(flatbuffers::Offset<flatbuffers::Vector<float>> alpha) {
    fbb_.AddOffset(6, alpha);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(8, type, 0);
  }
  void add_useInt32(bool useInt32) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(useInt32), 0);
  }
  void add_quantScale(float quantScale) {
    fbb_.AddElement<float>(12, quantScale, 0.0f);
  }
  void add_scaleIn(float scaleIn) {
    fbb_.AddElement<float>(14, scaleIn, 0.0f);
  }
  void add_scaleOut(float scaleOut) {
    fbb_.AddElement<float>(16, scaleOut, 0.0f);
  }
  void add_aMax(int32_t aMax) {
    fbb_.AddElement<int32_t>(18, aMax, 0);
  }
  void add_aMin(int32_t aMin) {
    fbb_.AddElement<int32_t>(20, aMin, 0);
  }
  void add_readType(int32_t readType) {
    fbb_.AddElement<int32_t>(22, readType, 0);
  }
  void add_has_scaleInt(bool has_scaleInt) {
    fbb_.AddElement<uint8_t>(24, static_cast<uint8_t>(has_scaleInt), 0);
  }
  void add_shapeInt32(bool shapeInt32) {
    fbb_.AddElement<uint8_t>(26, static_cast<uint8_t>(shapeInt32), 0);
  }
  void add_weightSize(uint32_t weightSize) {
    fbb_.AddElement<uint32_t>(28, weightSize, 0);
  }
  void add_index(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> index) {
    fbb_.AddOffset(30, index);
  }
  explicit IDSTQuanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IDSTQuanBuilder &operator=(const IDSTQuanBuilder &);
  flatbuffers::Offset<IDSTQuan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IDSTQuan>(end);
    return o;
  }
};

inline flatbuffers::Offset<IDSTQuan> CreateIDSTQuan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> alpha = 0,
    int32_t type = 0,
    bool useInt32 = false,
    float quantScale = 0.0f,
    float scaleIn = 0.0f,
    float scaleOut = 0.0f,
    int32_t aMax = 0,
    int32_t aMin = 0,
    int32_t readType = 0,
    bool has_scaleInt = false,
    bool shapeInt32 = false,
    uint32_t weightSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> index = 0) {
  IDSTQuanBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_weightSize(weightSize);
  builder_.add_readType(readType);
  builder_.add_aMin(aMin);
  builder_.add_aMax(aMax);
  builder_.add_scaleOut(scaleOut);
  builder_.add_scaleIn(scaleIn);
  builder_.add_quantScale(quantScale);
  builder_.add_type(type);
  builder_.add_alpha(alpha);
  builder_.add_buffer(buffer);
  builder_.add_shapeInt32(shapeInt32);
  builder_.add_has_scaleInt(has_scaleInt);
  builder_.add_useInt32(useInt32);
  return builder_.Finish();
}

flatbuffers::Offset<IDSTQuan> CreateIDSTQuan(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizedFloatParamT : public flatbuffers::NativeTable {
  typedef QuantizedFloatParam TableType;
  std::vector<int8_t> weight;
  std::vector<int32_t> bias;
  std::vector<float> scale;
  std::vector<float> tensorScale;
  QuantizeAlgo method;
  int32_t nbits;
  int8_t zeroPoint;
  int8_t outputZeroPoint;
  int8_t clampMin;
  int8_t clampMax;
  std::vector<int32_t> winogradAttr;
  DataType outputDataType;
  QuantizedFloatParamT()
      : method(QuantizeAlgo_DEFAULT),
        nbits(8),
        zeroPoint(0),
        outputZeroPoint(0),
        clampMin(-128),
        clampMax(127),
        outputDataType(DataType_DT_INT8) {
  }
};

struct QuantizedFloatParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizedFloatParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantizedFloatParamTypeTable();
  }
  const flatbuffers::Vector<int8_t> *weight() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(4);
  }
  const flatbuffers::Vector<int32_t> *bias() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  const flatbuffers::Vector<float> *tensorScale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  QuantizeAlgo method() const {
    return static_cast<QuantizeAlgo>(GetField<int8_t>(12, 0));
  }
  int32_t nbits() const {
    return GetField<int32_t>(14, 8);
  }
  int8_t zeroPoint() const {
    return GetField<int8_t>(16, 0);
  }
  int8_t outputZeroPoint() const {
    return GetField<int8_t>(18, 0);
  }
  int8_t clampMin() const {
    return GetField<int8_t>(20, -128);
  }
  int8_t clampMax() const {
    return GetField<int8_t>(22, 127);
  }
  const flatbuffers::Vector<int32_t> *winogradAttr() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(24);
  }
  DataType outputDataType() const {
    return static_cast<DataType>(GetField<int32_t>(26, 6));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(tensorScale()) &&
           VerifyField<int8_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int8_t>(verifier, 16) &&
           VerifyField<int8_t>(verifier, 18) &&
           VerifyField<int8_t>(verifier, 20) &&
           VerifyField<int8_t>(verifier, 22) &&
           VerifyOffset(verifier, 24) &&
           verifier.VerifyVector(winogradAttr()) &&
           VerifyField<int32_t>(verifier, 26) &&
           verifier.EndTable();
  }
  QuantizedFloatParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizedFloatParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizedFloatParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizedFloatParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<int8_t>> weight) {
    fbb_.AddOffset(4, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<int32_t>> bias) {
    fbb_.AddOffset(6, bias);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(8, scale);
  }
  void add_tensorScale(flatbuffers::Offset<flatbuffers::Vector<float>> tensorScale) {
    fbb_.AddOffset(10, tensorScale);
  }
  void add_method(QuantizeAlgo method) {
    fbb_.AddElement<int8_t>(12, static_cast<int8_t>(method), 0);
  }
  void add_nbits(int32_t nbits) {
    fbb_.AddElement<int32_t>(14, nbits, 8);
  }
  void add_zeroPoint(int8_t zeroPoint) {
    fbb_.AddElement<int8_t>(16, zeroPoint, 0);
  }
  void add_outputZeroPoint(int8_t outputZeroPoint) {
    fbb_.AddElement<int8_t>(18, outputZeroPoint, 0);
  }
  void add_clampMin(int8_t clampMin) {
    fbb_.AddElement<int8_t>(20, clampMin, -128);
  }
  void add_clampMax(int8_t clampMax) {
    fbb_.AddElement<int8_t>(22, clampMax, 127);
  }
  void add_winogradAttr(flatbuffers::Offset<flatbuffers::Vector<int32_t>> winogradAttr) {
    fbb_.AddOffset(24, winogradAttr);
  }
  void add_outputDataType(DataType outputDataType) {
    fbb_.AddElement<int32_t>(26, static_cast<int32_t>(outputDataType), 6);
  }
  explicit QuantizedFloatParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizedFloatParamBuilder &operator=(const QuantizedFloatParamBuilder &);
  flatbuffers::Offset<QuantizedFloatParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizedFloatParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> tensorScale = 0,
    QuantizeAlgo method = QuantizeAlgo_DEFAULT,
    int32_t nbits = 8,
    int8_t zeroPoint = 0,
    int8_t outputZeroPoint = 0,
    int8_t clampMin = -128,
    int8_t clampMax = 127,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> winogradAttr = 0,
    DataType outputDataType = DataType_DT_INT8) {
  QuantizedFloatParamBuilder builder_(_fbb);
  builder_.add_outputDataType(outputDataType);
  builder_.add_winogradAttr(winogradAttr);
  builder_.add_nbits(nbits);
  builder_.add_tensorScale(tensorScale);
  builder_.add_scale(scale);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_clampMax(clampMax);
  builder_.add_clampMin(clampMin);
  builder_.add_outputZeroPoint(outputZeroPoint);
  builder_.add_zeroPoint(zeroPoint);
  builder_.add_method(method);
  return builder_.Finish();
}

flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParam(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Convolution2DT : public flatbuffers::NativeTable {
  typedef Convolution2D TableType;
  std::unique_ptr<Convolution2DCommonT> common;
  std::vector<float> weight;
  std::vector<float> bias;
  std::unique_ptr<IDSTQuanT> quanParameter;
  std::unique_ptr<QuantizedFloatParamT> symmetricQuan;
  std::unique_ptr<SparseCommonT> sparseParameter;
  std::vector<int64_t> external;
  Convolution2DT() {
  }
};

struct Convolution2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution2DT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution2DTypeTable();
  }
  const Convolution2DCommon *common() const {
    return GetPointer<const Convolution2DCommon *>(4);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  const IDSTQuan *quanParameter() const {
    return GetPointer<const IDSTQuan *>(10);
  }
  const QuantizedFloatParam *symmetricQuan() const {
    return GetPointer<const QuantizedFloatParam *>(12);
  }
  const SparseCommon *sparseParameter() const {
    return GetPointer<const SparseCommon *>(14);
  }
  const flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(16);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyTable(quanParameter()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyTable(symmetricQuan()) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyTable(sparseParameter()) &&
           VerifyOffset(verifier, 16) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
  Convolution2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<Convolution2DCommon> common) {
    fbb_.AddOffset(4, common);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(6, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(8, bias);
  }
  void add_quanParameter(flatbuffers::Offset<IDSTQuan> quanParameter) {
    fbb_.AddOffset(10, quanParameter);
  }
  void add_symmetricQuan(flatbuffers::Offset<QuantizedFloatParam> symmetricQuan) {
    fbb_.AddOffset(12, symmetricQuan);
  }
  void add_sparseParameter(flatbuffers::Offset<SparseCommon> sparseParameter) {
    fbb_.AddOffset(14, sparseParameter);
  }
  void add_external(flatbuffers::Offset<flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(16, external);
  }
  explicit Convolution2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Convolution2DBuilder &operator=(const Convolution2DBuilder &);
  flatbuffers::Offset<Convolution2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution2D> CreateConvolution2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Convolution2DCommon> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    flatbuffers::Offset<IDSTQuan> quanParameter = 0,
    flatbuffers::Offset<QuantizedFloatParam> symmetricQuan = 0,
    flatbuffers::Offset<SparseCommon> sparseParameter = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> external = 0) {
  Convolution2DBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_sparseParameter(sparseParameter);
  builder_.add_symmetricQuan(symmetricQuan);
  builder_.add_quanParameter(quanParameter);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_common(common);
  return builder_.Finish();
}

flatbuffers::Offset<Convolution2D> CreateConvolution2D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Convolution3DT : public flatbuffers::NativeTable {
  typedef Convolution3D TableType;
  std::unique_ptr<Convolution3DCommonT> common;
  std::vector<float> weight;
  std::vector<float> bias;
  std::vector<int64_t> external;
  Convolution3DT() {
  }
};

struct Convolution3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution3DT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution3DTypeTable();
  }
  const Convolution3DCommon *common() const {
    return GetPointer<const Convolution3DCommon *>(4);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  const flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(10);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
  Convolution3DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution3DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution3D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution3DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<Convolution3DCommon> common) {
    fbb_.AddOffset(4, common);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(6, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(8, bias);
  }
  void add_external(flatbuffers::Offset<flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(10, external);
  }
  explicit Convolution3DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Convolution3DBuilder &operator=(const Convolution3DBuilder &);
  flatbuffers::Offset<Convolution3D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution3D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution3D> CreateConvolution3D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Convolution3DCommon> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> external = 0) {
  Convolution3DBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_common(common);
  return builder_.Finish();
}

flatbuffers::Offset<Convolution3D> CreateConvolution3D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InnerProductT : public flatbuffers::NativeTable {
  typedef InnerProduct TableType;
  int32_t outputCount;
  int32_t biasTerm;
  int32_t weightSize;
  std::vector<float> weight;
  std::vector<float> bias;
  int32_t axis;
  bool transpose;
  std::unique_ptr<IDSTQuanT> quanParameter;
  InnerProductT()
      : outputCount(0),
        biasTerm(0),
        weightSize(0),
        axis(0),
        transpose(false) {
  }
};

struct InnerProduct FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InnerProductT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InnerProductTypeTable();
  }
  int32_t outputCount() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t biasTerm() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(8, 0);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(12);
  }
  int32_t axis() const {
    return GetField<int32_t>(14, 0);
  }
  bool transpose() const {
    return GetField<uint8_t>(16, 0) != 0;
  }
  const IDSTQuan *quanParameter() const {
    return GetPointer<const IDSTQuan *>(18);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<uint8_t>(verifier, 16) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyTable(quanParameter()) &&
           verifier.EndTable();
  }
  InnerProductT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InnerProductT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InnerProduct> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InnerProductBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(4, outputCount, 0);
  }
  void add_biasTerm(int32_t biasTerm) {
    fbb_.AddElement<int32_t>(6, biasTerm, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(8, weightSize, 0);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(10, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(12, bias);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(14, axis, 0);
  }
  void add_transpose(bool transpose) {
    fbb_.AddElement<uint8_t>(16, static_cast<uint8_t>(transpose), 0);
  }
  void add_quanParameter(flatbuffers::Offset<IDSTQuan> quanParameter) {
    fbb_.AddOffset(18, quanParameter);
  }
  explicit InnerProductBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InnerProductBuilder &operator=(const InnerProductBuilder &);
  flatbuffers::Offset<InnerProduct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InnerProduct>(end);
    return o;
  }
};

inline flatbuffers::Offset<InnerProduct> CreateInnerProduct(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    int32_t axis = 0,
    bool transpose = false,
    flatbuffers::Offset<IDSTQuan> quanParameter = 0) {
  InnerProductBuilder builder_(_fbb);
  builder_.add_quanParameter(quanParameter);
  builder_.add_axis(axis);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_weightSize(weightSize);
  builder_.add_biasTerm(biasTerm);
  builder_.add_outputCount(outputCount);
  builder_.add_transpose(transpose);
  return builder_.Finish();
}

flatbuffers::Offset<InnerProduct> CreateInnerProduct(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoolT : public flatbuffers::NativeTable {
  typedef Pool TableType;
  int32_t padX;
  int32_t padY;
  bool isGlobal;
  int32_t kernelX;
  int32_t kernelY;
  int32_t strideX;
  int32_t strideY;
  PoolType type;
  PoolPadType padType;
  DataType dataType;
  bool ceilModel;
  std::vector<int32_t> pads;
  AvgPoolCountType countType;
  PoolT()
      : padX(0),
        padY(0),
        isGlobal(false),
        kernelX(0),
        kernelY(0),
        strideX(0),
        strideY(0),
        type(PoolType_MAXPOOL),
        padType(PoolPadType_CAFFE),
        dataType(DataType_DT_FLOAT),
        ceilModel(true),
        countType(AvgPoolCountType_DEFAULT) {
  }
};

struct Pool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoolT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PoolTypeTable();
  }
  int32_t padX() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(6, 0);
  }
  bool isGlobal() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  int32_t kernelX() const {
    return GetField<int32_t>(10, 0);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(12, 0);
  }
  int32_t strideX() const {
    return GetField<int32_t>(14, 0);
  }
  int32_t strideY() const {
    return GetField<int32_t>(16, 0);
  }
  PoolType type() const {
    return static_cast<PoolType>(GetField<int8_t>(18, 0));
  }
  PoolPadType padType() const {
    return static_cast<PoolPadType>(GetField<int8_t>(20, 0));
  }
  DataType dataType() const {
    return static_cast<DataType>(GetField<int32_t>(22, 1));
  }
  bool ceilModel() const {
    return GetField<uint8_t>(24, 1) != 0;
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(26);
  }
  AvgPoolCountType countType() const {
    return static_cast<AvgPoolCountType>(GetField<int8_t>(28, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           VerifyField<int8_t>(verifier, 18) &&
           VerifyField<int8_t>(verifier, 20) &&
           VerifyField<int32_t>(verifier, 22) &&
           VerifyField<uint8_t>(verifier, 24) &&
           VerifyOffset(verifier, 26) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, 28) &&
           verifier.EndTable();
  }
  PoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(4, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(6, padY, 0);
  }
  void add_isGlobal(bool isGlobal) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(isGlobal), 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(10, kernelX, 0);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(12, kernelY, 0);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(14, strideX, 0);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(16, strideY, 0);
  }
  void add_type(PoolType type) {
    fbb_.AddElement<int8_t>(18, static_cast<int8_t>(type), 0);
  }
  void add_padType(PoolPadType padType) {
    fbb_.AddElement<int8_t>(20, static_cast<int8_t>(padType), 0);
  }
  void add_dataType(DataType dataType) {
    fbb_.AddElement<int32_t>(22, static_cast<int32_t>(dataType), 1);
  }
  void add_ceilModel(bool ceilModel) {
    fbb_.AddElement<uint8_t>(24, static_cast<uint8_t>(ceilModel), 1);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(26, pads);
  }
  void add_countType(AvgPoolCountType countType) {
    fbb_.AddElement<int8_t>(28, static_cast<int8_t>(countType), 0);
  }
  explicit PoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolBuilder &operator=(const PoolBuilder &);
  flatbuffers::Offset<Pool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool> CreatePool(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    bool isGlobal = false,
    int32_t kernelX = 0,
    int32_t kernelY = 0,
    int32_t strideX = 0,
    int32_t strideY = 0,
    PoolType type = PoolType_MAXPOOL,
    PoolPadType padType = PoolPadType_CAFFE,
    DataType dataType = DataType_DT_FLOAT,
    bool ceilModel = true,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    AvgPoolCountType countType = AvgPoolCountType_DEFAULT) {
  PoolBuilder builder_(_fbb);
  builder_.add_pads(pads);
  builder_.add_dataType(dataType);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_countType(countType);
  builder_.add_ceilModel(ceilModel);
  builder_.add_padType(padType);
  builder_.add_type(type);
  builder_.add_isGlobal(isGlobal);
  return builder_.Finish();
}

flatbuffers::Offset<Pool> CreatePool(flatbuffers::FlatBufferBuilder &_fbb, const PoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool3DT : public flatbuffers::NativeTable {
  typedef Pool3D TableType;
  std::vector<int32_t> strides;
  std::vector<int32_t> kernels;
  std::vector<int32_t> pads;
  PoolType type;
  PoolPadType padType;
  bool isGlobal;
  Pool3DT()
      : type(PoolType_MAXPOOL),
        padType(PoolPadType_CAFFE),
        isGlobal(false) {
  }
};

struct Pool3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pool3DT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pool3DTypeTable();
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  const flatbuffers::Vector<int32_t> *kernels() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  PoolType type() const {
    return static_cast<PoolType>(GetField<int8_t>(10, 0));
  }
  PoolPadType padType() const {
    return static_cast<PoolPadType>(GetField<int8_t>(12, 0));
  }
  bool isGlobal() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(kernels()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, 10) &&
           VerifyField<int8_t>(verifier, 12) &&
           VerifyField<uint8_t>(verifier, 14) &&
           verifier.EndTable();
  }
  Pool3DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool3DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool3D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool3DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(4, strides);
  }
  void add_kernels(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels) {
    fbb_.AddOffset(6, kernels);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(8, pads);
  }
  void add_type(PoolType type) {
    fbb_.AddElement<int8_t>(10, static_cast<int8_t>(type), 0);
  }
  void add_padType(PoolPadType padType) {
    fbb_.AddElement<int8_t>(12, static_cast<int8_t>(padType), 0);
  }
  void add_isGlobal(bool isGlobal) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(isGlobal), 0);
  }
  explicit Pool3DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Pool3DBuilder &operator=(const Pool3DBuilder &);
  flatbuffers::Offset<Pool3D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool3D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool3D> CreatePool3D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    PoolType type = PoolType_MAXPOOL,
    PoolPadType padType = PoolPadType_CAFFE,
    bool isGlobal = false) {
  Pool3DBuilder builder_(_fbb);
  builder_.add_pads(pads);
  builder_.add_kernels(kernels);
  builder_.add_strides(strides);
  builder_.add_isGlobal(isGlobal);
  builder_.add_padType(padType);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Pool3D> CreatePool3D(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReluT : public flatbuffers::NativeTable {
  typedef Relu TableType;
  float slope;
  ReluT()
      : slope(0.0f) {
  }
};

struct Relu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReluT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReluTypeTable();
  }
  float slope() const {
    return GetField<float>(4, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           verifier.EndTable();
  }
  ReluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Relu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slope(float slope) {
    fbb_.AddElement<float>(4, slope, 0.0f);
  }
  explicit ReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReluBuilder &operator=(const ReluBuilder &);
  flatbuffers::Offset<Relu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu> CreateRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float slope = 0.0f) {
  ReluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  return builder_.Finish();
}

flatbuffers::Offset<Relu> CreateRelu(flatbuffers::FlatBufferBuilder &_fbb, const ReluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Relu6T : public flatbuffers::NativeTable {
  typedef Relu6 TableType;
  float minValue;
  float maxValue;
  Relu6T()
      : minValue(0.0f),
        maxValue(6.0f) {
  }
};

struct Relu6 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Relu6T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Relu6TypeTable();
  }
  float minValue() const {
    return GetField<float>(4, 0.0f);
  }
  float maxValue() const {
    return GetField<float>(6, 6.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           verifier.EndTable();
  }
  Relu6T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Relu6T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Relu6> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Relu6Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minValue(float minValue) {
    fbb_.AddElement<float>(4, minValue, 0.0f);
  }
  void add_maxValue(float maxValue) {
    fbb_.AddElement<float>(6, maxValue, 6.0f);
  }
  explicit Relu6Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Relu6Builder &operator=(const Relu6Builder &);
  flatbuffers::Offset<Relu6> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu6>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu6> CreateRelu6(
    flatbuffers::FlatBufferBuilder &_fbb,
    float minValue = 0.0f,
    float maxValue = 6.0f) {
  Relu6Builder builder_(_fbb);
  builder_.add_maxValue(maxValue);
  builder_.add_minValue(minValue);
  return builder_.Finish();
}

flatbuffers::Offset<Relu6> CreateRelu6(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PReluT : public flatbuffers::NativeTable {
  typedef PRelu TableType;
  int32_t slopeCount;
  std::vector<float> slope;
  PReluT()
      : slopeCount(0) {
  }
};

struct PRelu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PReluT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PReluTypeTable();
  }
  int32_t slopeCount() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<float> *slope() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(slope()) &&
           verifier.EndTable();
  }
  PReluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PReluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PRelu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PReluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slopeCount(int32_t slopeCount) {
    fbb_.AddElement<int32_t>(4, slopeCount, 0);
  }
  void add_slope(flatbuffers::Offset<flatbuffers::Vector<float>> slope) {
    fbb_.AddOffset(6, slope);
  }
  explicit PReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PReluBuilder &operator=(const PReluBuilder &);
  flatbuffers::Offset<PRelu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PRelu>(end);
    return o;
  }
};

inline flatbuffers::Offset<PRelu> CreatePRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slopeCount = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slope = 0) {
  PReluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  builder_.add_slopeCount(slopeCount);
  return builder_.Finish();
}

flatbuffers::Offset<PRelu> CreatePRelu(flatbuffers::FlatBufferBuilder &_fbb, const PReluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ELUT : public flatbuffers::NativeTable {
  typedef ELU TableType;
  float alpha;
  ELUT()
      : alpha(0.0f) {
  }
};

struct ELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ELUT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ELUTypeTable();
  }
  float alpha() const {
    return GetField<float>(4, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           verifier.EndTable();
  }
  ELUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ELUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ELU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ELUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ELUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(4, alpha, 0.0f);
  }
  explicit ELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ELUBuilder &operator=(const ELUBuilder &);
  flatbuffers::Offset<ELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ELU>(end);
    return o;
  }
};

inline flatbuffers::Offset<ELU> CreateELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  ELUBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<ELU> CreateELU(flatbuffers::FlatBufferBuilder &_fbb, const ELUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LRNT : public flatbuffers::NativeTable {
  typedef LRN TableType;
  int32_t regionType;
  int32_t localSize;
  float alpha;
  float beta;
  float bias;
  LRNT()
      : regionType(0),
        localSize(0),
        alpha(0.0f),
        beta(0.0f),
        bias(1.0f) {
  }
};

struct LRN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LRNT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LRNTypeTable();
  }
  int32_t regionType() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t localSize() const {
    return GetField<int32_t>(6, 0);
  }
  float alpha() const {
    return GetField<float>(8, 0.0f);
  }
  float beta() const {
    return GetField<float>(10, 0.0f);
  }
  float bias() const {
    return GetField<float>(12, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyField<float>(verifier, 10) &&
           VerifyField<float>(verifier, 12) &&
           verifier.EndTable();
  }
  LRNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LRN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LRNBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_regionType(int32_t regionType) {
    fbb_.AddElement<int32_t>(4, regionType, 0);
  }
  void add_localSize(int32_t localSize) {
    fbb_.AddElement<int32_t>(6, localSize, 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(8, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(10, beta, 0.0f);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(12, bias, 1.0f);
  }
  explicit LRNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LRNBuilder &operator=(const LRNBuilder &);
  flatbuffers::Offset<LRN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LRN>(end);
    return o;
  }
};

inline flatbuffers::Offset<LRN> CreateLRN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t regionType = 0,
    int32_t localSize = 0,
    float alpha = 0.0f,
    float beta = 0.0f,
    float bias = 1.0f) {
  LRNBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_localSize(localSize);
  builder_.add_regionType(regionType);
  return builder_.Finish();
}

flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxT : public flatbuffers::NativeTable {
  typedef ArgMax TableType;
  int32_t outMaxVal;
  int32_t topK;
  int32_t axis;
  int32_t softmaxThreshold;
  ArgMaxT()
      : outMaxVal(0),
        topK(0),
        axis(0),
        softmaxThreshold(0) {
  }
};

struct ArgMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMaxTypeTable();
  }
  int32_t outMaxVal() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t topK() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t softmaxThreshold() const {
    return GetField<int32_t>(10, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           verifier.EndTable();
  }
  ArgMaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outMaxVal(int32_t outMaxVal) {
    fbb_.AddElement<int32_t>(4, outMaxVal, 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(6, topK, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(8, axis, 0);
  }
  void add_softmaxThreshold(int32_t softmaxThreshold) {
    fbb_.AddElement<int32_t>(10, softmaxThreshold, 0);
  }
  explicit ArgMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxBuilder &operator=(const ArgMaxBuilder &);
  flatbuffers::Offset<ArgMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMax> CreateArgMax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outMaxVal = 0,
    int32_t topK = 0,
    int32_t axis = 0,
    int32_t softmaxThreshold = 0) {
  ArgMaxBuilder builder_(_fbb);
  builder_.add_softmaxThreshold(softmaxThreshold);
  builder_.add_axis(axis);
  builder_.add_topK(topK);
  builder_.add_outMaxVal(outMaxVal);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMax> CreateArgMax(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AxisT : public flatbuffers::NativeTable {
  typedef Axis TableType;
  int32_t axis;
  AxisT()
      : axis(0) {
  }
};

struct Axis FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AxisT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AxisTypeTable();
  }
  int32_t axis() const {
    return GetField<int32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  AxisT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AxisT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Axis> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AxisT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AxisBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(4, axis, 0);
  }
  explicit AxisBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AxisBuilder &operator=(const AxisBuilder &);
  flatbuffers::Offset<Axis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Axis>(end);
    return o;
  }
};

inline flatbuffers::Offset<Axis> CreateAxis(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  AxisBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Axis> CreateAxis(flatbuffers::FlatBufferBuilder &_fbb, const AxisT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputT : public flatbuffers::NativeTable {
  typedef Input TableType;
  std::vector<int32_t> dims;
  DataType dtype;
  MNN_DATA_FORMAT dformat;
  InputT()
      : dtype(DataType_DT_FLOAT),
        dformat(MNN_DATA_FORMAT_NC4HW4) {
  }
};

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputTypeTable();
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  DataType dtype() const {
    return static_cast<DataType>(GetField<int32_t>(6, 1));
  }
  MNN_DATA_FORMAT dformat() const {
    return static_cast<MNN_DATA_FORMAT>(GetField<int8_t>(8, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  InputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Input> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(4, dims);
  }
  void add_dtype(DataType dtype) {
    fbb_.AddElement<int32_t>(6, static_cast<int32_t>(dtype), 1);
  }
  void add_dformat(MNN_DATA_FORMAT dformat) {
    fbb_.AddElement<int8_t>(8, static_cast<int8_t>(dformat), 2);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputBuilder &operator=(const InputBuilder &);
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    DataType dtype = DataType_DT_FLOAT,
    MNN_DATA_FORMAT dformat = MNN_DATA_FORMAT_NC4HW4) {
  InputBuilder builder_(_fbb);
  builder_.add_dtype(dtype);
  builder_.add_dims(dims);
  builder_.add_dformat(dformat);
  return builder_.Finish();
}

flatbuffers::Offset<Input> CreateInput(flatbuffers::FlatBufferBuilder &_fbb, const InputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMT : public flatbuffers::NativeTable {
  typedef LSTM TableType;
  int32_t outputCount;
  int32_t weightSize;
  float clippingThreshold;
  std::unique_ptr<BlobT> weightI;
  std::unique_ptr<BlobT> weightH;
  std::unique_ptr<BlobT> bias;
  std::unique_ptr<BlobT> weightIQ;
  std::unique_ptr<BlobT> weightIA;
  float quantScale;
  LSTMT()
      : outputCount(0),
        weightSize(0),
        clippingThreshold(0.0f),
        quantScale(0.0f) {
  }
};

struct LSTM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LSTMTypeTable();
  }
  int32_t outputCount() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(6, 0);
  }
  float clippingThreshold() const {
    return GetField<float>(8, 0.0f);
  }
  const Blob *weightI() const {
    return GetPointer<const Blob *>(10);
  }
  const Blob *weightH() const {
    return GetPointer<const Blob *>(12);
  }
  const Blob *bias() const {
    return GetPointer<const Blob *>(14);
  }
  const Blob *weightIQ() const {
    return GetPointer<const Blob *>(16);
  }
  const Blob *weightIA() const {
    return GetPointer<const Blob *>(18);
  }
  float quantScale() const {
    return GetField<float>(20, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyTable(weightI()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyTable(weightH()) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyTable(bias()) &&
           VerifyOffset(verifier, 16) &&
           verifier.VerifyTable(weightIQ()) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyTable(weightIA()) &&
           VerifyField<float>(verifier, 20) &&
           verifier.EndTable();
  }
  LSTMT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSTM> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(4, outputCount, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(6, weightSize, 0);
  }
  void add_clippingThreshold(float clippingThreshold) {
    fbb_.AddElement<float>(8, clippingThreshold, 0.0f);
  }
  void add_weightI(flatbuffers::Offset<Blob> weightI) {
    fbb_.AddOffset(10, weightI);
  }
  void add_weightH(flatbuffers::Offset<Blob> weightH) {
    fbb_.AddOffset(12, weightH);
  }
  void add_bias(flatbuffers::Offset<Blob> bias) {
    fbb_.AddOffset(14, bias);
  }
  void add_weightIQ(flatbuffers::Offset<Blob> weightIQ) {
    fbb_.AddOffset(16, weightIQ);
  }
  void add_weightIA(flatbuffers::Offset<Blob> weightIA) {
    fbb_.AddOffset(18, weightIA);
  }
  void add_quantScale(float quantScale) {
    fbb_.AddElement<float>(20, quantScale, 0.0f);
  }
  explicit LSTMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSTMBuilder &operator=(const LSTMBuilder &);
  flatbuffers::Offset<LSTM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTM>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTM> CreateLSTM(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t weightSize = 0,
    float clippingThreshold = 0.0f,
    flatbuffers::Offset<Blob> weightI = 0,
    flatbuffers::Offset<Blob> weightH = 0,
    flatbuffers::Offset<Blob> bias = 0,
    flatbuffers::Offset<Blob> weightIQ = 0,
    flatbuffers::Offset<Blob> weightIA = 0,
    float quantScale = 0.0f) {
  LSTMBuilder builder_(_fbb);
  builder_.add_quantScale(quantScale);
  builder_.add_weightIA(weightIA);
  builder_.add_weightIQ(weightIQ);
  builder_.add_bias(bias);
  builder_.add_weightH(weightH);
  builder_.add_weightI(weightI);
  builder_.add_clippingThreshold(clippingThreshold);
  builder_.add_weightSize(weightSize);
  builder_.add_outputCount(outputCount);
  return builder_.Finish();
}

flatbuffers::Offset<LSTM> CreateLSTM(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceT : public flatbuffers::NativeTable {
  typedef Slice TableType;
  int32_t axis;
  std::vector<int32_t> slicePoints;
  NetSource sourceType;
  SliceT()
      : axis(0),
        sourceType(NetSource_CAFFE) {
  }
};

struct Slice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SliceTypeTable();
  }
  int32_t axis() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<int32_t> *slicePoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  NetSource sourceType() const {
    return static_cast<NetSource>(GetField<int8_t>(8, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(slicePoints()) &&
           VerifyField<int8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  SliceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Slice> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(4, axis, 0);
  }
  void add_slicePoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> slicePoints) {
    fbb_.AddOffset(6, slicePoints);
  }
  void add_sourceType(NetSource sourceType) {
    fbb_.AddElement<int8_t>(8, static_cast<int8_t>(sourceType), 0);
  }
  explicit SliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceBuilder &operator=(const SliceBuilder &);
  flatbuffers::Offset<Slice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Slice>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slice> CreateSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> slicePoints = 0,
    NetSource sourceType = NetSource_CAFFE) {
  SliceBuilder builder_(_fbb);
  builder_.add_slicePoints(slicePoints);
  builder_.add_axis(axis);
  builder_.add_sourceType(sourceType);
  return builder_.Finish();
}

flatbuffers::Offset<Slice> CreateSlice(flatbuffers::FlatBufferBuilder &_fbb, const SliceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchNormT : public flatbuffers::NativeTable {
  typedef BatchNorm TableType;
  int32_t channels;
  std::vector<float> slopeData;
  std::vector<float> meanData;
  std::vector<float> varData;
  std::vector<float> biasData;
  std::vector<float> Adata;
  std::vector<float> Bdata;
  float epsilon;
  BatchNormT()
      : channels(0),
        epsilon(0.001f) {
  }
};

struct BatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchNormTypeTable();
  }
  int32_t channels() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<float> *slopeData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  const flatbuffers::Vector<float> *meanData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  const flatbuffers::Vector<float> *varData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  const flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(12);
  }
  const flatbuffers::Vector<float> *Adata() const {
    return GetPointer<const flatbuffers::Vector<float> *>(14);
  }
  const flatbuffers::Vector<float> *Bdata() const {
    return GetPointer<const flatbuffers::Vector<float> *>(16);
  }
  float epsilon() const {
    return GetField<float>(18, 0.001f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(slopeData()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(meanData()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(varData()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(biasData()) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyVector(Adata()) &&
           VerifyOffset(verifier, 16) &&
           verifier.VerifyVector(Bdata()) &&
           VerifyField<float>(verifier, 18) &&
           verifier.EndTable();
  }
  BatchNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchNormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(4, channels, 0);
  }
  void add_slopeData(flatbuffers::Offset<flatbuffers::Vector<float>> slopeData) {
    fbb_.AddOffset(6, slopeData);
  }
  void add_meanData(flatbuffers::Offset<flatbuffers::Vector<float>> meanData) {
    fbb_.AddOffset(8, meanData);
  }
  void add_varData(flatbuffers::Offset<flatbuffers::Vector<float>> varData) {
    fbb_.AddOffset(10, varData);
  }
  void add_biasData(flatbuffers::Offset<flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(12, biasData);
  }
  void add_Adata(flatbuffers::Offset<flatbuffers::Vector<float>> Adata) {
    fbb_.AddOffset(14, Adata);
  }
  void add_Bdata(flatbuffers::Offset<flatbuffers::Vector<float>> Bdata) {
    fbb_.AddOffset(16, Bdata);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(18, epsilon, 0.001f);
  }
  explicit BatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchNormBuilder &operator=(const BatchNormBuilder &);
  flatbuffers::Offset<BatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slopeData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> meanData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> varData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> biasData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Adata = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Bdata = 0,
    float epsilon = 0.001f) {
  BatchNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_Bdata(Bdata);
  builder_.add_Adata(Adata);
  builder_.add_biasData(biasData);
  builder_.add_varData(varData);
  builder_.add_meanData(meanData);
  builder_.add_slopeData(slopeData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScaleT : public flatbuffers::NativeTable {
  typedef Scale TableType;
  int32_t channels;
  std::vector<float> scaleData;
  std::vector<float> biasData;
  std::vector<int64_t> external;
  ScaleT()
      : channels(0) {
  }
};

struct Scale FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScaleT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScaleTypeTable();
  }
  int32_t channels() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<float> *scaleData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  const flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  const flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(10);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(scaleData()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(biasData()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
  ScaleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScaleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Scale> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScaleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(4, channels, 0);
  }
  void add_scaleData(flatbuffers::Offset<flatbuffers::Vector<float>> scaleData) {
    fbb_.AddOffset(6, scaleData);
  }
  void add_biasData(flatbuffers::Offset<flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(8, biasData);
  }
  void add_external(flatbuffers::Offset<flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(10, external);
  }
  explicit ScaleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScaleBuilder &operator=(const ScaleBuilder &);
  flatbuffers::Offset<Scale> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scale>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scale> CreateScale(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scaleData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> biasData = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> external = 0) {
  ScaleBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_biasData(biasData);
  builder_.add_scaleData(scaleData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

flatbuffers::Offset<Scale> CreateScale(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EltwiseT : public flatbuffers::NativeTable {
  typedef Eltwise TableType;
  EltwiseType type;
  std::vector<float> coeff;
  EltwiseT()
      : type(EltwiseType_PROD) {
  }
};

struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EltwiseTypeTable();
  }
  EltwiseType type() const {
    return static_cast<EltwiseType>(GetField<int8_t>(4, 0));
  }
  const flatbuffers::Vector<float> *coeff() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(coeff()) &&
           verifier.EndTable();
  }
  EltwiseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Eltwise> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EltwiseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(EltwiseType type) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(type), 0);
  }
  void add_coeff(flatbuffers::Offset<flatbuffers::Vector<float>> coeff) {
    fbb_.AddOffset(6, coeff);
  }
  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EltwiseBuilder &operator=(const EltwiseBuilder &);
  flatbuffers::Offset<Eltwise> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Eltwise>(end);
    return o;
  }
};

inline flatbuffers::Offset<Eltwise> CreateEltwise(
    flatbuffers::FlatBufferBuilder &_fbb,
    EltwiseType type = EltwiseType_PROD,
    flatbuffers::Offset<flatbuffers::Vector<float>> coeff = 0) {
  EltwiseBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenT : public flatbuffers::NativeTable {
  typedef Flatten TableType;
  int32_t axis;
  int32_t endAxis;
  FlattenT()
      : axis(0),
        endAxis(0) {
  }
};

struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlattenTypeTable();
  }
  int32_t axis() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t endAxis() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  FlattenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Flatten> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(4, axis, 0);
  }
  void add_endAxis(int32_t endAxis) {
    fbb_.AddElement<int32_t>(6, endAxis, 0);
  }
  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlattenBuilder &operator=(const FlattenBuilder &);
  flatbuffers::Offset<Flatten> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Flatten>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flatten> CreateFlatten(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t endAxis = 0) {
  FlattenBuilder builder_(_fbb);
  builder_.add_endAxis(endAxis);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PermuteT : public flatbuffers::NativeTable {
  typedef Permute TableType;
  std::vector<int32_t> dims;
  PermuteT() {
  }
};

struct Permute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PermuteT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PermuteTypeTable();
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  PermuteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PermuteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Permute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PermuteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(4, dims);
  }
  explicit PermuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PermuteBuilder &operator=(const PermuteBuilder &);
  flatbuffers::Offset<Permute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Permute>(end);
    return o;
  }
};

inline flatbuffers::Offset<Permute> CreatePermute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  PermuteBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

flatbuffers::Offset<Permute> CreatePermute(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeT : public flatbuffers::NativeTable {
  typedef Reshape TableType;
  std::vector<int32_t> dims;
  MNN_DATA_FORMAT dimType;
  ReshapeT()
      : dimType(MNN_DATA_FORMAT_NCHW) {
  }
};

struct Reshape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReshapeTypeTable();
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  MNN_DATA_FORMAT dimType() const {
    return static_cast<MNN_DATA_FORMAT>(GetField<int8_t>(6, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  ReshapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reshape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(4, dims);
  }
  void add_dimType(MNN_DATA_FORMAT dimType) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(dimType), 0);
  }
  explicit ReshapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeBuilder &operator=(const ReshapeBuilder &);
  flatbuffers::Offset<Reshape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reshape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reshape> CreateReshape(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    MNN_DATA_FORMAT dimType = MNN_DATA_FORMAT_NCHW) {
  ReshapeBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_dimType(dimType);
  return builder_.Finish();
}

flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionOutputT : public flatbuffers::NativeTable {
  typedef DetectionOutput TableType;
  int32_t classCount;
  float nmsThresholdold;
  int32_t nmsTopK;
  int32_t keepTopK;
  float confidenceThreshold;
  int32_t shareLocation;
  int32_t backgroundLable;
  int32_t varianceEncodedTarget;
  int32_t codeType;
  float objectnessScore;
  DetectionOutputT()
      : classCount(0),
        nmsThresholdold(0.0f),
        nmsTopK(0),
        keepTopK(0),
        confidenceThreshold(0.0f),
        shareLocation(0),
        backgroundLable(0),
        varianceEncodedTarget(0),
        codeType(0),
        objectnessScore(0.01f) {
  }
};

struct DetectionOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionOutputT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DetectionOutputTypeTable();
  }
  int32_t classCount() const {
    return GetField<int32_t>(4, 0);
  }
  float nmsThresholdold() const {
    return GetField<float>(6, 0.0f);
  }
  int32_t nmsTopK() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t keepTopK() const {
    return GetField<int32_t>(10, 0);
  }
  float confidenceThreshold() const {
    return GetField<float>(12, 0.0f);
  }
  int32_t shareLocation() const {
    return GetField<int32_t>(14, 0);
  }
  int32_t backgroundLable() const {
    return GetField<int32_t>(16, 0);
  }
  int32_t varianceEncodedTarget() const {
    return GetField<int32_t>(18, 0);
  }
  int32_t codeType() const {
    return GetField<int32_t>(20, 0);
  }
  float objectnessScore() const {
    return GetField<float>(22, 0.01f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<float>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           VerifyField<int32_t>(verifier, 18) &&
           VerifyField<int32_t>(verifier, 20) &&
           VerifyField<float>(verifier, 22) &&
           verifier.EndTable();
  }
  DetectionOutputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionOutputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectionOutput> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionOutputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classCount(int32_t classCount) {
    fbb_.AddElement<int32_t>(4, classCount, 0);
  }
  void add_nmsThresholdold(float nmsThresholdold) {
    fbb_.AddElement<float>(6, nmsThresholdold, 0.0f);
  }
  void add_nmsTopK(int32_t nmsTopK) {
    fbb_.AddElement<int32_t>(8, nmsTopK, 0);
  }
  void add_keepTopK(int32_t keepTopK) {
    fbb_.AddElement<int32_t>(10, keepTopK, 0);
  }
  void add_confidenceThreshold(float confidenceThreshold) {
    fbb_.AddElement<float>(12, confidenceThreshold, 0.0f);
  }
  void add_shareLocation(int32_t shareLocation) {
    fbb_.AddElement<int32_t>(14, shareLocation, 0);
  }
  void add_backgroundLable(int32_t backgroundLable) {
    fbb_.AddElement<int32_t>(16, backgroundLable, 0);
  }
  void add_varianceEncodedTarget(int32_t varianceEncodedTarget) {
    fbb_.AddElement<int32_t>(18, varianceEncodedTarget, 0);
  }
  void add_codeType(int32_t codeType) {
    fbb_.AddElement<int32_t>(20, codeType, 0);
  }
  void add_objectnessScore(float objectnessScore) {
    fbb_.AddElement<float>(22, objectnessScore, 0.01f);
  }
  explicit DetectionOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DetectionOutputBuilder &operator=(const DetectionOutputBuilder &);
  flatbuffers::Offset<DetectionOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionOutput>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionOutput> CreateDetectionOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t classCount = 0,
    float nmsThresholdold = 0.0f,
    int32_t nmsTopK = 0,
    int32_t keepTopK = 0,
    float confidenceThreshold = 0.0f,
    int32_t shareLocation = 0,
    int32_t backgroundLable = 0,
    int32_t varianceEncodedTarget = 0,
    int32_t codeType = 0,
    float objectnessScore = 0.01f) {
  DetectionOutputBuilder builder_(_fbb);
  builder_.add_objectnessScore(objectnessScore);
  builder_.add_codeType(codeType);
  builder_.add_varianceEncodedTarget(varianceEncodedTarget);
  builder_.add_backgroundLable(backgroundLable);
  builder_.add_shareLocation(shareLocation);
  builder_.add_confidenceThreshold(confidenceThreshold);
  builder_.add_keepTopK(keepTopK);
  builder_.add_nmsTopK(nmsTopK);
  builder_.add_nmsThresholdold(nmsThresholdold);
  builder_.add_classCount(classCount);
  return builder_.Finish();
}

flatbuffers::Offset<DetectionOutput> CreateDetectionOutput(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoiParametersT : public flatbuffers::NativeTable {
  typedef RoiParameters TableType;
  int32_t pooledWidth;
  int32_t pooledHeight;
  float spatialScale;
  int32_t samplingRatio;
  bool aligned;
  PoolType poolType;
  bool outputGrad;
  RoiParametersT()
      : pooledWidth(0),
        pooledHeight(0),
        spatialScale(0.0f),
        samplingRatio(-1),
        aligned(false),
        poolType(PoolType_AVEPOOL),
        outputGrad(false) {
  }
};

struct RoiParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoiParametersT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RoiParametersTypeTable();
  }
  int32_t pooledWidth() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t pooledHeight() const {
    return GetField<int32_t>(6, 0);
  }
  float spatialScale() const {
    return GetField<float>(8, 0.0f);
  }
  int32_t samplingRatio() const {
    return GetField<int32_t>(10, -1);
  }
  bool aligned() const {
    return GetField<uint8_t>(12, 0) != 0;
  }
  PoolType poolType() const {
    return static_cast<PoolType>(GetField<int8_t>(14, 1));
  }
  bool outputGrad() const {
    return GetField<uint8_t>(16, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<uint8_t>(verifier, 12) &&
           VerifyField<int8_t>(verifier, 14) &&
           VerifyField<uint8_t>(verifier, 16) &&
           verifier.EndTable();
  }
  RoiParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoiParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoiParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoiParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoiParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pooledWidth(int32_t pooledWidth) {
    fbb_.AddElement<int32_t>(4, pooledWidth, 0);
  }
  void add_pooledHeight(int32_t pooledHeight) {
    fbb_.AddElement<int32_t>(6, pooledHeight, 0);
  }
  void add_spatialScale(float spatialScale) {
    fbb_.AddElement<float>(8, spatialScale, 0.0f);
  }
  void add_samplingRatio(int32_t samplingRatio) {
    fbb_.AddElement<int32_t>(10, samplingRatio, -1);
  }
  void add_aligned(bool aligned) {
    fbb_.AddElement<uint8_t>(12, static_cast<uint8_t>(aligned), 0);
  }
  void add_poolType(PoolType poolType) {
    fbb_.AddElement<int8_t>(14, static_cast<int8_t>(poolType), 1);
  }
  void add_outputGrad(bool outputGrad) {
    fbb_.AddElement<uint8_t>(16, static_cast<uint8_t>(outputGrad), 0);
  }
  explicit RoiParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RoiParametersBuilder &operator=(const RoiParametersBuilder &);
  flatbuffers::Offset<RoiParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoiParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoiParameters> CreateRoiParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pooledWidth = 0,
    int32_t pooledHeight = 0,
    float spatialScale = 0.0f,
    int32_t samplingRatio = -1,
    bool aligned = false,
    PoolType poolType = PoolType_AVEPOOL,
    bool outputGrad = false) {
  RoiParametersBuilder builder_(_fbb);
  builder_.add_samplingRatio(samplingRatio);
  builder_.add_spatialScale(spatialScale);
  builder_.add_pooledHeight(pooledHeight);
  builder_.add_pooledWidth(pooledWidth);
  builder_.add_outputGrad(outputGrad);
  builder_.add_poolType(poolType);
  builder_.add_aligned(aligned);
  return builder_.Finish();
}

flatbuffers::Offset<RoiParameters> CreateRoiParameters(flatbuffers::FlatBufferBuilder &_fbb, const RoiParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProposalT : public flatbuffers::NativeTable {
  typedef Proposal TableType;
  int32_t featStride;
  int32_t baseSize;
  int32_t preNmsTopN;
  int32_t afterNmsTopN;
  float nmsThreshold;
  int32_t minSize;
  std::unique_ptr<BlobT> ratios;
  std::unique_ptr<BlobT> scales;
  std::unique_ptr<BlobT> anchors;
  ProposalT()
      : featStride(0),
        baseSize(0),
        preNmsTopN(0),
        afterNmsTopN(0),
        nmsThreshold(0.0f),
        minSize(0) {
  }
};

struct Proposal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProposalT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProposalTypeTable();
  }
  int32_t featStride() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t baseSize() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t preNmsTopN() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t afterNmsTopN() const {
    return GetField<int32_t>(10, 0);
  }
  float nmsThreshold() const {
    return GetField<float>(12, 0.0f);
  }
  int32_t minSize() const {
    return GetField<int32_t>(14, 0);
  }
  const Blob *ratios() const {
    return GetPointer<const Blob *>(16);
  }
  const Blob *scales() const {
    return GetPointer<const Blob *>(18);
  }
  const Blob *anchors() const {
    return GetPointer<const Blob *>(20);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<float>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyOffset(verifier, 16) &&
           verifier.VerifyTable(ratios()) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyTable(scales()) &&
           VerifyOffset(verifier, 20) &&
           verifier.VerifyTable(anchors()) &&
           verifier.EndTable();
  }
  ProposalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProposalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Proposal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProposalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_featStride(int32_t featStride) {
    fbb_.AddElement<int32_t>(4, featStride, 0);
  }
  void add_baseSize(int32_t baseSize) {
    fbb_.AddElement<int32_t>(6, baseSize, 0);
  }
  void add_preNmsTopN(int32_t preNmsTopN) {
    fbb_.AddElement<int32_t>(8, preNmsTopN, 0);
  }
  void add_afterNmsTopN(int32_t afterNmsTopN) {
    fbb_.AddElement<int32_t>(10, afterNmsTopN, 0);
  }
  void add_nmsThreshold(float nmsThreshold) {
    fbb_.AddElement<float>(12, nmsThreshold, 0.0f);
  }
  void add_minSize(int32_t minSize) {
    fbb_.AddElement<int32_t>(14, minSize, 0);
  }
  void add_ratios(flatbuffers::Offset<Blob> ratios) {
    fbb_.AddOffset(16, ratios);
  }
  void add_scales(flatbuffers::Offset<Blob> scales) {
    fbb_.AddOffset(18, scales);
  }
  void add_anchors(flatbuffers::Offset<Blob> anchors) {
    fbb_.AddOffset(20, anchors);
  }
  explicit ProposalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalBuilder &operator=(const ProposalBuilder &);
  flatbuffers::Offset<Proposal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Proposal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Proposal> CreateProposal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t featStride = 0,
    int32_t baseSize = 0,
    int32_t preNmsTopN = 0,
    int32_t afterNmsTopN = 0,
    float nmsThreshold = 0.0f,
    int32_t minSize = 0,
    flatbuffers::Offset<Blob> ratios = 0,
    flatbuffers::Offset<Blob> scales = 0,
    flatbuffers::Offset<Blob> anchors = 0) {
  ProposalBuilder builder_(_fbb);
  builder_.add_anchors(anchors);
  builder_.add_scales(scales);
  builder_.add_ratios(ratios);
  builder_.add_minSize(minSize);
  builder_.add_nmsThreshold(nmsThreshold);
  builder_.add_afterNmsTopN(afterNmsTopN);
  builder_.add_preNmsTopN(preNmsTopN);
  builder_.add_baseSize(baseSize);
  builder_.add_featStride(featStride);
  return builder_.Finish();
}

flatbuffers::Offset<Proposal> CreateProposal(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InterpT : public flatbuffers::NativeTable {
  typedef Interp TableType;
  float widthScale;
  float heightScale;
  int32_t outputWidth;
  int32_t outputHeight;
  int32_t resizeType;
  bool alignCorners;
  bool halfPixelCenters;
  float widthOffset;
  float heightOffset;
  float cubicCoeffA;
  CoordinateTransformationMode ctm;
  float depthScale;
  int32_t outputDepth;
  float depthOffset;
  InterpT()
      : widthScale(0.0f),
        heightScale(0.0f),
        outputWidth(0),
        outputHeight(0),
        resizeType(0),
        alignCorners(false),
        halfPixelCenters(false),
        widthOffset(0.0f),
        heightOffset(0.0f),
        cubicCoeffA(-0.75f),
        ctm(CoordinateTransformationMode_NotSet),
        depthScale(0.0f),
        outputDepth(0),
        depthOffset(0.0f) {
  }
};

struct Interp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InterpT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InterpTypeTable();
  }
  float widthScale() const {
    return GetField<float>(4, 0.0f);
  }
  float heightScale() const {
    return GetField<float>(6, 0.0f);
  }
  int32_t outputWidth() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t outputHeight() const {
    return GetField<int32_t>(10, 0);
  }
  int32_t resizeType() const {
    return GetField<int32_t>(12, 0);
  }
  bool alignCorners() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  bool halfPixelCenters() const {
    return GetField<uint8_t>(16, 0) != 0;
  }
  float widthOffset() const {
    return GetField<float>(18, 0.0f);
  }
  float heightOffset() const {
    return GetField<float>(20, 0.0f);
  }
  float cubicCoeffA() const {
    return GetField<float>(22, -0.75f);
  }
  CoordinateTransformationMode ctm() const {
    return static_cast<CoordinateTransformationMode>(GetField<int8_t>(24, 0));
  }
  float depthScale() const {
    return GetField<float>(26, 0.0f);
  }
  int32_t outputDepth() const {
    return GetField<int32_t>(28, 0);
  }
  float depthOffset() const {
    return GetField<float>(30, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyField<uint8_t>(verifier, 14) &&
           VerifyField<uint8_t>(verifier, 16) &&
           VerifyField<float>(verifier, 18) &&
           VerifyField<float>(verifier, 20) &&
           VerifyField<float>(verifier, 22) &&
           VerifyField<int8_t>(verifier, 24) &&
           VerifyField<float>(verifier, 26) &&
           VerifyField<int32_t>(verifier, 28) &&
           VerifyField<float>(verifier, 30) &&
           verifier.EndTable();
  }
  InterpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InterpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Interp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InterpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_widthScale(float widthScale) {
    fbb_.AddElement<float>(4, widthScale, 0.0f);
  }
  void add_heightScale(float heightScale) {
    fbb_.AddElement<float>(6, heightScale, 0.0f);
  }
  void add_outputWidth(int32_t outputWidth) {
    fbb_.AddElement<int32_t>(8, outputWidth, 0);
  }
  void add_outputHeight(int32_t outputHeight) {
    fbb_.AddElement<int32_t>(10, outputHeight, 0);
  }
  void add_resizeType(int32_t resizeType) {
    fbb_.AddElement<int32_t>(12, resizeType, 0);
  }
  void add_alignCorners(bool alignCorners) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(alignCorners), 0);
  }
  void add_halfPixelCenters(bool halfPixelCenters) {
    fbb_.AddElement<uint8_t>(16, static_cast<uint8_t>(halfPixelCenters), 0);
  }
  void add_widthOffset(float widthOffset) {
    fbb_.AddElement<float>(18, widthOffset, 0.0f);
  }
  void add_heightOffset(float heightOffset) {
    fbb_.AddElement<float>(20, heightOffset, 0.0f);
  }
  void add_cubicCoeffA(float cubicCoeffA) {
    fbb_.AddElement<float>(22, cubicCoeffA, -0.75f);
  }
  void add_ctm(CoordinateTransformationMode ctm) {
    fbb_.AddElement<int8_t>(24, static_cast<int8_t>(ctm), 0);
  }
  void add_depthScale(float depthScale) {
    fbb_.AddElement<float>(26, depthScale, 0.0f);
  }
  void add_outputDepth(int32_t outputDepth) {
    fbb_.AddElement<int32_t>(28, outputDepth, 0);
  }
  void add_depthOffset(float depthOffset) {
    fbb_.AddElement<float>(30, depthOffset, 0.0f);
  }
  explicit InterpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InterpBuilder &operator=(const InterpBuilder &);
  flatbuffers::Offset<Interp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Interp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Interp> CreateInterp(
    flatbuffers::FlatBufferBuilder &_fbb,
    float widthScale = 0.0f,
    float heightScale = 0.0f,
    int32_t outputWidth = 0,
    int32_t outputHeight = 0,
    int32_t resizeType = 0,
    bool alignCorners = false,
    bool halfPixelCenters = false,
    float widthOffset = 0.0f,
    float heightOffset = 0.0f,
    float cubicCoeffA = -0.75f,
    CoordinateTransformationMode ctm = CoordinateTransformationMode_NotSet,
    float depthScale = 0.0f,
    int32_t outputDepth = 0,
    float depthOffset = 0.0f) {
  InterpBuilder builder_(_fbb);
  builder_.add_depthOffset(depthOffset);
  builder_.add_outputDepth(outputDepth);
  builder_.add_depthScale(depthScale);
  builder_.add_cubicCoeffA(cubicCoeffA);
  builder_.add_heightOffset(heightOffset);
  builder_.add_widthOffset(widthOffset);
  builder_.add_resizeType(resizeType);
  builder_.add_outputHeight(outputHeight);
  builder_.add_outputWidth(outputWidth);
  builder_.add_heightScale(heightScale);
  builder_.add_widthScale(widthScale);
  builder_.add_ctm(ctm);
  builder_.add_halfPixelCenters(halfPixelCenters);
  builder_.add_alignCorners(alignCorners);
  return builder_.Finish();
}

flatbuffers::Offset<Interp> CreateInterp(flatbuffers::FlatBufferBuilder &_fbb, const InterpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeT : public flatbuffers::NativeTable {
  typedef Resize TableType;
  float xScale;
  float yScale;
  ResizeT()
      : xScale(0.0f),
        yScale(0.0f) {
  }
};

struct Resize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResizeTypeTable();
  }
  float xScale() const {
    return GetField<float>(4, 0.0f);
  }
  float yScale() const {
    return GetField<float>(6, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           verifier.EndTable();
  }
  ResizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Resize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_xScale(float xScale) {
    fbb_.AddElement<float>(4, xScale, 0.0f);
  }
  void add_yScale(float yScale) {
    fbb_.AddElement<float>(6, yScale, 0.0f);
  }
  explicit ResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeBuilder &operator=(const ResizeBuilder &);
  flatbuffers::Offset<Resize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resize> CreateResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    float xScale = 0.0f,
    float yScale = 0.0f) {
  ResizeBuilder builder_(_fbb);
  builder_.add_yScale(yScale);
  builder_.add_xScale(xScale);
  return builder_.Finish();
}

flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PriorBoxT : public flatbuffers::NativeTable {
  typedef PriorBox TableType;
  std::vector<float> minSizes;
  std::vector<float> maxSizes;
  std::vector<float> aspectRatios;
  std::vector<float> variances;
  bool flip;
  bool clip;
  int32_t imageWidth;
  int32_t imageHeight;
  int32_t stepWidth;
  int32_t stepHeight;
  float offset;
  PriorBoxT()
      : flip(false),
        clip(false),
        imageWidth(0),
        imageHeight(0),
        stepWidth(0),
        stepHeight(0),
        offset(0.0f) {
  }
};

struct PriorBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PriorBoxT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PriorBoxTypeTable();
  }
  const flatbuffers::Vector<float> *minSizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(4);
  }
  const flatbuffers::Vector<float> *maxSizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  const flatbuffers::Vector<float> *aspectRatios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  bool flip() const {
    return GetField<uint8_t>(12, 0) != 0;
  }
  bool clip() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  int32_t imageWidth() const {
    return GetField<int32_t>(16, 0);
  }
  int32_t imageHeight() const {
    return GetField<int32_t>(18, 0);
  }
  int32_t stepWidth() const {
    return GetField<int32_t>(20, 0);
  }
  int32_t stepHeight() const {
    return GetField<int32_t>(22, 0);
  }
  float offset() const {
    return GetField<float>(24, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(minSizes()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(maxSizes()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(aspectRatios()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<uint8_t>(verifier, 12) &&
           VerifyField<uint8_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           VerifyField<int32_t>(verifier, 18) &&
           VerifyField<int32_t>(verifier, 20) &&
           VerifyField<int32_t>(verifier, 22) &&
           VerifyField<float>(verifier, 24) &&
           verifier.EndTable();
  }
  PriorBoxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PriorBox> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriorBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minSizes(flatbuffers::Offset<flatbuffers::Vector<float>> minSizes) {
    fbb_.AddOffset(4, minSizes);
  }
  void add_maxSizes(flatbuffers::Offset<flatbuffers::Vector<float>> maxSizes) {
    fbb_.AddOffset(6, maxSizes);
  }
  void add_aspectRatios(flatbuffers::Offset<flatbuffers::Vector<float>> aspectRatios) {
    fbb_.AddOffset(8, aspectRatios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(10, variances);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(12, static_cast<uint8_t>(flip), 0);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(clip), 0);
  }
  void add_imageWidth(int32_t imageWidth) {
    fbb_.AddElement<int32_t>(16, imageWidth, 0);
  }
  void add_imageHeight(int32_t imageHeight) {
    fbb_.AddElement<int32_t>(18, imageHeight, 0);
  }
  void add_stepWidth(int32_t stepWidth) {
    fbb_.AddElement<int32_t>(20, stepWidth, 0);
  }
  void add_stepHeight(int32_t stepHeight) {
    fbb_.AddElement<int32_t>(22, stepHeight, 0);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(24, offset, 0.0f);
  }
  explicit PriorBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PriorBoxBuilder &operator=(const PriorBoxBuilder &);
  flatbuffers::Offset<PriorBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorBox> CreatePriorBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> minSizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> maxSizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspectRatios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    bool flip = false,
    bool clip = false,
    int32_t imageWidth = 0,
    int32_t imageHeight = 0,
    int32_t stepWidth = 0,
    int32_t stepHeight = 0,
    float offset = 0.0f) {
  PriorBoxBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_stepHeight(stepHeight);
  builder_.add_stepWidth(stepWidth);
  builder_.add_imageHeight(imageHeight);
  builder_.add_imageWidth(imageWidth);
  builder_.add_variances(variances);
  builder_.add_aspectRatios(aspectRatios);
  builder_.add_maxSizes(maxSizes);
  builder_.add_minSizes(minSizes);
  builder_.add_clip(clip);
  builder_.add_flip(flip);
  return builder_.Finish();
}

flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NormalizeT : public flatbuffers::NativeTable {
  typedef Normalize TableType;
  int32_t acrossSpatial;
  int32_t channelShared;
  float eps;
  std::vector<float> scale;
  NormalizeT()
      : acrossSpatial(0),
        channelShared(0),
        eps(0.0f) {
  }
};

struct Normalize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormalizeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NormalizeTypeTable();
  }
  int32_t acrossSpatial() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t channelShared() const {
    return GetField<int32_t>(6, 0);
  }
  float eps() const {
    return GetField<float>(8, 0.0f);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(scale()) &&
           verifier.EndTable();
  }
  NormalizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NormalizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Normalize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NormalizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acrossSpatial(int32_t acrossSpatial) {
    fbb_.AddElement<int32_t>(4, acrossSpatial, 0);
  }
  void add_channelShared(int32_t channelShared) {
    fbb_.AddElement<int32_t>(6, channelShared, 0);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(8, eps, 0.0f);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(10, scale);
  }
  explicit NormalizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NormalizeBuilder &operator=(const NormalizeBuilder &);
  flatbuffers::Offset<Normalize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Normalize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Normalize> CreateNormalize(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t acrossSpatial = 0,
    int32_t channelShared = 0,
    float eps = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0) {
  NormalizeBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_eps(eps);
  builder_.add_channelShared(channelShared);
  builder_.add_acrossSpatial(acrossSpatial);
  return builder_.Finish();
}

flatbuffers::Offset<Normalize> CreateNormalize(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EltwiseInt8T : public flatbuffers::NativeTable {
  typedef EltwiseInt8 TableType;
  EltwiseType type;
  std::unique_ptr<QuantizedFloatParamT> inputQuan0;
  std::unique_ptr<QuantizedFloatParamT> inputQuan1;
  std::unique_ptr<QuantizedFloatParamT> outputQuan;
  EltwiseInt8T()
      : type(EltwiseType_PROD) {
  }
};

struct EltwiseInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseInt8T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EltwiseInt8TypeTable();
  }
  EltwiseType type() const {
    return static_cast<EltwiseType>(GetField<int8_t>(4, 0));
  }
  const QuantizedFloatParam *inputQuan0() const {
    return GetPointer<const QuantizedFloatParam *>(6);
  }
  const QuantizedFloatParam *inputQuan1() const {
    return GetPointer<const QuantizedFloatParam *>(8);
  }
  const QuantizedFloatParam *outputQuan() const {
    return GetPointer<const QuantizedFloatParam *>(10);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyTable(inputQuan0()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyTable(inputQuan1()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyTable(outputQuan()) &&
           verifier.EndTable();
  }
  EltwiseInt8T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EltwiseInt8T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EltwiseInt8> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EltwiseInt8Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(EltwiseType type) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(type), 0);
  }
  void add_inputQuan0(flatbuffers::Offset<QuantizedFloatParam> inputQuan0) {
    fbb_.AddOffset(6, inputQuan0);
  }
  void add_inputQuan1(flatbuffers::Offset<QuantizedFloatParam> inputQuan1) {
    fbb_.AddOffset(8, inputQuan1);
  }
  void add_outputQuan(flatbuffers::Offset<QuantizedFloatParam> outputQuan) {
    fbb_.AddOffset(10, outputQuan);
  }
  explicit EltwiseInt8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EltwiseInt8Builder &operator=(const EltwiseInt8Builder &);
  flatbuffers::Offset<EltwiseInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EltwiseInt8>(end);
    return o;
  }
};

inline flatbuffers::Offset<EltwiseInt8> CreateEltwiseInt8(
    flatbuffers::FlatBufferBuilder &_fbb,
    EltwiseType type = EltwiseType_PROD,
    flatbuffers::Offset<QuantizedFloatParam> inputQuan0 = 0,
    flatbuffers::Offset<QuantizedFloatParam> inputQuan1 = 0,
    flatbuffers::Offset<QuantizedFloatParam> outputQuan = 0) {
  EltwiseInt8Builder builder_(_fbb);
  builder_.add_outputQuan(outputQuan);
  builder_.add_inputQuan1(inputQuan1);
  builder_.add_inputQuan0(inputQuan0);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<EltwiseInt8> CreateEltwiseInt8(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CumSumT : public flatbuffers::NativeTable {
  typedef CumSum TableType;
  bool exclusive;
  bool reverse;
  CumSumT()
      : exclusive(false),
        reverse(false) {
  }
};

struct CumSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CumSumT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CumSumTypeTable();
  }
  bool exclusive() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  bool reverse() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  CumSumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CumSumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CumSum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CumSumBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CumSumBuilder &operator=(const CumSumBuilder &);
  flatbuffers::Offset<CumSum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CumSum>(end);
    return o;
  }
};

inline flatbuffers::Offset<CumSum> CreateCumSum(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool exclusive = false,
    bool reverse = false) {
  CumSumBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

flatbuffers::Offset<CumSum> CreateCumSum(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Convolution2DCommonT *Convolution2DCommon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Convolution2DCommonT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Convolution2DCommon::UnPackTo(Convolution2DCommonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; };
  { auto _e = padY(); _o->padY = _e; };
  { auto _e = kernelX(); _o->kernelX = _e; };
  { auto _e = kernelY(); _o->kernelY = _e; };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
  { auto _e = dilateX(); _o->dilateX = _e; };
  { auto _e = dilateY(); _o->dilateY = _e; };
  { auto _e = padMode(); _o->padMode = _e; };
  { auto _e = group(); _o->group = _e; };
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = inputCount(); _o->inputCount = _e; };
  { auto _e = relu(); _o->relu = _e; };
  { auto _e = relu6(); _o->relu6 = _e; };
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } };
  { auto _e = outPads(); if (_e) { _o->outPads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outPads[_i] = _e->Get(_i); } } };
  { auto _e = hasOutputShape(); _o->hasOutputShape = _e; };
}

inline flatbuffers::Offset<Convolution2DCommon> Convolution2DCommon::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution2DCommon(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution2DCommonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _dilateX = _o->dilateX;
  auto _dilateY = _o->dilateY;
  auto _padMode = _o->padMode;
  auto _group = _o->group;
  auto _outputCount = _o->outputCount;
  auto _inputCount = _o->inputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _outPads = _o->outPads.size() ? _fbb.CreateVector(_o->outPads) : 0;
  auto _hasOutputShape = _o->hasOutputShape;
  return MNN::CreateConvolution2DCommon(
      _fbb,
      _padX,
      _padY,
      _kernelX,
      _kernelY,
      _strideX,
      _strideY,
      _dilateX,
      _dilateY,
      _padMode,
      _group,
      _outputCount,
      _inputCount,
      _relu,
      _relu6,
      _pads,
      _outPads,
      _hasOutputShape);
}

inline Convolution3DCommonT *Convolution3DCommon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Convolution3DCommonT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Convolution3DCommon::UnPackTo(Convolution3DCommonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dilates(); if (_e) { _o->dilates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilates[_i] = _e->Get(_i); } } };
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } };
  { auto _e = kernels(); if (_e) { _o->kernels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernels[_i] = _e->Get(_i); } } };
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } };
  { auto _e = padMode(); _o->padMode = _e; };
  { auto _e = inputCount(); _o->inputCount = _e; };
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = relu(); _o->relu = _e; };
  { auto _e = relu6(); _o->relu6 = _e; };
  { auto _e = group(); _o->group = _e; };
  { auto _e = outPads(); if (_e) { _o->outPads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outPads[_i] = _e->Get(_i); } } };
  { auto _e = hasOutputShape(); _o->hasOutputShape = _e; };
}

inline flatbuffers::Offset<Convolution3DCommon> Convolution3DCommon::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution3DCommon(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution3DCommonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dilates = _o->dilates.size() ? _fbb.CreateVector(_o->dilates) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _kernels = _o->kernels.size() ? _fbb.CreateVector(_o->kernels) : 0;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _padMode = _o->padMode;
  auto _inputCount = _o->inputCount;
  auto _outputCount = _o->outputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  auto _group = _o->group;
  auto _outPads = _o->outPads.size() ? _fbb.CreateVector(_o->outPads) : 0;
  auto _hasOutputShape = _o->hasOutputShape;
  return MNN::CreateConvolution3DCommon(
      _fbb,
      _dilates,
      _strides,
      _kernels,
      _pads,
      _padMode,
      _inputCount,
      _outputCount,
      _relu,
      _relu6,
      _group,
      _outPads,
      _hasOutputShape);
}

inline SparseCommonT *SparseCommon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SparseCommonT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SparseCommon::UnPackTo(SparseCommonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = method(); _o->method = _e; };
  { auto _e = args(); if (_e) { _o->args.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->args[_i] = std::unique_ptr<AttributeT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<SparseCommon> SparseCommon::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseCommon(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseCommon> CreateSparseCommon(flatbuffers::FlatBufferBuilder &_fbb, const SparseCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseCommonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _method = _o->method;
  auto _args = _o->args.size() ? _fbb.CreateVector<flatbuffers::Offset<Attribute>> (_o->args.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->args[i].get(), __va->__rehasher); }, &_va ) : 0;
  return MNN::CreateSparseCommon(
      _fbb,
      _method,
      _args);
}

inline IDSTQuanT *IDSTQuan::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IDSTQuanT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IDSTQuan::UnPackTo(IDSTQuanT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = buffer(); if (_e) { _o->buffer.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buffer[_i] = _e->Get(_i); } } };
  { auto _e = alpha(); if (_e) { _o->alpha.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->alpha[_i] = _e->Get(_i); } } };
  { auto _e = type(); _o->type = _e; };
  { auto _e = useInt32(); _o->useInt32 = _e; };
  { auto _e = quantScale(); _o->quantScale = _e; };
  { auto _e = scaleIn(); _o->scaleIn = _e; };
  { auto _e = scaleOut(); _o->scaleOut = _e; };
  { auto _e = aMax(); _o->aMax = _e; };
  { auto _e = aMin(); _o->aMin = _e; };
  { auto _e = readType(); _o->readType = _e; };
  { auto _e = has_scaleInt(); _o->has_scaleInt = _e; };
  { auto _e = shapeInt32(); _o->shapeInt32 = _e; };
  { auto _e = weightSize(); _o->weightSize = _e; };
  { auto _e = index(); if (_e) { _o->index.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->index[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<IDSTQuan> IDSTQuan::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIDSTQuan(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IDSTQuan> CreateIDSTQuan(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IDSTQuanT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _buffer = _o->buffer.size() ? _fbb.CreateVector(_o->buffer) : 0;
  auto _alpha = _o->alpha.size() ? _fbb.CreateVector(_o->alpha) : 0;
  auto _type = _o->type;
  auto _useInt32 = _o->useInt32;
  auto _quantScale = _o->quantScale;
  auto _scaleIn = _o->scaleIn;
  auto _scaleOut = _o->scaleOut;
  auto _aMax = _o->aMax;
  auto _aMin = _o->aMin;
  auto _readType = _o->readType;
  auto _has_scaleInt = _o->has_scaleInt;
  auto _shapeInt32 = _o->shapeInt32;
  auto _weightSize = _o->weightSize;
  auto _index = _o->index.size() ? _fbb.CreateVector(_o->index) : 0;
  return MNN::CreateIDSTQuan(
      _fbb,
      _buffer,
      _alpha,
      _type,
      _useInt32,
      _quantScale,
      _scaleIn,
      _scaleOut,
      _aMax,
      _aMin,
      _readType,
      _has_scaleInt,
      _shapeInt32,
      _weightSize,
      _index);
}

inline QuantizedFloatParamT *QuantizedFloatParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QuantizedFloatParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void QuantizedFloatParam::UnPackTo(QuantizedFloatParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } };
  { auto _e = tensorScale(); if (_e) { _o->tensorScale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensorScale[_i] = _e->Get(_i); } } };
  { auto _e = method(); _o->method = _e; };
  { auto _e = nbits(); _o->nbits = _e; };
  { auto _e = zeroPoint(); _o->zeroPoint = _e; };
  { auto _e = outputZeroPoint(); _o->outputZeroPoint = _e; };
  { auto _e = clampMin(); _o->clampMin = _e; };
  { auto _e = clampMax(); _o->clampMax = _e; };
  { auto _e = winogradAttr(); if (_e) { _o->winogradAttr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->winogradAttr[_i] = _e->Get(_i); } } };
  { auto _e = outputDataType(); _o->outputDataType = _e; };
}

inline flatbuffers::Offset<QuantizedFloatParam> QuantizedFloatParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizedFloatParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParam(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizedFloatParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  auto _tensorScale = _o->tensorScale.size() ? _fbb.CreateVector(_o->tensorScale) : 0;
  auto _method = _o->method;
  auto _nbits = _o->nbits;
  auto _zeroPoint = _o->zeroPoint;
  auto _outputZeroPoint = _o->outputZeroPoint;
  auto _clampMin = _o->clampMin;
  auto _clampMax = _o->clampMax;
  auto _winogradAttr = _o->winogradAttr.size() ? _fbb.CreateVector(_o->winogradAttr) : 0;
  auto _outputDataType = _o->outputDataType;
  return MNN::CreateQuantizedFloatParam(
      _fbb,
      _weight,
      _bias,
      _scale,
      _tensorScale,
      _method,
      _nbits,
      _zeroPoint,
      _outputZeroPoint,
      _clampMin,
      _clampMax,
      _winogradAttr,
      _outputDataType);
}

inline Convolution2DT *Convolution2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Convolution2DT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Convolution2D::UnPackTo(Convolution2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = common(); if (_e) _o->common = std::unique_ptr<Convolution2DCommonT>(_e->UnPack(_resolver)); };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
  { auto _e = quanParameter(); if (_e) _o->quanParameter = std::unique_ptr<IDSTQuanT>(_e->UnPack(_resolver)); };
  { auto _e = symmetricQuan(); if (_e) _o->symmetricQuan = std::unique_ptr<QuantizedFloatParamT>(_e->UnPack(_resolver)); };
  { auto _e = sparseParameter(); if (_e) _o->sparseParameter = std::unique_ptr<SparseCommonT>(_e->UnPack(_resolver)); };
  { auto _e = external(); if (_e) { _o->external.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->external[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Convolution2D> Convolution2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution2D> CreateConvolution2D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _common = _o->common ? CreateConvolution2DCommon(_fbb, _o->common.get(), _rehasher) : 0;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _quanParameter = _o->quanParameter ? CreateIDSTQuan(_fbb, _o->quanParameter.get(), _rehasher) : 0;
  auto _symmetricQuan = _o->symmetricQuan ? CreateQuantizedFloatParam(_fbb, _o->symmetricQuan.get(), _rehasher) : 0;
  auto _sparseParameter = _o->sparseParameter ? CreateSparseCommon(_fbb, _o->sparseParameter.get(), _rehasher) : 0;
  auto _external = _o->external.size() ? _fbb.CreateVector(_o->external) : 0;
  return MNN::CreateConvolution2D(
      _fbb,
      _common,
      _weight,
      _bias,
      _quanParameter,
      _symmetricQuan,
      _sparseParameter,
      _external);
}

inline Convolution3DT *Convolution3D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Convolution3DT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Convolution3D::UnPackTo(Convolution3DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = common(); if (_e) _o->common = std::unique_ptr<Convolution3DCommonT>(_e->UnPack(_resolver)); };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
  { auto _e = external(); if (_e) { _o->external.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->external[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Convolution3D> Convolution3D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution3D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution3D> CreateConvolution3D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution3DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _common = _o->common ? CreateConvolution3DCommon(_fbb, _o->common.get(), _rehasher) : 0;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _external = _o->external.size() ? _fbb.CreateVector(_o->external) : 0;
  return MNN::CreateConvolution3D(
      _fbb,
      _common,
      _weight,
      _bias,
      _external);
}

inline InnerProductT *InnerProduct::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InnerProductT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InnerProduct::UnPackTo(InnerProductT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = biasTerm(); _o->biasTerm = _e; };
  { auto _e = weightSize(); _o->weightSize = _e; };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = transpose(); _o->transpose = _e; };
  { auto _e = quanParameter(); if (_e) _o->quanParameter = std::unique_ptr<IDSTQuanT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<InnerProduct> InnerProduct::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInnerProduct(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InnerProduct> CreateInnerProduct(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InnerProductT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputCount = _o->outputCount;
  auto _biasTerm = _o->biasTerm;
  auto _weightSize = _o->weightSize;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _axis = _o->axis;
  auto _transpose = _o->transpose;
  auto _quanParameter = _o->quanParameter ? CreateIDSTQuan(_fbb, _o->quanParameter.get(), _rehasher) : 0;
  return MNN::CreateInnerProduct(
      _fbb,
      _outputCount,
      _biasTerm,
      _weightSize,
      _weight,
      _bias,
      _axis,
      _transpose,
      _quanParameter);
}

inline PoolT *Pool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PoolT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Pool::UnPackTo(PoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; };
  { auto _e = padY(); _o->padY = _e; };
  { auto _e = isGlobal(); _o->isGlobal = _e; };
  { auto _e = kernelX(); _o->kernelX = _e; };
  { auto _e = kernelY(); _o->kernelY = _e; };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = padType(); _o->padType = _e; };
  { auto _e = dataType(); _o->dataType = _e; };
  { auto _e = ceilModel(); _o->ceilModel = _e; };
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } };
  { auto _e = countType(); _o->countType = _e; };
}

inline flatbuffers::Offset<Pool> Pool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool> CreatePool(flatbuffers::FlatBufferBuilder &_fbb, const PoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _isGlobal = _o->isGlobal;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _type = _o->type;
  auto _padType = _o->padType;
  auto _dataType = _o->dataType;
  auto _ceilModel = _o->ceilModel;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _countType = _o->countType;
  return MNN::CreatePool(
      _fbb,
      _padX,
      _padY,
      _isGlobal,
      _kernelX,
      _kernelY,
      _strideX,
      _strideY,
      _type,
      _padType,
      _dataType,
      _ceilModel,
      _pads,
      _countType);
}

inline Pool3DT *Pool3D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Pool3DT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Pool3D::UnPackTo(Pool3DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } };
  { auto _e = kernels(); if (_e) { _o->kernels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernels[_i] = _e->Get(_i); } } };
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } };
  { auto _e = type(); _o->type = _e; };
  { auto _e = padType(); _o->padType = _e; };
  { auto _e = isGlobal(); _o->isGlobal = _e; };
}

inline flatbuffers::Offset<Pool3D> Pool3D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool3D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool3D> CreatePool3D(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool3DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _kernels = _o->kernels.size() ? _fbb.CreateVector(_o->kernels) : 0;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _type = _o->type;
  auto _padType = _o->padType;
  auto _isGlobal = _o->isGlobal;
  return MNN::CreatePool3D(
      _fbb,
      _strides,
      _kernels,
      _pads,
      _type,
      _padType,
      _isGlobal);
}

inline ReluT *Relu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReluT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Relu::UnPackTo(ReluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slope(); _o->slope = _e; };
}

inline flatbuffers::Offset<Relu> Relu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Relu> CreateRelu(flatbuffers::FlatBufferBuilder &_fbb, const ReluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slope = _o->slope;
  return MNN::CreateRelu(
      _fbb,
      _slope);
}

inline Relu6T *Relu6::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Relu6T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Relu6::UnPackTo(Relu6T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = minValue(); _o->minValue = _e; };
  { auto _e = maxValue(); _o->maxValue = _e; };
}

inline flatbuffers::Offset<Relu6> Relu6::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelu6(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Relu6> CreateRelu6(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Relu6T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _minValue = _o->minValue;
  auto _maxValue = _o->maxValue;
  return MNN::CreateRelu6(
      _fbb,
      _minValue,
      _maxValue);
}

inline PReluT *PRelu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PReluT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PRelu::UnPackTo(PReluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slopeCount(); _o->slopeCount = _e; };
  { auto _e = slope(); if (_e) { _o->slope.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slope[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<PRelu> PRelu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePRelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PRelu> CreatePRelu(flatbuffers::FlatBufferBuilder &_fbb, const PReluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PReluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slopeCount = _o->slopeCount;
  auto _slope = _o->slope.size() ? _fbb.CreateVector(_o->slope) : 0;
  return MNN::CreatePRelu(
      _fbb,
      _slopeCount,
      _slope);
}

inline ELUT *ELU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ELUT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ELU::UnPackTo(ELUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; };
}

inline flatbuffers::Offset<ELU> ELU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ELUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateELU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ELU> CreateELU(flatbuffers::FlatBufferBuilder &_fbb, const ELUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ELUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return MNN::CreateELU(
      _fbb,
      _alpha);
}

inline LRNT *LRN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LRNT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LRN::UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = regionType(); _o->regionType = _e; };
  { auto _e = localSize(); _o->localSize = _e; };
  { auto _e = alpha(); _o->alpha = _e; };
  { auto _e = beta(); _o->beta = _e; };
  { auto _e = bias(); _o->bias = _e; };
}

inline flatbuffers::Offset<LRN> LRN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLRN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LRNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _regionType = _o->regionType;
  auto _localSize = _o->localSize;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  auto _bias = _o->bias;
  return MNN::CreateLRN(
      _fbb,
      _regionType,
      _localSize,
      _alpha,
      _beta,
      _bias);
}

inline ArgMaxT *ArgMax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ArgMaxT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ArgMax::UnPackTo(ArgMaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outMaxVal(); _o->outMaxVal = _e; };
  { auto _e = topK(); _o->topK = _e; };
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = softmaxThreshold(); _o->softmaxThreshold = _e; };
}

inline flatbuffers::Offset<ArgMax> ArgMax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMax> CreateArgMax(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outMaxVal = _o->outMaxVal;
  auto _topK = _o->topK;
  auto _axis = _o->axis;
  auto _softmaxThreshold = _o->softmaxThreshold;
  return MNN::CreateArgMax(
      _fbb,
      _outMaxVal,
      _topK,
      _axis,
      _softmaxThreshold);
}

inline AxisT *Axis::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AxisT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Axis::UnPackTo(AxisT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<Axis> Axis::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AxisT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAxis(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Axis> CreateAxis(flatbuffers::FlatBufferBuilder &_fbb, const AxisT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AxisT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return MNN::CreateAxis(
      _fbb,
      _axis);
}

inline InputT *Input::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InputT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Input::UnPackTo(InputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } };
  { auto _e = dtype(); _o->dtype = _e; };
  { auto _e = dformat(); _o->dformat = _e; };
}

inline flatbuffers::Offset<Input> Input::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Input> CreateInput(flatbuffers::FlatBufferBuilder &_fbb, const InputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dtype = _o->dtype;
  auto _dformat = _o->dformat;
  return MNN::CreateInput(
      _fbb,
      _dims,
      _dtype,
      _dformat);
}

inline LSTMT *LSTM::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LSTMT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LSTM::UnPackTo(LSTMT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = weightSize(); _o->weightSize = _e; };
  { auto _e = clippingThreshold(); _o->clippingThreshold = _e; };
  { auto _e = weightI(); if (_e) _o->weightI = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = weightH(); if (_e) _o->weightH = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bias(); if (_e) _o->bias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = weightIQ(); if (_e) _o->weightIQ = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = weightIA(); if (_e) _o->weightIA = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = quantScale(); _o->quantScale = _e; };
}

inline flatbuffers::Offset<LSTM> LSTM::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSTM(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTM> CreateLSTM(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputCount = _o->outputCount;
  auto _weightSize = _o->weightSize;
  auto _clippingThreshold = _o->clippingThreshold;
  auto _weightI = _o->weightI ? CreateBlob(_fbb, _o->weightI.get(), _rehasher) : 0;
  auto _weightH = _o->weightH ? CreateBlob(_fbb, _o->weightH.get(), _rehasher) : 0;
  auto _bias = _o->bias ? CreateBlob(_fbb, _o->bias.get(), _rehasher) : 0;
  auto _weightIQ = _o->weightIQ ? CreateBlob(_fbb, _o->weightIQ.get(), _rehasher) : 0;
  auto _weightIA = _o->weightIA ? CreateBlob(_fbb, _o->weightIA.get(), _rehasher) : 0;
  auto _quantScale = _o->quantScale;
  return MNN::CreateLSTM(
      _fbb,
      _outputCount,
      _weightSize,
      _clippingThreshold,
      _weightI,
      _weightH,
      _bias,
      _weightIQ,
      _weightIA,
      _quantScale);
}

inline SliceT *Slice::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SliceT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Slice::UnPackTo(SliceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = slicePoints(); if (_e) { _o->slicePoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slicePoints[_i] = _e->Get(_i); } } };
  { auto _e = sourceType(); _o->sourceType = _e; };
}

inline flatbuffers::Offset<Slice> Slice::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSlice(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Slice> CreateSlice(flatbuffers::FlatBufferBuilder &_fbb, const SliceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _slicePoints = _o->slicePoints.size() ? _fbb.CreateVector(_o->slicePoints) : 0;
  auto _sourceType = _o->sourceType;
  return MNN::CreateSlice(
      _fbb,
      _axis,
      _slicePoints,
      _sourceType);
}

inline BatchNormT *BatchNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BatchNormT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BatchNorm::UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; };
  { auto _e = slopeData(); if (_e) { _o->slopeData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slopeData[_i] = _e->Get(_i); } } };
  { auto _e = meanData(); if (_e) { _o->meanData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meanData[_i] = _e->Get(_i); } } };
  { auto _e = varData(); if (_e) { _o->varData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->varData[_i] = _e->Get(_i); } } };
  { auto _e = biasData(); if (_e) { _o->biasData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->biasData[_i] = _e->Get(_i); } } };
  { auto _e = Adata(); if (_e) { _o->Adata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Adata[_i] = _e->Get(_i); } } };
  { auto _e = Bdata(); if (_e) { _o->Bdata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Bdata[_i] = _e->Get(_i); } } };
  { auto _e = epsilon(); _o->epsilon = _e; };
}

inline flatbuffers::Offset<BatchNorm> BatchNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _slopeData = _o->slopeData.size() ? _fbb.CreateVector(_o->slopeData) : 0;
  auto _meanData = _o->meanData.size() ? _fbb.CreateVector(_o->meanData) : 0;
  auto _varData = _o->varData.size() ? _fbb.CreateVector(_o->varData) : 0;
  auto _biasData = _o->biasData.size() ? _fbb.CreateVector(_o->biasData) : 0;
  auto _Adata = _o->Adata.size() ? _fbb.CreateVector(_o->Adata) : 0;
  auto _Bdata = _o->Bdata.size() ? _fbb.CreateVector(_o->Bdata) : 0;
  auto _epsilon = _o->epsilon;
  return MNN::CreateBatchNorm(
      _fbb,
      _channels,
      _slopeData,
      _meanData,
      _varData,
      _biasData,
      _Adata,
      _Bdata,
      _epsilon);
}

inline ScaleT *Scale::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ScaleT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Scale::UnPackTo(ScaleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; };
  { auto _e = scaleData(); if (_e) { _o->scaleData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scaleData[_i] = _e->Get(_i); } } };
  { auto _e = biasData(); if (_e) { _o->biasData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->biasData[_i] = _e->Get(_i); } } };
  { auto _e = external(); if (_e) { _o->external.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->external[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Scale> Scale::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScale(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Scale> CreateScale(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScaleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _scaleData = _o->scaleData.size() ? _fbb.CreateVector(_o->scaleData) : 0;
  auto _biasData = _o->biasData.size() ? _fbb.CreateVector(_o->biasData) : 0;
  auto _external = _o->external.size() ? _fbb.CreateVector(_o->external) : 0;
  return MNN::CreateScale(
      _fbb,
      _channels,
      _scaleData,
      _biasData,
      _external);
}

inline EltwiseT *Eltwise::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EltwiseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Eltwise::UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = coeff(); if (_e) { _o->coeff.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->coeff[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Eltwise> Eltwise::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEltwise(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _coeff = _o->coeff.size() ? _fbb.CreateVector(_o->coeff) : 0;
  return MNN::CreateEltwise(
      _fbb,
      _type,
      _coeff);
}

inline FlattenT *Flatten::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FlattenT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Flatten::UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = endAxis(); _o->endAxis = _e; };
}

inline flatbuffers::Offset<Flatten> Flatten::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlatten(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _endAxis = _o->endAxis;
  return MNN::CreateFlatten(
      _fbb,
      _axis,
      _endAxis);
}

inline PermuteT *Permute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PermuteT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Permute::UnPackTo(PermuteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Permute> Permute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePermute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Permute> CreatePermute(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PermuteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return MNN::CreatePermute(
      _fbb,
      _dims);
}

inline ReshapeT *Reshape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReshapeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reshape::UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } };
  { auto _e = dimType(); _o->dimType = _e; };
}

inline flatbuffers::Offset<Reshape> Reshape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dimType = _o->dimType;
  return MNN::CreateReshape(
      _fbb,
      _dims,
      _dimType);
}

inline DetectionOutputT *DetectionOutput::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DetectionOutputT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DetectionOutput::UnPackTo(DetectionOutputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = classCount(); _o->classCount = _e; };
  { auto _e = nmsThresholdold(); _o->nmsThresholdold = _e; };
  { auto _e = nmsTopK(); _o->nmsTopK = _e; };
  { auto _e = keepTopK(); _o->keepTopK = _e; };
  { auto _e = confidenceThreshold(); _o->confidenceThreshold = _e; };
  { auto _e = shareLocation(); _o->shareLocation = _e; };
  { auto _e = backgroundLable(); _o->backgroundLable = _e; };
  { auto _e = varianceEncodedTarget(); _o->varianceEncodedTarget = _e; };
  { auto _e = codeType(); _o->codeType = _e; };
  { auto _e = objectnessScore(); _o->objectnessScore = _e; };
}

inline flatbuffers::Offset<DetectionOutput> DetectionOutput::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectionOutput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectionOutput> CreateDetectionOutput(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionOutputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _classCount = _o->classCount;
  auto _nmsThresholdold = _o->nmsThresholdold;
  auto _nmsTopK = _o->nmsTopK;
  auto _keepTopK = _o->keepTopK;
  auto _confidenceThreshold = _o->confidenceThreshold;
  auto _shareLocation = _o->shareLocation;
  auto _backgroundLable = _o->backgroundLable;
  auto _varianceEncodedTarget = _o->varianceEncodedTarget;
  auto _codeType = _o->codeType;
  auto _objectnessScore = _o->objectnessScore;
  return MNN::CreateDetectionOutput(
      _fbb,
      _classCount,
      _nmsThresholdold,
      _nmsTopK,
      _keepTopK,
      _confidenceThreshold,
      _shareLocation,
      _backgroundLable,
      _varianceEncodedTarget,
      _codeType,
      _objectnessScore);
}

inline RoiParametersT *RoiParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RoiParametersT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RoiParameters::UnPackTo(RoiParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pooledWidth(); _o->pooledWidth = _e; };
  { auto _e = pooledHeight(); _o->pooledHeight = _e; };
  { auto _e = spatialScale(); _o->spatialScale = _e; };
  { auto _e = samplingRatio(); _o->samplingRatio = _e; };
  { auto _e = aligned(); _o->aligned = _e; };
  { auto _e = poolType(); _o->poolType = _e; };
  { auto _e = outputGrad(); _o->outputGrad = _e; };
}

inline flatbuffers::Offset<RoiParameters> RoiParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoiParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoiParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoiParameters> CreateRoiParameters(flatbuffers::FlatBufferBuilder &_fbb, const RoiParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoiParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pooledWidth = _o->pooledWidth;
  auto _pooledHeight = _o->pooledHeight;
  auto _spatialScale = _o->spatialScale;
  auto _samplingRatio = _o->samplingRatio;
  auto _aligned = _o->aligned;
  auto _poolType = _o->poolType;
  auto _outputGrad = _o->outputGrad;
  return MNN::CreateRoiParameters(
      _fbb,
      _pooledWidth,
      _pooledHeight,
      _spatialScale,
      _samplingRatio,
      _aligned,
      _poolType,
      _outputGrad);
}

inline ProposalT *Proposal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProposalT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Proposal::UnPackTo(ProposalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = featStride(); _o->featStride = _e; };
  { auto _e = baseSize(); _o->baseSize = _e; };
  { auto _e = preNmsTopN(); _o->preNmsTopN = _e; };
  { auto _e = afterNmsTopN(); _o->afterNmsTopN = _e; };
  { auto _e = nmsThreshold(); _o->nmsThreshold = _e; };
  { auto _e = minSize(); _o->minSize = _e; };
  { auto _e = ratios(); if (_e) _o->ratios = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = scales(); if (_e) _o->scales = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = anchors(); if (_e) _o->anchors = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Proposal> Proposal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProposal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Proposal> CreateProposal(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProposalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _featStride = _o->featStride;
  auto _baseSize = _o->baseSize;
  auto _preNmsTopN = _o->preNmsTopN;
  auto _afterNmsTopN = _o->afterNmsTopN;
  auto _nmsThreshold = _o->nmsThreshold;
  auto _minSize = _o->minSize;
  auto _ratios = _o->ratios ? CreateBlob(_fbb, _o->ratios.get(), _rehasher) : 0;
  auto _scales = _o->scales ? CreateBlob(_fbb, _o->scales.get(), _rehasher) : 0;
  auto _anchors = _o->anchors ? CreateBlob(_fbb, _o->anchors.get(), _rehasher) : 0;
  return MNN::CreateProposal(
      _fbb,
      _featStride,
      _baseSize,
      _preNmsTopN,
      _afterNmsTopN,
      _nmsThreshold,
      _minSize,
      _ratios,
      _scales,
      _anchors);
}

inline InterpT *Interp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InterpT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Interp::UnPackTo(InterpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = widthScale(); _o->widthScale = _e; };
  { auto _e = heightScale(); _o->heightScale = _e; };
  { auto _e = outputWidth(); _o->outputWidth = _e; };
  { auto _e = outputHeight(); _o->outputHeight = _e; };
  { auto _e = resizeType(); _o->resizeType = _e; };
  { auto _e = alignCorners(); _o->alignCorners = _e; };
  { auto _e = halfPixelCenters(); _o->halfPixelCenters = _e; };
  { auto _e = widthOffset(); _o->widthOffset = _e; };
  { auto _e = heightOffset(); _o->heightOffset = _e; };
  { auto _e = cubicCoeffA(); _o->cubicCoeffA = _e; };
  { auto _e = ctm(); _o->ctm = _e; };
  { auto _e = depthScale(); _o->depthScale = _e; };
  { auto _e = outputDepth(); _o->outputDepth = _e; };
  { auto _e = depthOffset(); _o->depthOffset = _e; };
}

inline flatbuffers::Offset<Interp> Interp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInterp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Interp> CreateInterp(flatbuffers::FlatBufferBuilder &_fbb, const InterpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InterpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _widthScale = _o->widthScale;
  auto _heightScale = _o->heightScale;
  auto _outputWidth = _o->outputWidth;
  auto _outputHeight = _o->outputHeight;
  auto _resizeType = _o->resizeType;
  auto _alignCorners = _o->alignCorners;
  auto _halfPixelCenters = _o->halfPixelCenters;
  auto _widthOffset = _o->widthOffset;
  auto _heightOffset = _o->heightOffset;
  auto _cubicCoeffA = _o->cubicCoeffA;
  auto _ctm = _o->ctm;
  auto _depthScale = _o->depthScale;
  auto _outputDepth = _o->outputDepth;
  auto _depthOffset = _o->depthOffset;
  return MNN::CreateInterp(
      _fbb,
      _widthScale,
      _heightScale,
      _outputWidth,
      _outputHeight,
      _resizeType,
      _alignCorners,
      _halfPixelCenters,
      _widthOffset,
      _heightOffset,
      _cubicCoeffA,
      _ctm,
      _depthScale,
      _outputDepth,
      _depthOffset);
}

inline ResizeT *Resize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResizeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Resize::UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = xScale(); _o->xScale = _e; };
  { auto _e = yScale(); _o->yScale = _e; };
}

inline flatbuffers::Offset<Resize> Resize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _xScale = _o->xScale;
  auto _yScale = _o->yScale;
  return MNN::CreateResize(
      _fbb,
      _xScale,
      _yScale);
}

inline PriorBoxT *PriorBox::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PriorBoxT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PriorBox::UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = minSizes(); if (_e) { _o->minSizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->minSizes[_i] = _e->Get(_i); } } };
  { auto _e = maxSizes(); if (_e) { _o->maxSizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->maxSizes[_i] = _e->Get(_i); } } };
  { auto _e = aspectRatios(); if (_e) { _o->aspectRatios.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aspectRatios[_i] = _e->Get(_i); } } };
  { auto _e = variances(); if (_e) { _o->variances.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variances[_i] = _e->Get(_i); } } };
  { auto _e = flip(); _o->flip = _e; };
  { auto _e = clip(); _o->clip = _e; };
  { auto _e = imageWidth(); _o->imageWidth = _e; };
  { auto _e = imageHeight(); _o->imageHeight = _e; };
  { auto _e = stepWidth(); _o->stepWidth = _e; };
  { auto _e = stepHeight(); _o->stepHeight = _e; };
  { auto _e = offset(); _o->offset = _e; };
}

inline flatbuffers::Offset<PriorBox> PriorBox::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriorBox(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PriorBoxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _minSizes = _o->minSizes.size() ? _fbb.CreateVector(_o->minSizes) : 0;
  auto _maxSizes = _o->maxSizes.size() ? _fbb.CreateVector(_o->maxSizes) : 0;
  auto _aspectRatios = _o->aspectRatios.size() ? _fbb.CreateVector(_o->aspectRatios) : 0;
  auto _variances = _o->variances.size() ? _fbb.CreateVector(_o->variances) : 0;
  auto _flip = _o->flip;
  auto _clip = _o->clip;
  auto _imageWidth = _o->imageWidth;
  auto _imageHeight = _o->imageHeight;
  auto _stepWidth = _o->stepWidth;
  auto _stepHeight = _o->stepHeight;
  auto _offset = _o->offset;
  return MNN::CreatePriorBox(
      _fbb,
      _minSizes,
      _maxSizes,
      _aspectRatios,
      _variances,
      _flip,
      _clip,
      _imageWidth,
      _imageHeight,
      _stepWidth,
      _stepHeight,
      _offset);
}

inline NormalizeT *Normalize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NormalizeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Normalize::UnPackTo(NormalizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acrossSpatial(); _o->acrossSpatial = _e; };
  { auto _e = channelShared(); _o->channelShared = _e; };
  { auto _e = eps(); _o->eps = _e; };
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Normalize> Normalize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNormalize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Normalize> CreateNormalize(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NormalizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _acrossSpatial = _o->acrossSpatial;
  auto _channelShared = _o->channelShared;
  auto _eps = _o->eps;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  return MNN::CreateNormalize(
      _fbb,
      _acrossSpatial,
      _channelShared,
      _eps,
      _scale);
}

inline EltwiseInt8T *EltwiseInt8::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EltwiseInt8T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EltwiseInt8::UnPackTo(EltwiseInt8T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = inputQuan0(); if (_e) _o->inputQuan0 = std::unique_ptr<QuantizedFloatParamT>(_e->UnPack(_resolver)); };
  { auto _e = inputQuan1(); if (_e) _o->inputQuan1 = std::unique_ptr<QuantizedFloatParamT>(_e->UnPack(_resolver)); };
  { auto _e = outputQuan(); if (_e) _o->outputQuan = std::unique_ptr<QuantizedFloatParamT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<EltwiseInt8> EltwiseInt8::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEltwiseInt8(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EltwiseInt8> CreateEltwiseInt8(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseInt8T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _inputQuan0 = _o->inputQuan0 ? CreateQuantizedFloatParam(_fbb, _o->inputQuan0.get(), _rehasher) : 0;
  auto _inputQuan1 = _o->inputQuan1 ? CreateQuantizedFloatParam(_fbb, _o->inputQuan1.get(), _rehasher) : 0;
  auto _outputQuan = _o->outputQuan ? CreateQuantizedFloatParam(_fbb, _o->outputQuan.get(), _rehasher) : 0;
  return MNN::CreateEltwiseInt8(
      _fbb,
      _type,
      _inputQuan0,
      _inputQuan1,
      _outputQuan);
}

inline CumSumT *CumSum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CumSumT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CumSum::UnPackTo(CumSumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = exclusive(); _o->exclusive = _e; };
  { auto _e = reverse(); _o->reverse = _e; };
}

inline flatbuffers::Offset<CumSum> CumSum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCumSum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CumSum> CreateCumSum(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CumSumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _exclusive = _o->exclusive;
  auto _reverse = _o->reverse;
  return MNN::CreateCumSum(
      _fbb,
      _exclusive,
      _reverse);
}

inline const flatbuffers::TypeTable *PadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparseAlgoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SparseAlgoTypeTable
  };
  static const char * const names[] = {
    "RANDOM",
    "SIMD_OC"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantizeAlgoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    QuantizeAlgoTypeTable
  };
  static const char * const names[] = {
    "DEFAULT",
    "OVERFLOW_AWARE",
    "WINOGRAD_AWARE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable
  };
  static const char * const names[] = {
    "MAXPOOL",
    "AVEPOOL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolPadTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolPadTypeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AvgPoolCountTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AvgPoolCountTypeTypeTable
  };
  static const char * const names[] = {
    "DEFAULT",
    "INCLUDE_PADDING",
    "EXCLUDE_PADDING"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    EltwiseTypeTypeTable
  };
  static const char * const names[] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "SUB"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CoordinateTransformationModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CoordinateTransformationModeTypeTable
  };
  static const char * const names[] = {
    "NotSet",
    "AlignCorners",
    "HalfPixels",
    "PytorchHalfPixels",
    "Asymmetric",
    "TensorflowHalfPixels",
    "TensorflowCropAndResize"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution2DCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "padX",
    "padY",
    "kernelX",
    "kernelY",
    "strideX",
    "strideY",
    "dilateX",
    "dilateY",
    "padMode",
    "group",
    "outputCount",
    "inputCount",
    "relu",
    "relu6",
    "pads",
    "outPads",
    "hasOutputShape"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 17, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution3DCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "dilates",
    "strides",
    "kernels",
    "pads",
    "padMode",
    "inputCount",
    "outputCount",
    "relu",
    "relu6",
    "group",
    "outPads",
    "hasOutputShape"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 12, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparseCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SparseAlgoTypeTable,
    AttributeTypeTable
  };
  static const char * const names[] = {
    "method",
    "args"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IDSTQuanTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 1, -1 }
  };
  static const char * const names[] = {
    "buffer",
    "alpha",
    "type",
    "useInt32",
    "quantScale",
    "scaleIn",
    "scaleOut",
    "aMax",
    "aMin",
    "readType",
    "has_scaleInt",
    "shapeInt32",
    "weightSize",
    "index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantizedFloatParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    QuantizeAlgoTypeTable,
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "weight",
    "bias",
    "scale",
    "tensorScale",
    "method",
    "nbits",
    "zeroPoint",
    "outputZeroPoint",
    "clampMin",
    "clampMax",
    "winogradAttr",
    "outputDataType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 12, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Convolution2DCommonTypeTable,
    IDSTQuanTypeTable,
    QuantizedFloatParamTypeTable,
    SparseCommonTypeTable
  };
  static const char * const names[] = {
    "common",
    "weight",
    "bias",
    "quanParameter",
    "symmetricQuan",
    "sparseParameter",
    "external"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution3DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Convolution3DCommonTypeTable
  };
  static const char * const names[] = {
    "common",
    "weight",
    "bias",
    "external"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InnerProductTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    IDSTQuanTypeTable
  };
  static const char * const names[] = {
    "outputCount",
    "biasTerm",
    "weightSize",
    "weight",
    "bias",
    "axis",
    "transpose",
    "quanParameter"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, 2 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable,
    PoolPadTypeTypeTable,
    DataTypeTypeTable,
    AvgPoolCountTypeTypeTable
  };
  static const char * const names[] = {
    "padX",
    "padY",
    "isGlobal",
    "kernelX",
    "kernelY",
    "strideX",
    "strideY",
    "type",
    "padType",
    "dataType",
    "ceilModel",
    "pads",
    "countType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pool3DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable,
    PoolPadTypeTypeTable
  };
  static const char * const names[] = {
    "strides",
    "kernels",
    "pads",
    "type",
    "padType",
    "isGlobal"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Relu6TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "minValue",
    "maxValue"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PReluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "slopeCount",
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ELUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LRNTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "regionType",
    "localSize",
    "alpha",
    "beta",
    "bias"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "outMaxVal",
    "topK",
    "axis",
    "softmaxThreshold"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AxisTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable,
    MNN_DATA_FORMATTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dtype",
    "dformat"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LSTMTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlobTypeTable
  };
  static const char * const names[] = {
    "outputCount",
    "weightSize",
    "clippingThreshold",
    "weightI",
    "weightH",
    "bias",
    "weightIQ",
    "weightIA",
    "quantScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SliceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    NetSourceTypeTable
  };
  static const char * const names[] = {
    "axis",
    "slicePoints",
    "sourceType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "channels",
    "slopeData",
    "meanData",
    "varData",
    "biasData",
    "Adata",
    "Bdata",
    "epsilon"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScaleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "channels",
    "scaleData",
    "biasData",
    "external"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    EltwiseTypeTypeTable
  };
  static const char * const names[] = {
    "type",
    "coeff"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FlattenTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis",
    "endAxis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PermuteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReshapeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MNN_DATA_FORMATTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dimType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DetectionOutputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "classCount",
    "nmsThresholdold",
    "nmsTopK",
    "keepTopK",
    "confidenceThreshold",
    "shareLocation",
    "backgroundLable",
    "varianceEncodedTarget",
    "codeType",
    "objectnessScore"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoiParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable
  };
  static const char * const names[] = {
    "pooledWidth",
    "pooledHeight",
    "spatialScale",
    "samplingRatio",
    "aligned",
    "poolType",
    "outputGrad"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProposalTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlobTypeTable
  };
  static const char * const names[] = {
    "featStride",
    "baseSize",
    "preNmsTopN",
    "afterNmsTopN",
    "nmsThreshold",
    "minSize",
    "ratios",
    "scales",
    "anchors"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InterpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CoordinateTransformationModeTypeTable
  };
  static const char * const names[] = {
    "widthScale",
    "heightScale",
    "outputWidth",
    "outputHeight",
    "resizeType",
    "alignCorners",
    "halfPixelCenters",
    "widthOffset",
    "heightOffset",
    "cubicCoeffA",
    "ctm",
    "depthScale",
    "outputDepth",
    "depthOffset"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "xScale",
    "yScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PriorBoxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "minSizes",
    "maxSizes",
    "aspectRatios",
    "variances",
    "flip",
    "clip",
    "imageWidth",
    "imageHeight",
    "stepWidth",
    "stepHeight",
    "offset"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NormalizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "acrossSpatial",
    "channelShared",
    "eps",
    "scale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseInt8TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    EltwiseTypeTypeTable,
    QuantizedFloatParamTypeTable
  };
  static const char * const names[] = {
    "type",
    "inputQuan0",
    "inputQuan1",
    "outputQuan"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CumSumTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "exclusive",
    "reverse"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace MNN

#endif  // FLATBUFFERS_GENERATED_CAFFEOP_MNN_H_
