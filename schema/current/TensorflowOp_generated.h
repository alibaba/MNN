// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TENSORFLOWOP_MNN_H_
#define FLATBUFFERS_GENERATED_TENSORFLOWOP_MNN_H_


#include "Tensor_generated.h"
#include "Type_generated.h"

namespace MNN {

struct BinaryOp;
struct BinaryOpT;

struct PackParam;
struct PackParamT;

struct StridedSliceParam;
struct StridedSliceParamT;

struct SqueezeParam;
struct SqueezeParamT;

struct CastParam;
struct CastParamT;

struct ReductionParam;
struct ReductionParamT;

struct Gather;
struct GatherT;

struct ExpandDims;
struct ExpandDimsT;

struct Selu;
struct SeluT;

struct AsString;
struct AsStringT;

struct ReduceJoin;
struct ReduceJoinT;

struct UnaryOp;
struct UnaryOpT;

struct TopKV2;
struct TopKV2T;

struct CropAndResize;
struct CropAndResizeT;

struct Fill;
struct FillT;

struct GatherV2;
struct GatherV2T;

struct NonMaxSuppressionV2;
struct NonMaxSuppressionV2T;

struct Range;
struct RangeT;

struct Rank;
struct RankT;

struct Size;
struct SizeT;

struct Transpose;
struct TransposeT;

struct SliceTf;
struct SliceTfT;

struct QuantizeMaxMin;
struct QuantizeMaxMinT;

struct Crop;
struct CropT;

struct SpaceBatch;
struct SpaceBatchT;

struct MatMul;
struct MatMulT;

struct MomentsParam;
struct MomentsParamT;

struct RNNParam;
struct RNNParamT;

struct BatchMatMulParam;
struct BatchMatMulParamT;

struct DepthSpaceParam;
struct DepthSpaceParamT;

struct ReverseSequenceParam;
struct ReverseSequenceParamT;

struct DetectionPostProcessParam;
struct DetectionPostProcessParamT;

struct OneHotParam;
struct OneHotParamT;

struct PadParam;
struct PadParamT;

struct LayerNorm;
struct LayerNormT;

struct RandomUniform;
struct RandomUniformT;

struct TensorArray;
struct TensorArrayT;

struct LSTMBlockCell;
struct LSTMBlockCellT;

inline const flatbuffers::TypeTable *BinaryOpTypeTable();

inline const flatbuffers::TypeTable *PackParamTypeTable();

inline const flatbuffers::TypeTable *StridedSliceParamTypeTable();

inline const flatbuffers::TypeTable *SqueezeParamTypeTable();

inline const flatbuffers::TypeTable *CastParamTypeTable();

inline const flatbuffers::TypeTable *ReductionParamTypeTable();

inline const flatbuffers::TypeTable *GatherTypeTable();

inline const flatbuffers::TypeTable *ExpandDimsTypeTable();

inline const flatbuffers::TypeTable *SeluTypeTable();

inline const flatbuffers::TypeTable *AsStringTypeTable();

inline const flatbuffers::TypeTable *ReduceJoinTypeTable();

inline const flatbuffers::TypeTable *UnaryOpTypeTable();

inline const flatbuffers::TypeTable *TopKV2TypeTable();

inline const flatbuffers::TypeTable *CropAndResizeTypeTable();

inline const flatbuffers::TypeTable *FillTypeTable();

inline const flatbuffers::TypeTable *GatherV2TypeTable();

inline const flatbuffers::TypeTable *NonMaxSuppressionV2TypeTable();

inline const flatbuffers::TypeTable *RangeTypeTable();

inline const flatbuffers::TypeTable *RankTypeTable();

inline const flatbuffers::TypeTable *SizeTypeTable();

inline const flatbuffers::TypeTable *TransposeTypeTable();

inline const flatbuffers::TypeTable *SliceTfTypeTable();

inline const flatbuffers::TypeTable *QuantizeMaxMinTypeTable();

inline const flatbuffers::TypeTable *CropTypeTable();

inline const flatbuffers::TypeTable *SpaceBatchTypeTable();

inline const flatbuffers::TypeTable *MatMulTypeTable();

inline const flatbuffers::TypeTable *MomentsParamTypeTable();

inline const flatbuffers::TypeTable *RNNParamTypeTable();

inline const flatbuffers::TypeTable *BatchMatMulParamTypeTable();

inline const flatbuffers::TypeTable *DepthSpaceParamTypeTable();

inline const flatbuffers::TypeTable *ReverseSequenceParamTypeTable();

inline const flatbuffers::TypeTable *DetectionPostProcessParamTypeTable();

inline const flatbuffers::TypeTable *OneHotParamTypeTable();

inline const flatbuffers::TypeTable *PadParamTypeTable();

inline const flatbuffers::TypeTable *LayerNormTypeTable();

inline const flatbuffers::TypeTable *RandomUniformTypeTable();

inline const flatbuffers::TypeTable *TensorArrayTypeTable();

inline const flatbuffers::TypeTable *LSTMBlockCellTypeTable();

enum BinaryOpOperation {
  BinaryOpOperation_ADD = 0,
  BinaryOpOperation_SUB = 1,
  BinaryOpOperation_MUL = 2,
  BinaryOpOperation_DIV = 3,
  BinaryOpOperation_MAX_TEMP = 4,
  BinaryOpOperation_MIN_TEMP = 5,
  BinaryOpOperation_POW = 6,
  BinaryOpOperation_REALDIV = 7,
  BinaryOpOperation_MINIMUM = 8,
  BinaryOpOperation_MAXIMUM = 9,
  BinaryOpOperation_GREATER = 10,
  BinaryOpOperation_GREATER_EQUAL = 11,
  BinaryOpOperation_LESS = 12,
  BinaryOpOperation_FLOORDIV = 13,
  BinaryOpOperation_SquaredDifference = 14,
  BinaryOpOperation_EQUAL = 15,
  BinaryOpOperation_LESS_EQUAL = 16,
  BinaryOpOperation_FLOORMOD = 17,
  BinaryOpOperation_MOD = 19,
  BinaryOpOperation_ATAN2 = 20,
  BinaryOpOperation_LOGICALOR = 21,
  BinaryOpOperation_NOTEQUAL = 22,
  BinaryOpOperation_BITWISE_AND = 23,
  BinaryOpOperation_BITWISE_OR = 24,
  BinaryOpOperation_BITWISE_XOR = 25,
  BinaryOpOperation_LOGICALXOR = 26,
  BinaryOpOperation_LEFTSHIFT = 27,
  BinaryOpOperation_RIGHTSHIFT = 28,
  BinaryOpOperation_MIN = BinaryOpOperation_ADD,
  BinaryOpOperation_MAX = BinaryOpOperation_RIGHTSHIFT
};

inline const BinaryOpOperation (&EnumValuesBinaryOpOperation())[28] {
  static const BinaryOpOperation values[] = {
    BinaryOpOperation_ADD,
    BinaryOpOperation_SUB,
    BinaryOpOperation_MUL,
    BinaryOpOperation_DIV,
    BinaryOpOperation_MAX_TEMP,
    BinaryOpOperation_MIN_TEMP,
    BinaryOpOperation_POW,
    BinaryOpOperation_REALDIV,
    BinaryOpOperation_MINIMUM,
    BinaryOpOperation_MAXIMUM,
    BinaryOpOperation_GREATER,
    BinaryOpOperation_GREATER_EQUAL,
    BinaryOpOperation_LESS,
    BinaryOpOperation_FLOORDIV,
    BinaryOpOperation_SquaredDifference,
    BinaryOpOperation_EQUAL,
    BinaryOpOperation_LESS_EQUAL,
    BinaryOpOperation_FLOORMOD,
    BinaryOpOperation_MOD,
    BinaryOpOperation_ATAN2,
    BinaryOpOperation_LOGICALOR,
    BinaryOpOperation_NOTEQUAL,
    BinaryOpOperation_BITWISE_AND,
    BinaryOpOperation_BITWISE_OR,
    BinaryOpOperation_BITWISE_XOR,
    BinaryOpOperation_LOGICALXOR,
    BinaryOpOperation_LEFTSHIFT,
    BinaryOpOperation_RIGHTSHIFT
  };
  return values;
}

inline const char * const *EnumNamesBinaryOpOperation() {
  static const char * const names[] = {
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "MAX_TEMP",
    "MIN_TEMP",
    "POW",
    "REALDIV",
    "MINIMUM",
    "MAXIMUM",
    "GREATER",
    "GREATER_EQUAL",
    "LESS",
    "FLOORDIV",
    "SquaredDifference",
    "EQUAL",
    "LESS_EQUAL",
    "FLOORMOD",
    "",
    "MOD",
    "ATAN2",
    "LOGICALOR",
    "NOTEQUAL",
    "BITWISE_AND",
    "BITWISE_OR",
    "BITWISE_XOR",
    "LOGICALXOR",
    "LEFTSHIFT",
    "RIGHTSHIFT",
    nullptr
  };
  return names;
}

inline const char *EnumNameBinaryOpOperation(BinaryOpOperation e) {
  if (e < BinaryOpOperation_ADD || e > BinaryOpOperation_RIGHTSHIFT) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesBinaryOpOperation()[index];
}

enum ReductionType {
  ReductionType_SUM = 0,
  ReductionType_ASUM = 1,
  ReductionType_SUMSQ = 2,
  ReductionType_MEAN = 3,
  ReductionType_MAXIMUM = 4,
  ReductionType_MINIMUM = 5,
  ReductionType_PROD = 6,
  ReductionType_ANY = 7,
  ReductionType_ALL = 8,
  ReductionType_MIN = ReductionType_SUM,
  ReductionType_MAX = ReductionType_ALL
};

inline const ReductionType (&EnumValuesReductionType())[9] {
  static const ReductionType values[] = {
    ReductionType_SUM,
    ReductionType_ASUM,
    ReductionType_SUMSQ,
    ReductionType_MEAN,
    ReductionType_MAXIMUM,
    ReductionType_MINIMUM,
    ReductionType_PROD,
    ReductionType_ANY,
    ReductionType_ALL
  };
  return values;
}

inline const char * const *EnumNamesReductionType() {
  static const char * const names[] = {
    "SUM",
    "ASUM",
    "SUMSQ",
    "MEAN",
    "MAXIMUM",
    "MINIMUM",
    "PROD",
    "ANY",
    "ALL",
    nullptr
  };
  return names;
}

inline const char *EnumNameReductionType(ReductionType e) {
  if (e < ReductionType_SUM || e > ReductionType_ALL) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesReductionType()[index];
}

enum UnaryOpOperation {
  UnaryOpOperation_ABS = 0,
  UnaryOpOperation_NEG = 1,
  UnaryOpOperation_FLOOR = 2,
  UnaryOpOperation_CEIL = 3,
  UnaryOpOperation_SQUARE = 4,
  UnaryOpOperation_SQRT = 5,
  UnaryOpOperation_RSQRT = 6,
  UnaryOpOperation_EXP = 7,
  UnaryOpOperation_LOG = 8,
  UnaryOpOperation_SIN = 9,
  UnaryOpOperation_COS = 10,
  UnaryOpOperation_TAN = 11,
  UnaryOpOperation_ASIN = 12,
  UnaryOpOperation_ACOS = 13,
  UnaryOpOperation_ATAN = 14,
  UnaryOpOperation_RECIPROCAL = 15,
  UnaryOpOperation_LOG1P = 16,
  UnaryOpOperation_BNLL = 17,
  UnaryOpOperation_ACOSH = 18,
  UnaryOpOperation_SINH = 19,
  UnaryOpOperation_ASINH = 20,
  UnaryOpOperation_ATANH = 21,
  UnaryOpOperation_SIGN = 22,
  UnaryOpOperation_ROUND = 23,
  UnaryOpOperation_COSH = 24,
  UnaryOpOperation_ERF = 25,
  UnaryOpOperation_ERFC = 26,
  UnaryOpOperation_ERFINV = 27,
  UnaryOpOperation_EXPM1 = 28,
  UnaryOpOperation_SIGMOID = 29,
  UnaryOpOperation_TANH = 30,
  UnaryOpOperation_HARDSWISH = 31,
  UnaryOpOperation_GELU = 32,
  UnaryOpOperation_GELU_STANDARD = 33,
  UnaryOpOperation_MIN = UnaryOpOperation_ABS,
  UnaryOpOperation_MAX = UnaryOpOperation_GELU_STANDARD
};

inline const UnaryOpOperation (&EnumValuesUnaryOpOperation())[34] {
  static const UnaryOpOperation values[] = {
    UnaryOpOperation_ABS,
    UnaryOpOperation_NEG,
    UnaryOpOperation_FLOOR,
    UnaryOpOperation_CEIL,
    UnaryOpOperation_SQUARE,
    UnaryOpOperation_SQRT,
    UnaryOpOperation_RSQRT,
    UnaryOpOperation_EXP,
    UnaryOpOperation_LOG,
    UnaryOpOperation_SIN,
    UnaryOpOperation_COS,
    UnaryOpOperation_TAN,
    UnaryOpOperation_ASIN,
    UnaryOpOperation_ACOS,
    UnaryOpOperation_ATAN,
    UnaryOpOperation_RECIPROCAL,
    UnaryOpOperation_LOG1P,
    UnaryOpOperation_BNLL,
    UnaryOpOperation_ACOSH,
    UnaryOpOperation_SINH,
    UnaryOpOperation_ASINH,
    UnaryOpOperation_ATANH,
    UnaryOpOperation_SIGN,
    UnaryOpOperation_ROUND,
    UnaryOpOperation_COSH,
    UnaryOpOperation_ERF,
    UnaryOpOperation_ERFC,
    UnaryOpOperation_ERFINV,
    UnaryOpOperation_EXPM1,
    UnaryOpOperation_SIGMOID,
    UnaryOpOperation_TANH,
    UnaryOpOperation_HARDSWISH,
    UnaryOpOperation_GELU,
    UnaryOpOperation_GELU_STANDARD
  };
  return values;
}

inline const char * const *EnumNamesUnaryOpOperation() {
  static const char * const names[] = {
    "ABS",
    "NEG",
    "FLOOR",
    "CEIL",
    "SQUARE",
    "SQRT",
    "RSQRT",
    "EXP",
    "LOG",
    "SIN",
    "COS",
    "TAN",
    "ASIN",
    "ACOS",
    "ATAN",
    "RECIPROCAL",
    "LOG1P",
    "BNLL",
    "ACOSH",
    "SINH",
    "ASINH",
    "ATANH",
    "SIGN",
    "ROUND",
    "COSH",
    "ERF",
    "ERFC",
    "ERFINV",
    "EXPM1",
    "SIGMOID",
    "TANH",
    "HARDSWISH",
    "GELU",
    "GELU_STANDARD",
    nullptr
  };
  return names;
}

inline const char *EnumNameUnaryOpOperation(UnaryOpOperation e) {
  if (e < UnaryOpOperation_ABS || e > UnaryOpOperation_GELU_STANDARD) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesUnaryOpOperation()[index];
}

enum CropAndResizeMethod {
  CropAndResizeMethod_BILINEAR = 0,
  CropAndResizeMethod_NEAREST = 1,
  CropAndResizeMethod_MIN = CropAndResizeMethod_BILINEAR,
  CropAndResizeMethod_MAX = CropAndResizeMethod_NEAREST
};

inline const CropAndResizeMethod (&EnumValuesCropAndResizeMethod())[2] {
  static const CropAndResizeMethod values[] = {
    CropAndResizeMethod_BILINEAR,
    CropAndResizeMethod_NEAREST
  };
  return values;
}

inline const char * const *EnumNamesCropAndResizeMethod() {
  static const char * const names[] = {
    "BILINEAR",
    "NEAREST",
    nullptr
  };
  return names;
}

inline const char *EnumNameCropAndResizeMethod(CropAndResizeMethod e) {
  if (e < CropAndResizeMethod_BILINEAR || e > CropAndResizeMethod_NEAREST) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesCropAndResizeMethod()[index];
}

enum DepthToSpaceMode {
  DepthToSpaceMode_DCR = 0,
  DepthToSpaceMode_CRD = 1,
  DepthToSpaceMode_MIN = DepthToSpaceMode_DCR,
  DepthToSpaceMode_MAX = DepthToSpaceMode_CRD
};

inline const DepthToSpaceMode (&EnumValuesDepthToSpaceMode())[2] {
  static const DepthToSpaceMode values[] = {
    DepthToSpaceMode_DCR,
    DepthToSpaceMode_CRD
  };
  return values;
}

inline const char * const *EnumNamesDepthToSpaceMode() {
  static const char * const names[] = {
    "DCR",
    "CRD",
    nullptr
  };
  return names;
}

inline const char *EnumNameDepthToSpaceMode(DepthToSpaceMode e) {
  if (e < DepthToSpaceMode_DCR || e > DepthToSpaceMode_CRD) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesDepthToSpaceMode()[index];
}

enum PadValueMode {
  PadValueMode_CONSTANT = 0,
  PadValueMode_REFLECT = 1,
  PadValueMode_SYMMETRIC = 2,
  PadValueMode_EDGE = 3,
  PadValueMode_MIN = PadValueMode_CONSTANT,
  PadValueMode_MAX = PadValueMode_EDGE
};

inline const PadValueMode (&EnumValuesPadValueMode())[4] {
  static const PadValueMode values[] = {
    PadValueMode_CONSTANT,
    PadValueMode_REFLECT,
    PadValueMode_SYMMETRIC,
    PadValueMode_EDGE
  };
  return values;
}

inline const char * const *EnumNamesPadValueMode() {
  static const char * const names[] = {
    "CONSTANT",
    "REFLECT",
    "SYMMETRIC",
    "EDGE",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadValueMode(PadValueMode e) {
  if (e < PadValueMode_CONSTANT || e > PadValueMode_EDGE) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPadValueMode()[index];
}

struct BinaryOpT : public flatbuffers::NativeTable {
  typedef BinaryOp TableType;
  int32_t opType;
  DataType T;
  int32_t activationType;
  BinaryOpT()
      : opType(0),
        T(DataType_DT_FLOAT),
        activationType(0) {
  }
};

struct BinaryOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryOpT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BinaryOpTypeTable();
  }
  int32_t opType() const {
    return GetField<int32_t>(4, 0);
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(6, 1));
  }
  int32_t activationType() const {
    return GetField<int32_t>(8, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           verifier.EndTable();
  }
  BinaryOpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BinaryOpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BinaryOp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryOpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BinaryOpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opType(int32_t opType) {
    fbb_.AddElement<int32_t>(4, opType, 0);
  }
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(6, static_cast<int32_t>(T), 1);
  }
  void add_activationType(int32_t activationType) {
    fbb_.AddElement<int32_t>(8, activationType, 0);
  }
  explicit BinaryOpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinaryOpBuilder &operator=(const BinaryOpBuilder &);
  flatbuffers::Offset<BinaryOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryOp>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryOp> CreateBinaryOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t opType = 0,
    DataType T = DataType_DT_FLOAT,
    int32_t activationType = 0) {
  BinaryOpBuilder builder_(_fbb);
  builder_.add_activationType(activationType);
  builder_.add_T(T);
  builder_.add_opType(opType);
  return builder_.Finish();
}

flatbuffers::Offset<BinaryOp> CreateBinaryOp(flatbuffers::FlatBufferBuilder &_fbb, const BinaryOpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackParamT : public flatbuffers::NativeTable {
  typedef PackParam TableType;
  DataType dataType;
  int32_t axis;
  PackParamT()
      : dataType(DataType_DT_INVALID),
        axis(0) {
  }
};

struct PackParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PackParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PackParamTypeTable();
  }
  DataType dataType() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  int32_t axis() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  PackParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PackParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PackParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataType(DataType dataType) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(dataType), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(6, axis, 0);
  }
  explicit PackParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PackParamBuilder &operator=(const PackParamBuilder &);
  flatbuffers::Offset<PackParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PackParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<PackParam> CreatePackParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType dataType = DataType_DT_INVALID,
    int32_t axis = 0) {
  PackParamBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_dataType(dataType);
  return builder_.Finish();
}

flatbuffers::Offset<PackParam> CreatePackParam(flatbuffers::FlatBufferBuilder &_fbb, const PackParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceParamT : public flatbuffers::NativeTable {
  typedef StridedSliceParam TableType;
  DataType Index;
  DataType T;
  int32_t beginMask;
  int32_t endMask;
  int32_t ellipsisMask;
  int32_t newAxisMask;
  int32_t shrinkAxisMask;
  StridedSliceParamT()
      : Index(DataType_DT_INVALID),
        T(DataType_DT_INVALID),
        beginMask(0),
        endMask(0),
        ellipsisMask(0),
        newAxisMask(0),
        shrinkAxisMask(0) {
  }
};

struct StridedSliceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StridedSliceParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StridedSliceParamTypeTable();
  }
  DataType Index() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(6, 0));
  }
  int32_t beginMask() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t endMask() const {
    return GetField<int32_t>(10, 0);
  }
  int32_t ellipsisMask() const {
    return GetField<int32_t>(12, 0);
  }
  int32_t newAxisMask() const {
    return GetField<int32_t>(14, 0);
  }
  int32_t shrinkAxisMask() const {
    return GetField<int32_t>(16, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           verifier.EndTable();
  }
  StridedSliceParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StridedSliceParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StridedSliceParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Index(DataType Index) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(Index), 0);
  }
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(6, static_cast<int32_t>(T), 0);
  }
  void add_beginMask(int32_t beginMask) {
    fbb_.AddElement<int32_t>(8, beginMask, 0);
  }
  void add_endMask(int32_t endMask) {
    fbb_.AddElement<int32_t>(10, endMask, 0);
  }
  void add_ellipsisMask(int32_t ellipsisMask) {
    fbb_.AddElement<int32_t>(12, ellipsisMask, 0);
  }
  void add_newAxisMask(int32_t newAxisMask) {
    fbb_.AddElement<int32_t>(14, newAxisMask, 0);
  }
  void add_shrinkAxisMask(int32_t shrinkAxisMask) {
    fbb_.AddElement<int32_t>(16, shrinkAxisMask, 0);
  }
  explicit StridedSliceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceParamBuilder &operator=(const StridedSliceParamBuilder &);
  flatbuffers::Offset<StridedSliceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceParam> CreateStridedSliceParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType Index = DataType_DT_INVALID,
    DataType T = DataType_DT_INVALID,
    int32_t beginMask = 0,
    int32_t endMask = 0,
    int32_t ellipsisMask = 0,
    int32_t newAxisMask = 0,
    int32_t shrinkAxisMask = 0) {
  StridedSliceParamBuilder builder_(_fbb);
  builder_.add_shrinkAxisMask(shrinkAxisMask);
  builder_.add_newAxisMask(newAxisMask);
  builder_.add_ellipsisMask(ellipsisMask);
  builder_.add_endMask(endMask);
  builder_.add_beginMask(beginMask);
  builder_.add_T(T);
  builder_.add_Index(Index);
  return builder_.Finish();
}

flatbuffers::Offset<StridedSliceParam> CreateStridedSliceParam(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeParamT : public flatbuffers::NativeTable {
  typedef SqueezeParam TableType;
  std::vector<int32_t> squeezeDims;
  SqueezeParamT() {
  }
};

struct SqueezeParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqueezeParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqueezeParamTypeTable();
  }
  const flatbuffers::Vector<int32_t> *squeezeDims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(squeezeDims()) &&
           verifier.EndTable();
  }
  SqueezeParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqueezeParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SqueezeParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_squeezeDims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeezeDims) {
    fbb_.AddOffset(4, squeezeDims);
  }
  explicit SqueezeParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqueezeParamBuilder &operator=(const SqueezeParamBuilder &);
  flatbuffers::Offset<SqueezeParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqueezeParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqueezeParam> CreateSqueezeParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeezeDims = 0) {
  SqueezeParamBuilder builder_(_fbb);
  builder_.add_squeezeDims(squeezeDims);
  return builder_.Finish();
}

flatbuffers::Offset<SqueezeParam> CreateSqueezeParam(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastParamT : public flatbuffers::NativeTable {
  typedef CastParam TableType;
  DataType srcT;
  DataType dstT;
  CastParamT()
      : srcT(DataType_DT_INVALID),
        dstT(DataType_DT_INVALID) {
  }
};

struct CastParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CastParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CastParamTypeTable();
  }
  DataType srcT() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  DataType dstT() const {
    return static_cast<DataType>(GetField<int32_t>(6, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  CastParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CastParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CastParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_srcT(DataType srcT) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(srcT), 0);
  }
  void add_dstT(DataType dstT) {
    fbb_.AddElement<int32_t>(6, static_cast<int32_t>(dstT), 0);
  }
  explicit CastParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastParamBuilder &operator=(const CastParamBuilder &);
  flatbuffers::Offset<CastParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CastParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<CastParam> CreateCastParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType srcT = DataType_DT_INVALID,
    DataType dstT = DataType_DT_INVALID) {
  CastParamBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

flatbuffers::Offset<CastParam> CreateCastParam(flatbuffers::FlatBufferBuilder &_fbb, const CastParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReductionParamT : public flatbuffers::NativeTable {
  typedef ReductionParam TableType;
  ReductionType operation;
  std::vector<int32_t> dim;
  float coeff;
  bool keepDims;
  DataType dType;
  ReductionParamT()
      : operation(ReductionType_SUM),
        coeff(0.0f),
        keepDims(false),
        dType(DataType_DT_FLOAT) {
  }
};

struct ReductionParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReductionParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReductionParamTypeTable();
  }
  ReductionType operation() const {
    return static_cast<ReductionType>(GetField<int8_t>(4, 0));
  }
  const flatbuffers::Vector<int32_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  float coeff() const {
    return GetField<float>(8, 0.0f);
  }
  bool keepDims() const {
    return GetField<uint8_t>(10, 0) != 0;
  }
  DataType dType() const {
    return static_cast<DataType>(GetField<int32_t>(12, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(dim()) &&
           VerifyField<float>(verifier, 8) &&
           VerifyField<uint8_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           verifier.EndTable();
  }
  ReductionParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReductionParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReductionParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReductionParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReductionParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_operation(ReductionType operation) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(operation), 0);
  }
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim) {
    fbb_.AddOffset(6, dim);
  }
  void add_coeff(float coeff) {
    fbb_.AddElement<float>(8, coeff, 0.0f);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(keepDims), 0);
  }
  void add_dType(DataType dType) {
    fbb_.AddElement<int32_t>(12, static_cast<int32_t>(dType), 1);
  }
  explicit ReductionParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReductionParamBuilder &operator=(const ReductionParamBuilder &);
  flatbuffers::Offset<ReductionParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReductionParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReductionParam> CreateReductionParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ReductionType operation = ReductionType_SUM,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim = 0,
    float coeff = 0.0f,
    bool keepDims = false,
    DataType dType = DataType_DT_FLOAT) {
  ReductionParamBuilder builder_(_fbb);
  builder_.add_dType(dType);
  builder_.add_coeff(coeff);
  builder_.add_dim(dim);
  builder_.add_keepDims(keepDims);
  builder_.add_operation(operation);
  return builder_.Finish();
}

flatbuffers::Offset<ReductionParam> CreateReductionParam(flatbuffers::FlatBufferBuilder &_fbb, const ReductionParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherT : public flatbuffers::NativeTable {
  typedef Gather TableType;
  DataType Tindices;
  DataType Tparams;
  bool validateIndices;
  int32_t axis;
  GatherT()
      : Tindices(DataType_DT_INVALID),
        Tparams(DataType_DT_INVALID),
        validateIndices(false),
        axis(0) {
  }
};

struct Gather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherTypeTable();
  }
  DataType Tindices() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  DataType Tparams() const {
    return static_cast<DataType>(GetField<int32_t>(6, 0));
  }
  bool validateIndices() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  int32_t axis() const {
    return GetField<int32_t>(10, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           verifier.EndTable();
  }
  GatherT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Gather> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Tindices(DataType Tindices) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(Tindices), 0);
  }
  void add_Tparams(DataType Tparams) {
    fbb_.AddElement<int32_t>(6, static_cast<int32_t>(Tparams), 0);
  }
  void add_validateIndices(bool validateIndices) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(validateIndices), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(10, axis, 0);
  }
  explicit GatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherBuilder &operator=(const GatherBuilder &);
  flatbuffers::Offset<Gather> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gather>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gather> CreateGather(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType Tindices = DataType_DT_INVALID,
    DataType Tparams = DataType_DT_INVALID,
    bool validateIndices = false,
    int32_t axis = 0) {
  GatherBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_Tparams(Tparams);
  builder_.add_Tindices(Tindices);
  builder_.add_validateIndices(validateIndices);
  return builder_.Finish();
}

flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsT : public flatbuffers::NativeTable {
  typedef ExpandDims TableType;
  DataType T;
  DataType Tdim;
  int32_t axis;
  ExpandDimsT()
      : T(DataType_DT_INVALID),
        Tdim(DataType_DT_INVALID),
        axis(0) {
  }
};

struct ExpandDims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpandDimsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpandDimsTypeTable();
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  DataType Tdim() const {
    return static_cast<DataType>(GetField<int32_t>(6, 0));
  }
  int32_t axis() const {
    return GetField<int32_t>(8, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           verifier.EndTable();
  }
  ExpandDimsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpandDims> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(T), 0);
  }
  void add_Tdim(DataType Tdim) {
    fbb_.AddElement<int32_t>(6, static_cast<int32_t>(Tdim), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(8, axis, 0);
  }
  explicit ExpandDimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpandDimsBuilder &operator=(const ExpandDimsBuilder &);
  flatbuffers::Offset<ExpandDims> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDims>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID,
    DataType Tdim = DataType_DT_INVALID,
    int32_t axis = 0) {
  ExpandDimsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_Tdim(Tdim);
  builder_.add_T(T);
  return builder_.Finish();
}

flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SeluT : public flatbuffers::NativeTable {
  typedef Selu TableType;
  float scale;
  float alpha;
  SeluT()
      : scale(0.0f),
        alpha(0.0f) {
  }
};

struct Selu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SeluT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SeluTypeTable();
  }
  float scale() const {
    return GetField<float>(4, 0.0f);
  }
  float alpha() const {
    return GetField<float>(6, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           verifier.EndTable();
  }
  SeluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SeluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Selu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SeluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SeluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(4, scale, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(6, alpha, 0.0f);
  }
  explicit SeluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeluBuilder &operator=(const SeluBuilder &);
  flatbuffers::Offset<Selu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Selu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Selu> CreateSelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 0.0f,
    float alpha = 0.0f) {
  SeluBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_scale(scale);
  return builder_.Finish();
}

flatbuffers::Offset<Selu> CreateSelu(flatbuffers::FlatBufferBuilder &_fbb, const SeluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AsStringT : public flatbuffers::NativeTable {
  typedef AsString TableType;
  DataType T;
  int32_t precision;
  bool scientific;
  bool shortest;
  int32_t width;
  std::string fillString;
  AsStringT()
      : T(DataType_DT_INVALID),
        precision(0),
        scientific(false),
        shortest(false),
        width(0) {
  }
};

struct AsString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AsStringT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AsStringTypeTable();
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  int32_t precision() const {
    return GetField<int32_t>(6, 0);
  }
  bool scientific() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool shortest() const {
    return GetField<uint8_t>(10, 0) != 0;
  }
  int32_t width() const {
    return GetField<int32_t>(12, 0);
  }
  const flatbuffers::String *fillString() const {
    return GetPointer<const flatbuffers::String *>(14);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           VerifyField<uint8_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyString(fillString()) &&
           verifier.EndTable();
  }
  AsStringT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AsStringT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AsString> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AsStringT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AsStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(T), 0);
  }
  void add_precision(int32_t precision) {
    fbb_.AddElement<int32_t>(6, precision, 0);
  }
  void add_scientific(bool scientific) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(scientific), 0);
  }
  void add_shortest(bool shortest) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(shortest), 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(12, width, 0);
  }
  void add_fillString(flatbuffers::Offset<flatbuffers::String> fillString) {
    fbb_.AddOffset(14, fillString);
  }
  explicit AsStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AsStringBuilder &operator=(const AsStringBuilder &);
  flatbuffers::Offset<AsString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AsString>(end);
    return o;
  }
};

inline flatbuffers::Offset<AsString> CreateAsString(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID,
    int32_t precision = 0,
    bool scientific = false,
    bool shortest = false,
    int32_t width = 0,
    flatbuffers::Offset<flatbuffers::String> fillString = 0) {
  AsStringBuilder builder_(_fbb);
  builder_.add_fillString(fillString);
  builder_.add_width(width);
  builder_.add_precision(precision);
  builder_.add_T(T);
  builder_.add_shortest(shortest);
  builder_.add_scientific(scientific);
  return builder_.Finish();
}

flatbuffers::Offset<AsString> CreateAsString(flatbuffers::FlatBufferBuilder &_fbb, const AsStringT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceJoinT : public flatbuffers::NativeTable {
  typedef ReduceJoin TableType;
  bool keepDims;
  std::string separator;
  ReduceJoinT()
      : keepDims(false) {
  }
};

struct ReduceJoin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceJoinT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceJoinTypeTable();
  }
  bool keepDims() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  const flatbuffers::String *separator() const {
    return GetPointer<const flatbuffers::String *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyString(separator()) &&
           verifier.EndTable();
  }
  ReduceJoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceJoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceJoin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceJoinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceJoinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(keepDims), 0);
  }
  void add_separator(flatbuffers::Offset<flatbuffers::String> separator) {
    fbb_.AddOffset(6, separator);
  }
  explicit ReduceJoinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReduceJoinBuilder &operator=(const ReduceJoinBuilder &);
  flatbuffers::Offset<ReduceJoin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceJoin>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceJoin> CreateReduceJoin(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keepDims = false,
    flatbuffers::Offset<flatbuffers::String> separator = 0) {
  ReduceJoinBuilder builder_(_fbb);
  builder_.add_separator(separator);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceJoin> CreateReduceJoin(flatbuffers::FlatBufferBuilder &_fbb, const ReduceJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnaryOpT : public flatbuffers::NativeTable {
  typedef UnaryOp TableType;
  UnaryOpOperation opType;
  DataType T;
  UnaryOpT()
      : opType(UnaryOpOperation_ABS),
        T(DataType_DT_INVALID) {
  }
};

struct UnaryOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnaryOpT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnaryOpTypeTable();
  }
  UnaryOpOperation opType() const {
    return static_cast<UnaryOpOperation>(GetField<int32_t>(4, 0));
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(6, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  UnaryOpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnaryOpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnaryOp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnaryOpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opType(UnaryOpOperation opType) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(opType), 0);
  }
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(6, static_cast<int32_t>(T), 0);
  }
  explicit UnaryOpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnaryOpBuilder &operator=(const UnaryOpBuilder &);
  flatbuffers::Offset<UnaryOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnaryOp>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnaryOp> CreateUnaryOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    UnaryOpOperation opType = UnaryOpOperation_ABS,
    DataType T = DataType_DT_INVALID) {
  UnaryOpBuilder builder_(_fbb);
  builder_.add_T(T);
  builder_.add_opType(opType);
  return builder_.Finish();
}

flatbuffers::Offset<UnaryOp> CreateUnaryOp(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKV2T : public flatbuffers::NativeTable {
  typedef TopKV2 TableType;
  DataType T;
  bool sorted;
  bool largest;
  TopKV2T()
      : T(DataType_DT_FLOAT),
        sorted(false),
        largest(true) {
  }
};

struct TopKV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopKV2T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TopKV2TypeTable();
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(4, 1));
  }
  bool sorted() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  bool largest() const {
    return GetField<uint8_t>(8, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  TopKV2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopKV2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopKV2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKV2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(T), 1);
  }
  void add_sorted(bool sorted) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(sorted), 0);
  }
  void add_largest(bool largest) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(largest), 1);
  }
  explicit TopKV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKV2Builder &operator=(const TopKV2Builder &);
  flatbuffers::Offset<TopKV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKV2> CreateTopKV2(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_FLOAT,
    bool sorted = false,
    bool largest = true) {
  TopKV2Builder builder_(_fbb);
  builder_.add_T(T);
  builder_.add_largest(largest);
  builder_.add_sorted(sorted);
  return builder_.Finish();
}

flatbuffers::Offset<TopKV2> CreateTopKV2(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CropAndResizeT : public flatbuffers::NativeTable {
  typedef CropAndResize TableType;
  float extrapolationValue;
  CropAndResizeMethod method;
  CropAndResizeT()
      : extrapolationValue(0.0f),
        method(CropAndResizeMethod_BILINEAR) {
  }
};

struct CropAndResize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CropAndResizeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CropAndResizeTypeTable();
  }
  float extrapolationValue() const {
    return GetField<float>(4, 0.0f);
  }
  CropAndResizeMethod method() const {
    return static_cast<CropAndResizeMethod>(GetField<int8_t>(6, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<int8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  CropAndResizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CropAndResizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CropAndResize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CropAndResizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_extrapolationValue(float extrapolationValue) {
    fbb_.AddElement<float>(4, extrapolationValue, 0.0f);
  }
  void add_method(CropAndResizeMethod method) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(method), 0);
  }
  explicit CropAndResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CropAndResizeBuilder &operator=(const CropAndResizeBuilder &);
  flatbuffers::Offset<CropAndResize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CropAndResize>(end);
    return o;
  }
};

inline flatbuffers::Offset<CropAndResize> CreateCropAndResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    float extrapolationValue = 0.0f,
    CropAndResizeMethod method = CropAndResizeMethod_BILINEAR) {
  CropAndResizeBuilder builder_(_fbb);
  builder_.add_extrapolationValue(extrapolationValue);
  builder_.add_method(method);
  return builder_.Finish();
}

flatbuffers::Offset<CropAndResize> CreateCropAndResize(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillT : public flatbuffers::NativeTable {
  typedef Fill TableType;
  FillT() {
  }
};

struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FillT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FillTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FillT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FillT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Fill> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillBuilder &operator=(const FillBuilder &);
  flatbuffers::Offset<Fill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fill> CreateFill(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FillBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Fill> CreateFill(flatbuffers::FlatBufferBuilder &_fbb, const FillT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherV2T : public flatbuffers::NativeTable {
  typedef GatherV2 TableType;
  DataType Taxis;
  DataType Tindices;
  DataType Tparams;
  GatherV2T()
      : Taxis(DataType_DT_INVALID),
        Tindices(DataType_DT_INVALID),
        Tparams(DataType_DT_INVALID) {
  }
};

struct GatherV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherV2T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherV2TypeTable();
  }
  DataType Taxis() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  DataType Tindices() const {
    return static_cast<DataType>(GetField<int32_t>(6, 0));
  }
  DataType Tparams() const {
    return static_cast<DataType>(GetField<int32_t>(8, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           verifier.EndTable();
  }
  GatherV2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherV2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherV2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherV2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherV2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Taxis(DataType Taxis) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(Taxis), 0);
  }
  void add_Tindices(DataType Tindices) {
    fbb_.AddElement<int32_t>(6, static_cast<int32_t>(Tindices), 0);
  }
  void add_Tparams(DataType Tparams) {
    fbb_.AddElement<int32_t>(8, static_cast<int32_t>(Tparams), 0);
  }
  explicit GatherV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherV2Builder &operator=(const GatherV2Builder &);
  flatbuffers::Offset<GatherV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherV2> CreateGatherV2(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType Taxis = DataType_DT_INVALID,
    DataType Tindices = DataType_DT_INVALID,
    DataType Tparams = DataType_DT_INVALID) {
  GatherV2Builder builder_(_fbb);
  builder_.add_Tparams(Tparams);
  builder_.add_Tindices(Tindices);
  builder_.add_Taxis(Taxis);
  return builder_.Finish();
}

flatbuffers::Offset<GatherV2> CreateGatherV2(flatbuffers::FlatBufferBuilder &_fbb, const GatherV2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV2T : public flatbuffers::NativeTable {
  typedef NonMaxSuppressionV2 TableType;
  NonMaxSuppressionV2T() {
  }
};

struct NonMaxSuppressionV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonMaxSuppressionV2T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NonMaxSuppressionV2TypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NonMaxSuppressionV2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionV2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonMaxSuppressionV2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionV2Builder &operator=(const NonMaxSuppressionV2Builder &);
  flatbuffers::Offset<NonMaxSuppressionV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV2> CreateNonMaxSuppressionV2(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV2Builder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppressionV2> CreateNonMaxSuppressionV2(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeT : public flatbuffers::NativeTable {
  typedef Range TableType;
  DataType Tidx;
  RangeT()
      : Tidx(DataType_DT_INVALID) {
  }
};

struct Range FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RangeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RangeTypeTable();
  }
  DataType Tidx() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  RangeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Range> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Tidx(DataType Tidx) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(Tidx), 0);
  }
  explicit RangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeBuilder &operator=(const RangeBuilder &);
  flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline flatbuffers::Offset<Range> CreateRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType Tidx = DataType_DT_INVALID) {
  RangeBuilder builder_(_fbb);
  builder_.add_Tidx(Tidx);
  return builder_.Finish();
}

flatbuffers::Offset<Range> CreateRange(flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RankT : public flatbuffers::NativeTable {
  typedef Rank TableType;
  RankT() {
  }
};

struct Rank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RankT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RankTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RankT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RankT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rank> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RankBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankBuilder &operator=(const RankBuilder &);
  flatbuffers::Offset<Rank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rank>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rank> CreateRank(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Rank> CreateRank(flatbuffers::FlatBufferBuilder &_fbb, const RankT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SizeT : public flatbuffers::NativeTable {
  typedef Size TableType;
  DataType outputDataType;
  SizeT()
      : outputDataType(DataType_DT_INVALID) {
  }
};

struct Size FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SizeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SizeTypeTable();
  }
  DataType outputDataType() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  SizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Size> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputDataType(DataType outputDataType) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(outputDataType), 0);
  }
  explicit SizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SizeBuilder &operator=(const SizeBuilder &);
  flatbuffers::Offset<Size> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Size>(end);
    return o;
  }
};

inline flatbuffers::Offset<Size> CreateSize(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType outputDataType = DataType_DT_INVALID) {
  SizeBuilder builder_(_fbb);
  builder_.add_outputDataType(outputDataType);
  return builder_.Finish();
}

flatbuffers::Offset<Size> CreateSize(flatbuffers::FlatBufferBuilder &_fbb, const SizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeT : public flatbuffers::NativeTable {
  typedef Transpose TableType;
  DataType Tperm;
  TransposeT()
      : Tperm(DataType_DT_INVALID) {
  }
};

struct Transpose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransposeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransposeTypeTable();
  }
  DataType Tperm() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  TransposeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transpose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Tperm(DataType Tperm) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(Tperm), 0);
  }
  explicit TransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeBuilder &operator=(const TransposeBuilder &);
  flatbuffers::Offset<Transpose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transpose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transpose> CreateTranspose(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType Tperm = DataType_DT_INVALID) {
  TransposeBuilder builder_(_fbb);
  builder_.add_Tperm(Tperm);
  return builder_.Finish();
}

flatbuffers::Offset<Transpose> CreateTranspose(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceTfT : public flatbuffers::NativeTable {
  typedef SliceTf TableType;
  DataType T;
  SliceTfT()
      : T(DataType_DT_INVALID) {
  }
};

struct SliceTf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceTfT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SliceTfTypeTable();
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  SliceTfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceTfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SliceTf> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceTfT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceTfBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(T), 0);
  }
  explicit SliceTfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceTfBuilder &operator=(const SliceTfBuilder &);
  flatbuffers::Offset<SliceTf> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceTf>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceTf> CreateSliceTf(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID) {
  SliceTfBuilder builder_(_fbb);
  builder_.add_T(T);
  return builder_.Finish();
}

flatbuffers::Offset<SliceTf> CreateSliceTf(flatbuffers::FlatBufferBuilder &_fbb, const SliceTfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizeMaxMinT : public flatbuffers::NativeTable {
  typedef QuantizeMaxMin TableType;
  DataType T;
  QuantizeMaxMinT()
      : T(DataType_DT_INVALID) {
  }
};

struct QuantizeMaxMin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizeMaxMinT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantizeMaxMinTypeTable();
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  QuantizeMaxMinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizeMaxMinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizeMaxMin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeMaxMinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizeMaxMinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(T), 0);
  }
  explicit QuantizeMaxMinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizeMaxMinBuilder &operator=(const QuantizeMaxMinBuilder &);
  flatbuffers::Offset<QuantizeMaxMin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizeMaxMin>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizeMaxMin> CreateQuantizeMaxMin(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID) {
  QuantizeMaxMinBuilder builder_(_fbb);
  builder_.add_T(T);
  return builder_.Finish();
}

flatbuffers::Offset<QuantizeMaxMin> CreateQuantizeMaxMin(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeMaxMinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CropT : public flatbuffers::NativeTable {
  typedef Crop TableType;
  int32_t axis;
  std::vector<int32_t> offset;
  CropT()
      : axis(2) {
  }
};

struct Crop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CropT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CropTypeTable();
  }
  int32_t axis() const {
    return GetField<int32_t>(4, 2);
  }
  const flatbuffers::Vector<int32_t> *offset() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(offset()) &&
           verifier.EndTable();
  }
  CropT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CropT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Crop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CropBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(4, axis, 2);
  }
  void add_offset(flatbuffers::Offset<flatbuffers::Vector<int32_t>> offset) {
    fbb_.AddOffset(6, offset);
  }
  explicit CropBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CropBuilder &operator=(const CropBuilder &);
  flatbuffers::Offset<Crop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Crop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Crop> CreateCrop(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 2,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> offset = 0) {
  CropBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Crop> CreateCrop(flatbuffers::FlatBufferBuilder &_fbb, const CropT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceBatchT : public flatbuffers::NativeTable {
  typedef SpaceBatch TableType;
  std::unique_ptr<BlobT> blockShape;
  std::unique_ptr<BlobT> padding;
  SpaceBatchT() {
  }
};

struct SpaceBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceBatchT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpaceBatchTypeTable();
  }
  const Blob *blockShape() const {
    return GetPointer<const Blob *>(4);
  }
  const Blob *padding() const {
    return GetPointer<const Blob *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyTable(blockShape()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyTable(padding()) &&
           verifier.EndTable();
  }
  SpaceBatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceBatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceBatch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceBatchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceBatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<Blob> blockShape) {
    fbb_.AddOffset(4, blockShape);
  }
  void add_padding(flatbuffers::Offset<Blob> padding) {
    fbb_.AddOffset(6, padding);
  }
  explicit SpaceBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceBatchBuilder &operator=(const SpaceBatchBuilder &);
  flatbuffers::Offset<SpaceBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceBatch> CreateSpaceBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Blob> blockShape = 0,
    flatbuffers::Offset<Blob> padding = 0) {
  SpaceBatchBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceBatch> CreateSpaceBatch(flatbuffers::FlatBufferBuilder &_fbb, const SpaceBatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatMulT : public flatbuffers::NativeTable {
  typedef MatMul TableType;
  DataType T;
  bool transposeA;
  bool transposeB;
  std::vector<float> weight;
  std::vector<float> bias;
  MatMulT()
      : T(DataType_DT_INVALID),
        transposeA(false),
        transposeB(false) {
  }
};

struct MatMul FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatMulT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MatMulTypeTable();
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(4, 0));
  }
  bool transposeA() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  bool transposeB() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(12);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(bias()) &&
           verifier.EndTable();
  }
  MatMulT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatMulT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatMul> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatMulBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(T), 0);
  }
  void add_transposeA(bool transposeA) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(transposeA), 0);
  }
  void add_transposeB(bool transposeB) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(transposeB), 0);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(10, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(12, bias);
  }
  explicit MatMulBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatMulBuilder &operator=(const MatMulBuilder &);
  flatbuffers::Offset<MatMul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatMul>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatMul> CreateMatMul(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID,
    bool transposeA = false,
    bool transposeB = false,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0) {
  MatMulBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_T(T);
  builder_.add_transposeB(transposeB);
  builder_.add_transposeA(transposeA);
  return builder_.Finish();
}

flatbuffers::Offset<MatMul> CreateMatMul(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MomentsParamT : public flatbuffers::NativeTable {
  typedef MomentsParam TableType;
  std::vector<int32_t> dim;
  bool keepDims;
  DataType dType;
  MomentsParamT()
      : keepDims(true),
        dType(DataType_DT_FLOAT) {
  }
};

struct MomentsParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MomentsParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MomentsParamTypeTable();
  }
  const flatbuffers::Vector<int32_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  bool keepDims() const {
    return GetField<uint8_t>(6, 1) != 0;
  }
  DataType dType() const {
    return static_cast<DataType>(GetField<int32_t>(8, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(dim()) &&
           VerifyField<uint8_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           verifier.EndTable();
  }
  MomentsParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MomentsParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MomentsParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MomentsParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MomentsParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim) {
    fbb_.AddOffset(4, dim);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(keepDims), 1);
  }
  void add_dType(DataType dType) {
    fbb_.AddElement<int32_t>(8, static_cast<int32_t>(dType), 1);
  }
  explicit MomentsParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MomentsParamBuilder &operator=(const MomentsParamBuilder &);
  flatbuffers::Offset<MomentsParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MomentsParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<MomentsParam> CreateMomentsParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim = 0,
    bool keepDims = true,
    DataType dType = DataType_DT_FLOAT) {
  MomentsParamBuilder builder_(_fbb);
  builder_.add_dType(dType);
  builder_.add_dim(dim);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

flatbuffers::Offset<MomentsParam> CreateMomentsParam(flatbuffers::FlatBufferBuilder &_fbb, const MomentsParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RNNParamT : public flatbuffers::NativeTable {
  typedef RNNParam TableType;
  int32_t numUnits;
  bool isBidirectionalRNN;
  bool linearBeforeReset;
  bool keepAllOutputs;
  std::unique_ptr<BlobT> fwGateWeight;
  std::unique_ptr<BlobT> fwGateBias;
  std::unique_ptr<BlobT> fwCandidateWeight;
  std::unique_ptr<BlobT> fwCandidateBias;
  std::unique_ptr<BlobT> fwRecurrentBias;
  std::unique_ptr<BlobT> bwGateWeight;
  std::unique_ptr<BlobT> bwGateBias;
  std::unique_ptr<BlobT> bwCandidateWeight;
  std::unique_ptr<BlobT> bwCandidateBias;
  std::unique_ptr<BlobT> bwRecurrentBias;
  RNNParamT()
      : numUnits(0),
        isBidirectionalRNN(false),
        linearBeforeReset(false),
        keepAllOutputs(false) {
  }
};

struct RNNParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RNNParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RNNParamTypeTable();
  }
  int32_t numUnits() const {
    return GetField<int32_t>(4, 0);
  }
  bool isBidirectionalRNN() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  bool linearBeforeReset() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool keepAllOutputs() const {
    return GetField<uint8_t>(10, 0) != 0;
  }
  const Blob *fwGateWeight() const {
    return GetPointer<const Blob *>(12);
  }
  const Blob *fwGateBias() const {
    return GetPointer<const Blob *>(14);
  }
  const Blob *fwCandidateWeight() const {
    return GetPointer<const Blob *>(16);
  }
  const Blob *fwCandidateBias() const {
    return GetPointer<const Blob *>(18);
  }
  const Blob *fwRecurrentBias() const {
    return GetPointer<const Blob *>(20);
  }
  const Blob *bwGateWeight() const {
    return GetPointer<const Blob *>(22);
  }
  const Blob *bwGateBias() const {
    return GetPointer<const Blob *>(24);
  }
  const Blob *bwCandidateWeight() const {
    return GetPointer<const Blob *>(26);
  }
  const Blob *bwCandidateBias() const {
    return GetPointer<const Blob *>(28);
  }
  const Blob *bwRecurrentBias() const {
    return GetPointer<const Blob *>(30);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           VerifyField<uint8_t>(verifier, 10) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyTable(fwGateWeight()) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyTable(fwGateBias()) &&
           VerifyOffset(verifier, 16) &&
           verifier.VerifyTable(fwCandidateWeight()) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyTable(fwCandidateBias()) &&
           VerifyOffset(verifier, 20) &&
           verifier.VerifyTable(fwRecurrentBias()) &&
           VerifyOffset(verifier, 22) &&
           verifier.VerifyTable(bwGateWeight()) &&
           VerifyOffset(verifier, 24) &&
           verifier.VerifyTable(bwGateBias()) &&
           VerifyOffset(verifier, 26) &&
           verifier.VerifyTable(bwCandidateWeight()) &&
           VerifyOffset(verifier, 28) &&
           verifier.VerifyTable(bwCandidateBias()) &&
           VerifyOffset(verifier, 30) &&
           verifier.VerifyTable(bwRecurrentBias()) &&
           verifier.EndTable();
  }
  RNNParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RNNParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RNNParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RNNParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numUnits(int32_t numUnits) {
    fbb_.AddElement<int32_t>(4, numUnits, 0);
  }
  void add_isBidirectionalRNN(bool isBidirectionalRNN) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(isBidirectionalRNN), 0);
  }
  void add_linearBeforeReset(bool linearBeforeReset) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(linearBeforeReset), 0);
  }
  void add_keepAllOutputs(bool keepAllOutputs) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(keepAllOutputs), 0);
  }
  void add_fwGateWeight(flatbuffers::Offset<Blob> fwGateWeight) {
    fbb_.AddOffset(12, fwGateWeight);
  }
  void add_fwGateBias(flatbuffers::Offset<Blob> fwGateBias) {
    fbb_.AddOffset(14, fwGateBias);
  }
  void add_fwCandidateWeight(flatbuffers::Offset<Blob> fwCandidateWeight) {
    fbb_.AddOffset(16, fwCandidateWeight);
  }
  void add_fwCandidateBias(flatbuffers::Offset<Blob> fwCandidateBias) {
    fbb_.AddOffset(18, fwCandidateBias);
  }
  void add_fwRecurrentBias(flatbuffers::Offset<Blob> fwRecurrentBias) {
    fbb_.AddOffset(20, fwRecurrentBias);
  }
  void add_bwGateWeight(flatbuffers::Offset<Blob> bwGateWeight) {
    fbb_.AddOffset(22, bwGateWeight);
  }
  void add_bwGateBias(flatbuffers::Offset<Blob> bwGateBias) {
    fbb_.AddOffset(24, bwGateBias);
  }
  void add_bwCandidateWeight(flatbuffers::Offset<Blob> bwCandidateWeight) {
    fbb_.AddOffset(26, bwCandidateWeight);
  }
  void add_bwCandidateBias(flatbuffers::Offset<Blob> bwCandidateBias) {
    fbb_.AddOffset(28, bwCandidateBias);
  }
  void add_bwRecurrentBias(flatbuffers::Offset<Blob> bwRecurrentBias) {
    fbb_.AddOffset(30, bwRecurrentBias);
  }
  explicit RNNParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RNNParamBuilder &operator=(const RNNParamBuilder &);
  flatbuffers::Offset<RNNParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RNNParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<RNNParam> CreateRNNParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numUnits = 0,
    bool isBidirectionalRNN = false,
    bool linearBeforeReset = false,
    bool keepAllOutputs = false,
    flatbuffers::Offset<Blob> fwGateWeight = 0,
    flatbuffers::Offset<Blob> fwGateBias = 0,
    flatbuffers::Offset<Blob> fwCandidateWeight = 0,
    flatbuffers::Offset<Blob> fwCandidateBias = 0,
    flatbuffers::Offset<Blob> fwRecurrentBias = 0,
    flatbuffers::Offset<Blob> bwGateWeight = 0,
    flatbuffers::Offset<Blob> bwGateBias = 0,
    flatbuffers::Offset<Blob> bwCandidateWeight = 0,
    flatbuffers::Offset<Blob> bwCandidateBias = 0,
    flatbuffers::Offset<Blob> bwRecurrentBias = 0) {
  RNNParamBuilder builder_(_fbb);
  builder_.add_bwRecurrentBias(bwRecurrentBias);
  builder_.add_bwCandidateBias(bwCandidateBias);
  builder_.add_bwCandidateWeight(bwCandidateWeight);
  builder_.add_bwGateBias(bwGateBias);
  builder_.add_bwGateWeight(bwGateWeight);
  builder_.add_fwRecurrentBias(fwRecurrentBias);
  builder_.add_fwCandidateBias(fwCandidateBias);
  builder_.add_fwCandidateWeight(fwCandidateWeight);
  builder_.add_fwGateBias(fwGateBias);
  builder_.add_fwGateWeight(fwGateWeight);
  builder_.add_numUnits(numUnits);
  builder_.add_keepAllOutputs(keepAllOutputs);
  builder_.add_linearBeforeReset(linearBeforeReset);
  builder_.add_isBidirectionalRNN(isBidirectionalRNN);
  return builder_.Finish();
}

flatbuffers::Offset<RNNParam> CreateRNNParam(flatbuffers::FlatBufferBuilder &_fbb, const RNNParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchMatMulParamT : public flatbuffers::NativeTable {
  typedef BatchMatMulParam TableType;
  bool adjX;
  bool adjY;
  BatchMatMulParamT()
      : adjX(false),
        adjY(false) {
  }
};

struct BatchMatMulParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchMatMulParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchMatMulParamTypeTable();
  }
  bool adjX() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  bool adjY() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  BatchMatMulParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchMatMulParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchMatMulParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchMatMulParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_adjX(bool adjX) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(adjX), 0);
  }
  void add_adjY(bool adjY) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(adjY), 0);
  }
  explicit BatchMatMulParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchMatMulParamBuilder &operator=(const BatchMatMulParamBuilder &);
  flatbuffers::Offset<BatchMatMulParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchMatMulParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchMatMulParam> CreateBatchMatMulParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool adjX = false,
    bool adjY = false) {
  BatchMatMulParamBuilder builder_(_fbb);
  builder_.add_adjY(adjY);
  builder_.add_adjX(adjX);
  return builder_.Finish();
}

flatbuffers::Offset<BatchMatMulParam> CreateBatchMatMulParam(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthSpaceParamT : public flatbuffers::NativeTable {
  typedef DepthSpaceParam TableType;
  int32_t blockSize;
  DepthToSpaceMode mode;
  DepthSpaceParamT()
      : blockSize(0),
        mode(DepthToSpaceMode_DCR) {
  }
};

struct DepthSpaceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepthSpaceParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DepthSpaceParamTypeTable();
  }
  int32_t blockSize() const {
    return GetField<int32_t>(4, 0);
  }
  DepthToSpaceMode mode() const {
    return static_cast<DepthToSpaceMode>(GetField<int8_t>(6, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  DepthSpaceParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthSpaceParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthSpaceParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthSpaceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthSpaceParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockSize(int32_t blockSize) {
    fbb_.AddElement<int32_t>(4, blockSize, 0);
  }
  void add_mode(DepthToSpaceMode mode) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(mode), 0);
  }
  explicit DepthSpaceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthSpaceParamBuilder &operator=(const DepthSpaceParamBuilder &);
  flatbuffers::Offset<DepthSpaceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthSpaceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthSpaceParam> CreateDepthSpaceParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t blockSize = 0,
    DepthToSpaceMode mode = DepthToSpaceMode_DCR) {
  DepthSpaceParamBuilder builder_(_fbb);
  builder_.add_blockSize(blockSize);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<DepthSpaceParam> CreateDepthSpaceParam(flatbuffers::FlatBufferBuilder &_fbb, const DepthSpaceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseSequenceParamT : public flatbuffers::NativeTable {
  typedef ReverseSequenceParam TableType;
  int32_t batchDim;
  int32_t seqDim;
  ReverseSequenceParamT()
      : batchDim(0),
        seqDim(0) {
  }
};

struct ReverseSequenceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReverseSequenceParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReverseSequenceParamTypeTable();
  }
  int32_t batchDim() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t seqDim() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  ReverseSequenceParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseSequenceParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReverseSequenceParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseSequenceParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_batchDim(int32_t batchDim) {
    fbb_.AddElement<int32_t>(4, batchDim, 0);
  }
  void add_seqDim(int32_t seqDim) {
    fbb_.AddElement<int32_t>(6, seqDim, 0);
  }
  explicit ReverseSequenceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseSequenceParamBuilder &operator=(const ReverseSequenceParamBuilder &);
  flatbuffers::Offset<ReverseSequenceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequenceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequenceParam> CreateReverseSequenceParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batchDim = 0,
    int32_t seqDim = 0) {
  ReverseSequenceParamBuilder builder_(_fbb);
  builder_.add_seqDim(seqDim);
  builder_.add_batchDim(batchDim);
  return builder_.Finish();
}

flatbuffers::Offset<ReverseSequenceParam> CreateReverseSequenceParam(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionPostProcessParamT : public flatbuffers::NativeTable {
  typedef DetectionPostProcessParam TableType;
  int32_t maxDetections;
  int32_t maxClassesPerDetection;
  int32_t detectionsPerClass;
  float nmsScoreThreshold;
  float iouThreshold;
  int32_t numClasses;
  bool useRegularNMS;
  std::vector<float> centerSizeEncoding;
  DetectionPostProcessParamT()
      : maxDetections(0),
        maxClassesPerDetection(0),
        detectionsPerClass(0),
        nmsScoreThreshold(0.0f),
        iouThreshold(0.0f),
        numClasses(0),
        useRegularNMS(false) {
  }
};

struct DetectionPostProcessParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionPostProcessParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DetectionPostProcessParamTypeTable();
  }
  int32_t maxDetections() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t maxClassesPerDetection() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t detectionsPerClass() const {
    return GetField<int32_t>(8, 0);
  }
  float nmsScoreThreshold() const {
    return GetField<float>(10, 0.0f);
  }
  float iouThreshold() const {
    return GetField<float>(12, 0.0f);
  }
  int32_t numClasses() const {
    return GetField<int32_t>(14, 0);
  }
  bool useRegularNMS() const {
    return GetField<uint8_t>(16, 0) != 0;
  }
  const flatbuffers::Vector<float> *centerSizeEncoding() const {
    return GetPointer<const flatbuffers::Vector<float> *>(18);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<float>(verifier, 10) &&
           VerifyField<float>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<uint8_t>(verifier, 16) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyVector(centerSizeEncoding()) &&
           verifier.EndTable();
  }
  DetectionPostProcessParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionPostProcessParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectionPostProcessParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionPostProcessParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maxDetections(int32_t maxDetections) {
    fbb_.AddElement<int32_t>(4, maxDetections, 0);
  }
  void add_maxClassesPerDetection(int32_t maxClassesPerDetection) {
    fbb_.AddElement<int32_t>(6, maxClassesPerDetection, 0);
  }
  void add_detectionsPerClass(int32_t detectionsPerClass) {
    fbb_.AddElement<int32_t>(8, detectionsPerClass, 0);
  }
  void add_nmsScoreThreshold(float nmsScoreThreshold) {
    fbb_.AddElement<float>(10, nmsScoreThreshold, 0.0f);
  }
  void add_iouThreshold(float iouThreshold) {
    fbb_.AddElement<float>(12, iouThreshold, 0.0f);
  }
  void add_numClasses(int32_t numClasses) {
    fbb_.AddElement<int32_t>(14, numClasses, 0);
  }
  void add_useRegularNMS(bool useRegularNMS) {
    fbb_.AddElement<uint8_t>(16, static_cast<uint8_t>(useRegularNMS), 0);
  }
  void add_centerSizeEncoding(flatbuffers::Offset<flatbuffers::Vector<float>> centerSizeEncoding) {
    fbb_.AddOffset(18, centerSizeEncoding);
  }
  explicit DetectionPostProcessParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DetectionPostProcessParamBuilder &operator=(const DetectionPostProcessParamBuilder &);
  flatbuffers::Offset<DetectionPostProcessParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionPostProcessParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionPostProcessParam> CreateDetectionPostProcessParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t maxDetections = 0,
    int32_t maxClassesPerDetection = 0,
    int32_t detectionsPerClass = 0,
    float nmsScoreThreshold = 0.0f,
    float iouThreshold = 0.0f,
    int32_t numClasses = 0,
    bool useRegularNMS = false,
    flatbuffers::Offset<flatbuffers::Vector<float>> centerSizeEncoding = 0) {
  DetectionPostProcessParamBuilder builder_(_fbb);
  builder_.add_centerSizeEncoding(centerSizeEncoding);
  builder_.add_numClasses(numClasses);
  builder_.add_iouThreshold(iouThreshold);
  builder_.add_nmsScoreThreshold(nmsScoreThreshold);
  builder_.add_detectionsPerClass(detectionsPerClass);
  builder_.add_maxClassesPerDetection(maxClassesPerDetection);
  builder_.add_maxDetections(maxDetections);
  builder_.add_useRegularNMS(useRegularNMS);
  return builder_.Finish();
}

flatbuffers::Offset<DetectionPostProcessParam> CreateDetectionPostProcessParam(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotParamT : public flatbuffers::NativeTable {
  typedef OneHotParam TableType;
  DataType dType;
  int32_t axis;
  OneHotParamT()
      : dType(DataType_DT_FLOAT),
        axis(-1) {
  }
};

struct OneHotParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OneHotParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OneHotParamTypeTable();
  }
  DataType dType() const {
    return static_cast<DataType>(GetField<int32_t>(4, 1));
  }
  int32_t axis() const {
    return GetField<int32_t>(6, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  OneHotParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OneHotParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OneHotParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dType(DataType dType) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(dType), 1);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(6, axis, -1);
  }
  explicit OneHotParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneHotParamBuilder &operator=(const OneHotParamBuilder &);
  flatbuffers::Offset<OneHotParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHotParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHotParam> CreateOneHotParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType dType = DataType_DT_FLOAT,
    int32_t axis = -1) {
  OneHotParamBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_dType(dType);
  return builder_.Finish();
}

flatbuffers::Offset<OneHotParam> CreateOneHotParam(flatbuffers::FlatBufferBuilder &_fbb, const OneHotParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadParamT : public flatbuffers::NativeTable {
  typedef PadParam TableType;
  PadValueMode mode;
  PadParamT()
      : mode(PadValueMode_CONSTANT) {
  }
};

struct PadParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PadParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PadParamTypeTable();
  }
  PadValueMode mode() const {
    return static_cast<PadValueMode>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  PadParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PadParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(PadValueMode mode) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(mode), 0);
  }
  explicit PadParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadParamBuilder &operator=(const PadParamBuilder &);
  flatbuffers::Offset<PadParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadParam> CreatePadParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    PadValueMode mode = PadValueMode_CONSTANT) {
  PadParamBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<PadParam> CreatePadParam(flatbuffers::FlatBufferBuilder &_fbb, const PadParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LayerNormT : public flatbuffers::NativeTable {
  typedef LayerNorm TableType;
  std::vector<int32_t> axis;
  float epsilon;
  std::vector<float> gamma;
  std::vector<float> beta;
  int32_t group;
  std::vector<int64_t> external;
  LayerNormT()
      : epsilon(0.0f),
        group(1) {
  }
};

struct LayerNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerNormT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LayerNormTypeTable();
  }
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  float epsilon() const {
    return GetField<float>(6, 0.0f);
  }
  const flatbuffers::Vector<float> *gamma() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  const flatbuffers::Vector<float> *beta() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  int32_t group() const {
    return GetField<int32_t>(12, 1);
  }
  const flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(14);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<float>(verifier, 6) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(gamma()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(beta()) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
  LayerNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LayerNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LayerNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LayerNormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(4, axis);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(6, epsilon, 0.0f);
  }
  void add_gamma(flatbuffers::Offset<flatbuffers::Vector<float>> gamma) {
    fbb_.AddOffset(8, gamma);
  }
  void add_beta(flatbuffers::Offset<flatbuffers::Vector<float>> beta) {
    fbb_.AddOffset(10, beta);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(12, group, 1);
  }
  void add_external(flatbuffers::Offset<flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(14, external);
  }
  explicit LayerNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LayerNormBuilder &operator=(const LayerNormBuilder &);
  flatbuffers::Offset<LayerNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerNorm> CreateLayerNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0,
    float epsilon = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> gamma = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> beta = 0,
    int32_t group = 1,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> external = 0) {
  LayerNormBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_group(group);
  builder_.add_beta(beta);
  builder_.add_gamma(gamma);
  builder_.add_epsilon(epsilon);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<LayerNorm> CreateLayerNorm(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomUniformT : public flatbuffers::NativeTable {
  typedef RandomUniform TableType;
  int32_t seed;
  int32_t seed2;
  DataType type;
  float low;
  float high;
  RandomUniformT()
      : seed(0),
        seed2(0),
        type(DataType_DT_FLOAT),
        low(0.0f),
        high(1.0f) {
  }
};

struct RandomUniform FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RandomUniformT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RandomUniformTypeTable();
  }
  int32_t seed() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t seed2() const {
    return GetField<int32_t>(6, 0);
  }
  DataType type() const {
    return static_cast<DataType>(GetField<int32_t>(8, 1));
  }
  float low() const {
    return GetField<float>(10, 0.0f);
  }
  float high() const {
    return GetField<float>(12, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<float>(verifier, 10) &&
           VerifyField<float>(verifier, 12) &&
           verifier.EndTable();
  }
  RandomUniformT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomUniformT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RandomUniform> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomUniformT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomUniformBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(int32_t seed) {
    fbb_.AddElement<int32_t>(4, seed, 0);
  }
  void add_seed2(int32_t seed2) {
    fbb_.AddElement<int32_t>(6, seed2, 0);
  }
  void add_type(DataType type) {
    fbb_.AddElement<int32_t>(8, static_cast<int32_t>(type), 1);
  }
  void add_low(float low) {
    fbb_.AddElement<float>(10, low, 0.0f);
  }
  void add_high(float high) {
    fbb_.AddElement<float>(12, high, 1.0f);
  }
  explicit RandomUniformBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RandomUniformBuilder &operator=(const RandomUniformBuilder &);
  flatbuffers::Offset<RandomUniform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RandomUniform>(end);
    return o;
  }
};

inline flatbuffers::Offset<RandomUniform> CreateRandomUniform(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seed = 0,
    int32_t seed2 = 0,
    DataType type = DataType_DT_FLOAT,
    float low = 0.0f,
    float high = 1.0f) {
  RandomUniformBuilder builder_(_fbb);
  builder_.add_high(high);
  builder_.add_low(low);
  builder_.add_type(type);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

flatbuffers::Offset<RandomUniform> CreateRandomUniform(flatbuffers::FlatBufferBuilder &_fbb, const RandomUniformT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorArrayT : public flatbuffers::NativeTable {
  typedef TensorArray TableType;
  bool dynamic_size;
  bool identical_element_shapes;
  std::vector<int32_t> element_shape;
  DataType T;
  int32_t axis;
  bool keepdims;
  bool new_axis;
  TensorArrayT()
      : dynamic_size(false),
        identical_element_shapes(false),
        T(DataType_DT_FLOAT),
        axis(0),
        keepdims(true),
        new_axis(false) {
  }
};

struct TensorArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorArrayT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorArrayTypeTable();
  }
  bool dynamic_size() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  bool identical_element_shapes() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *element_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(10, 1));
  }
  int32_t axis() const {
    return GetField<int32_t>(12, 0);
  }
  bool keepdims() const {
    return GetField<uint8_t>(14, 1) != 0;
  }
  bool new_axis() const {
    return GetField<uint8_t>(16, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(element_shape()) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyField<uint8_t>(verifier, 14) &&
           VerifyField<uint8_t>(verifier, 16) &&
           verifier.EndTable();
  }
  TensorArrayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorArrayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorArray> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dynamic_size(bool dynamic_size) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(dynamic_size), 0);
  }
  void add_identical_element_shapes(bool identical_element_shapes) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(identical_element_shapes), 0);
  }
  void add_element_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_shape) {
    fbb_.AddOffset(8, element_shape);
  }
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(10, static_cast<int32_t>(T), 1);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(12, axis, 0);
  }
  void add_keepdims(bool keepdims) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(keepdims), 1);
  }
  void add_new_axis(bool new_axis) {
    fbb_.AddElement<uint8_t>(16, static_cast<uint8_t>(new_axis), 0);
  }
  explicit TensorArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorArrayBuilder &operator=(const TensorArrayBuilder &);
  flatbuffers::Offset<TensorArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorArray> CreateTensorArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool dynamic_size = false,
    bool identical_element_shapes = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_shape = 0,
    DataType T = DataType_DT_FLOAT,
    int32_t axis = 0,
    bool keepdims = true,
    bool new_axis = false) {
  TensorArrayBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_T(T);
  builder_.add_element_shape(element_shape);
  builder_.add_new_axis(new_axis);
  builder_.add_keepdims(keepdims);
  builder_.add_identical_element_shapes(identical_element_shapes);
  builder_.add_dynamic_size(dynamic_size);
  return builder_.Finish();
}

flatbuffers::Offset<TensorArray> CreateTensorArray(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMBlockCellT : public flatbuffers::NativeTable {
  typedef LSTMBlockCell TableType;
  float cell_clip;
  float forget_bias;
  bool use_peephole;
  LSTMBlockCellT()
      : cell_clip(3.0f),
        forget_bias(1.0f),
        use_peephole(false) {
  }
};

struct LSTMBlockCell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMBlockCellT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LSTMBlockCellTypeTable();
  }
  float cell_clip() const {
    return GetField<float>(4, 3.0f);
  }
  float forget_bias() const {
    return GetField<float>(6, 1.0f);
  }
  bool use_peephole() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  LSTMBlockCellT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMBlockCellT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSTMBlockCell> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMBlockCellT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMBlockCellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(4, cell_clip, 3.0f);
  }
  void add_forget_bias(float forget_bias) {
    fbb_.AddElement<float>(6, forget_bias, 1.0f);
  }
  void add_use_peephole(bool use_peephole) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(use_peephole), 0);
  }
  explicit LSTMBlockCellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSTMBlockCellBuilder &operator=(const LSTMBlockCellBuilder &);
  flatbuffers::Offset<LSTMBlockCell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMBlockCell>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMBlockCell> CreateLSTMBlockCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    float cell_clip = 3.0f,
    float forget_bias = 1.0f,
    bool use_peephole = false) {
  LSTMBlockCellBuilder builder_(_fbb);
  builder_.add_forget_bias(forget_bias);
  builder_.add_cell_clip(cell_clip);
  builder_.add_use_peephole(use_peephole);
  return builder_.Finish();
}

flatbuffers::Offset<LSTMBlockCell> CreateLSTMBlockCell(flatbuffers::FlatBufferBuilder &_fbb, const LSTMBlockCellT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BinaryOpT *BinaryOp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BinaryOpT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BinaryOp::UnPackTo(BinaryOpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = opType(); _o->opType = _e; };
  { auto _e = T(); _o->T = _e; };
  { auto _e = activationType(); _o->activationType = _e; };
}

inline flatbuffers::Offset<BinaryOp> BinaryOp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryOpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBinaryOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BinaryOp> CreateBinaryOp(flatbuffers::FlatBufferBuilder &_fbb, const BinaryOpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BinaryOpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _opType = _o->opType;
  auto _T = _o->T;
  auto _activationType = _o->activationType;
  return MNN::CreateBinaryOp(
      _fbb,
      _opType,
      _T,
      _activationType);
}

inline PackParamT *PackParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PackParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PackParam::UnPackTo(PackParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dataType(); _o->dataType = _e; };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<PackParam> PackParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePackParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PackParam> CreatePackParam(flatbuffers::FlatBufferBuilder &_fbb, const PackParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PackParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dataType = _o->dataType;
  auto _axis = _o->axis;
  return MNN::CreatePackParam(
      _fbb,
      _dataType,
      _axis);
}

inline StridedSliceParamT *StridedSliceParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StridedSliceParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StridedSliceParam::UnPackTo(StridedSliceParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Index(); _o->Index = _e; };
  { auto _e = T(); _o->T = _e; };
  { auto _e = beginMask(); _o->beginMask = _e; };
  { auto _e = endMask(); _o->endMask = _e; };
  { auto _e = ellipsisMask(); _o->ellipsisMask = _e; };
  { auto _e = newAxisMask(); _o->newAxisMask = _e; };
  { auto _e = shrinkAxisMask(); _o->shrinkAxisMask = _e; };
}

inline flatbuffers::Offset<StridedSliceParam> StridedSliceParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStridedSliceParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSliceParam> CreateStridedSliceParam(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Index = _o->Index;
  auto _T = _o->T;
  auto _beginMask = _o->beginMask;
  auto _endMask = _o->endMask;
  auto _ellipsisMask = _o->ellipsisMask;
  auto _newAxisMask = _o->newAxisMask;
  auto _shrinkAxisMask = _o->shrinkAxisMask;
  return MNN::CreateStridedSliceParam(
      _fbb,
      _Index,
      _T,
      _beginMask,
      _endMask,
      _ellipsisMask,
      _newAxisMask,
      _shrinkAxisMask);
}

inline SqueezeParamT *SqueezeParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SqueezeParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SqueezeParam::UnPackTo(SqueezeParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = squeezeDims(); if (_e) { _o->squeezeDims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->squeezeDims[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<SqueezeParam> SqueezeParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqueezeParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqueezeParam> CreateSqueezeParam(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqueezeParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _squeezeDims = _o->squeezeDims.size() ? _fbb.CreateVector(_o->squeezeDims) : 0;
  return MNN::CreateSqueezeParam(
      _fbb,
      _squeezeDims);
}

inline CastParamT *CastParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CastParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CastParam::UnPackTo(CastParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = srcT(); _o->srcT = _e; };
  { auto _e = dstT(); _o->dstT = _e; };
}

inline flatbuffers::Offset<CastParam> CastParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCastParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CastParam> CreateCastParam(flatbuffers::FlatBufferBuilder &_fbb, const CastParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CastParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _srcT = _o->srcT;
  auto _dstT = _o->dstT;
  return MNN::CreateCastParam(
      _fbb,
      _srcT,
      _dstT);
}

inline ReductionParamT *ReductionParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReductionParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReductionParam::UnPackTo(ReductionParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = operation(); _o->operation = _e; };
  { auto _e = dim(); if (_e) { _o->dim.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dim[_i] = _e->Get(_i); } } };
  { auto _e = coeff(); _o->coeff = _e; };
  { auto _e = keepDims(); _o->keepDims = _e; };
  { auto _e = dType(); _o->dType = _e; };
}

inline flatbuffers::Offset<ReductionParam> ReductionParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReductionParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReductionParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReductionParam> CreateReductionParam(flatbuffers::FlatBufferBuilder &_fbb, const ReductionParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReductionParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _operation = _o->operation;
  auto _dim = _o->dim.size() ? _fbb.CreateVector(_o->dim) : 0;
  auto _coeff = _o->coeff;
  auto _keepDims = _o->keepDims;
  auto _dType = _o->dType;
  return MNN::CreateReductionParam(
      _fbb,
      _operation,
      _dim,
      _coeff,
      _keepDims,
      _dType);
}

inline GatherT *Gather::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GatherT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Gather::UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Tindices(); _o->Tindices = _e; };
  { auto _e = Tparams(); _o->Tparams = _e; };
  { auto _e = validateIndices(); _o->validateIndices = _e; };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<Gather> Gather::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGather(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Tindices = _o->Tindices;
  auto _Tparams = _o->Tparams;
  auto _validateIndices = _o->validateIndices;
  auto _axis = _o->axis;
  return MNN::CreateGather(
      _fbb,
      _Tindices,
      _Tparams,
      _validateIndices,
      _axis);
}

inline ExpandDimsT *ExpandDims::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ExpandDimsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ExpandDims::UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
  { auto _e = Tdim(); _o->Tdim = _e; };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<ExpandDims> ExpandDims::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpandDims(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  auto _Tdim = _o->Tdim;
  auto _axis = _o->axis;
  return MNN::CreateExpandDims(
      _fbb,
      _T,
      _Tdim,
      _axis);
}

inline SeluT *Selu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SeluT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Selu::UnPackTo(SeluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scale(); _o->scale = _e; };
  { auto _e = alpha(); _o->alpha = _e; };
}

inline flatbuffers::Offset<Selu> Selu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SeluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Selu> CreateSelu(flatbuffers::FlatBufferBuilder &_fbb, const SeluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SeluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scale = _o->scale;
  auto _alpha = _o->alpha;
  return MNN::CreateSelu(
      _fbb,
      _scale,
      _alpha);
}

inline AsStringT *AsString::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AsStringT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AsString::UnPackTo(AsStringT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
  { auto _e = precision(); _o->precision = _e; };
  { auto _e = scientific(); _o->scientific = _e; };
  { auto _e = shortest(); _o->shortest = _e; };
  { auto _e = width(); _o->width = _e; };
  { auto _e = fillString(); if (_e) _o->fillString = _e->str(); };
}

inline flatbuffers::Offset<AsString> AsString::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AsStringT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAsString(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AsString> CreateAsString(flatbuffers::FlatBufferBuilder &_fbb, const AsStringT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AsStringT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  auto _precision = _o->precision;
  auto _scientific = _o->scientific;
  auto _shortest = _o->shortest;
  auto _width = _o->width;
  auto _fillString = _o->fillString.empty() ? 0 : _fbb.CreateString(_o->fillString);
  return MNN::CreateAsString(
      _fbb,
      _T,
      _precision,
      _scientific,
      _shortest,
      _width,
      _fillString);
}

inline ReduceJoinT *ReduceJoin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReduceJoinT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReduceJoin::UnPackTo(ReduceJoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keepDims(); _o->keepDims = _e; };
  { auto _e = separator(); if (_e) _o->separator = _e->str(); };
}

inline flatbuffers::Offset<ReduceJoin> ReduceJoin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceJoinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceJoin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceJoin> CreateReduceJoin(flatbuffers::FlatBufferBuilder &_fbb, const ReduceJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceJoinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keepDims = _o->keepDims;
  auto _separator = _o->separator.empty() ? 0 : _fbb.CreateString(_o->separator);
  return MNN::CreateReduceJoin(
      _fbb,
      _keepDims,
      _separator);
}

inline UnaryOpT *UnaryOp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnaryOpT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnaryOp::UnPackTo(UnaryOpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = opType(); _o->opType = _e; };
  { auto _e = T(); _o->T = _e; };
}

inline flatbuffers::Offset<UnaryOp> UnaryOp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnaryOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnaryOp> CreateUnaryOp(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnaryOpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _opType = _o->opType;
  auto _T = _o->T;
  return MNN::CreateUnaryOp(
      _fbb,
      _opType,
      _T);
}

inline TopKV2T *TopKV2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TopKV2T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TopKV2::UnPackTo(TopKV2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
  { auto _e = sorted(); _o->sorted = _e; };
  { auto _e = largest(); _o->largest = _e; };
}

inline flatbuffers::Offset<TopKV2> TopKV2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopKV2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopKV2> CreateTopKV2(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopKV2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  auto _sorted = _o->sorted;
  auto _largest = _o->largest;
  return MNN::CreateTopKV2(
      _fbb,
      _T,
      _sorted,
      _largest);
}

inline CropAndResizeT *CropAndResize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CropAndResizeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CropAndResize::UnPackTo(CropAndResizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = extrapolationValue(); _o->extrapolationValue = _e; };
  { auto _e = method(); _o->method = _e; };
}

inline flatbuffers::Offset<CropAndResize> CropAndResize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCropAndResize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CropAndResize> CreateCropAndResize(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CropAndResizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _extrapolationValue = _o->extrapolationValue;
  auto _method = _o->method;
  return MNN::CreateCropAndResize(
      _fbb,
      _extrapolationValue,
      _method);
}

inline FillT *Fill::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FillT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Fill::UnPackTo(FillT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Fill> Fill::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFill(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Fill> CreateFill(flatbuffers::FlatBufferBuilder &_fbb, const FillT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FillT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MNN::CreateFill(
      _fbb);
}

inline GatherV2T *GatherV2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GatherV2T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GatherV2::UnPackTo(GatherV2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Taxis(); _o->Taxis = _e; };
  { auto _e = Tindices(); _o->Tindices = _e; };
  { auto _e = Tparams(); _o->Tparams = _e; };
}

inline flatbuffers::Offset<GatherV2> GatherV2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherV2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherV2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherV2> CreateGatherV2(flatbuffers::FlatBufferBuilder &_fbb, const GatherV2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherV2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Taxis = _o->Taxis;
  auto _Tindices = _o->Tindices;
  auto _Tparams = _o->Tparams;
  return MNN::CreateGatherV2(
      _fbb,
      _Taxis,
      _Tindices,
      _Tparams);
}

inline NonMaxSuppressionV2T *NonMaxSuppressionV2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NonMaxSuppressionV2T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NonMaxSuppressionV2::UnPackTo(NonMaxSuppressionV2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NonMaxSuppressionV2> NonMaxSuppressionV2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonMaxSuppressionV2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppressionV2> CreateNonMaxSuppressionV2(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MNN::CreateNonMaxSuppressionV2(
      _fbb);
}

inline RangeT *Range::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RangeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Range::UnPackTo(RangeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Tidx(); _o->Tidx = _e; };
}

inline flatbuffers::Offset<Range> Range::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRange(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Range> CreateRange(flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RangeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Tidx = _o->Tidx;
  return MNN::CreateRange(
      _fbb,
      _Tidx);
}

inline RankT *Rank::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RankT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Rank::UnPackTo(RankT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rank> Rank::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRank(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rank> CreateRank(flatbuffers::FlatBufferBuilder &_fbb, const RankT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RankT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MNN::CreateRank(
      _fbb);
}

inline SizeT *Size::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SizeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Size::UnPackTo(SizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputDataType(); _o->outputDataType = _e; };
}

inline flatbuffers::Offset<Size> Size::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Size> CreateSize(flatbuffers::FlatBufferBuilder &_fbb, const SizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputDataType = _o->outputDataType;
  return MNN::CreateSize(
      _fbb,
      _outputDataType);
}

inline TransposeT *Transpose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransposeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Transpose::UnPackTo(TransposeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Tperm(); _o->Tperm = _e; };
}

inline flatbuffers::Offset<Transpose> Transpose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTranspose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transpose> CreateTranspose(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Tperm = _o->Tperm;
  return MNN::CreateTranspose(
      _fbb,
      _Tperm);
}

inline SliceTfT *SliceTf::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SliceTfT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SliceTf::UnPackTo(SliceTfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
}

inline flatbuffers::Offset<SliceTf> SliceTf::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceTfT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSliceTf(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceTf> CreateSliceTf(flatbuffers::FlatBufferBuilder &_fbb, const SliceTfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceTfT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  return MNN::CreateSliceTf(
      _fbb,
      _T);
}

inline QuantizeMaxMinT *QuantizeMaxMin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QuantizeMaxMinT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void QuantizeMaxMin::UnPackTo(QuantizeMaxMinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
}

inline flatbuffers::Offset<QuantizeMaxMin> QuantizeMaxMin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeMaxMinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizeMaxMin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizeMaxMin> CreateQuantizeMaxMin(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeMaxMinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizeMaxMinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  return MNN::CreateQuantizeMaxMin(
      _fbb,
      _T);
}

inline CropT *Crop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CropT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Crop::UnPackTo(CropT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = offset(); if (_e) { _o->offset.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->offset[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Crop> Crop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCrop(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Crop> CreateCrop(flatbuffers::FlatBufferBuilder &_fbb, const CropT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CropT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _offset = _o->offset.size() ? _fbb.CreateVector(_o->offset) : 0;
  return MNN::CreateCrop(
      _fbb,
      _axis,
      _offset);
}

inline SpaceBatchT *SpaceBatch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SpaceBatchT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SpaceBatch::UnPackTo(SpaceBatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blockShape(); if (_e) _o->blockShape = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = padding(); if (_e) _o->padding = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<SpaceBatch> SpaceBatch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceBatchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceBatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceBatch> CreateSpaceBatch(flatbuffers::FlatBufferBuilder &_fbb, const SpaceBatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceBatchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blockShape = _o->blockShape ? CreateBlob(_fbb, _o->blockShape.get(), _rehasher) : 0;
  auto _padding = _o->padding ? CreateBlob(_fbb, _o->padding.get(), _rehasher) : 0;
  return MNN::CreateSpaceBatch(
      _fbb,
      _blockShape,
      _padding);
}

inline MatMulT *MatMul::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MatMulT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MatMul::UnPackTo(MatMulT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
  { auto _e = transposeA(); _o->transposeA = _e; };
  { auto _e = transposeB(); _o->transposeB = _e; };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<MatMul> MatMul::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatMul(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatMul> CreateMatMul(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatMulT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  auto _transposeA = _o->transposeA;
  auto _transposeB = _o->transposeB;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  return MNN::CreateMatMul(
      _fbb,
      _T,
      _transposeA,
      _transposeB,
      _weight,
      _bias);
}

inline MomentsParamT *MomentsParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MomentsParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MomentsParam::UnPackTo(MomentsParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dim(); if (_e) { _o->dim.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dim[_i] = _e->Get(_i); } } };
  { auto _e = keepDims(); _o->keepDims = _e; };
  { auto _e = dType(); _o->dType = _e; };
}

inline flatbuffers::Offset<MomentsParam> MomentsParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MomentsParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMomentsParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MomentsParam> CreateMomentsParam(flatbuffers::FlatBufferBuilder &_fbb, const MomentsParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MomentsParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dim = _o->dim.size() ? _fbb.CreateVector(_o->dim) : 0;
  auto _keepDims = _o->keepDims;
  auto _dType = _o->dType;
  return MNN::CreateMomentsParam(
      _fbb,
      _dim,
      _keepDims,
      _dType);
}

inline RNNParamT *RNNParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RNNParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RNNParam::UnPackTo(RNNParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = numUnits(); _o->numUnits = _e; };
  { auto _e = isBidirectionalRNN(); _o->isBidirectionalRNN = _e; };
  { auto _e = linearBeforeReset(); _o->linearBeforeReset = _e; };
  { auto _e = keepAllOutputs(); _o->keepAllOutputs = _e; };
  { auto _e = fwGateWeight(); if (_e) _o->fwGateWeight = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = fwGateBias(); if (_e) _o->fwGateBias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = fwCandidateWeight(); if (_e) _o->fwCandidateWeight = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = fwCandidateBias(); if (_e) _o->fwCandidateBias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = fwRecurrentBias(); if (_e) _o->fwRecurrentBias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bwGateWeight(); if (_e) _o->bwGateWeight = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bwGateBias(); if (_e) _o->bwGateBias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bwCandidateWeight(); if (_e) _o->bwCandidateWeight = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bwCandidateBias(); if (_e) _o->bwCandidateBias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bwRecurrentBias(); if (_e) _o->bwRecurrentBias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<RNNParam> RNNParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRNNParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RNNParam> CreateRNNParam(flatbuffers::FlatBufferBuilder &_fbb, const RNNParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RNNParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _numUnits = _o->numUnits;
  auto _isBidirectionalRNN = _o->isBidirectionalRNN;
  auto _linearBeforeReset = _o->linearBeforeReset;
  auto _keepAllOutputs = _o->keepAllOutputs;
  auto _fwGateWeight = _o->fwGateWeight ? CreateBlob(_fbb, _o->fwGateWeight.get(), _rehasher) : 0;
  auto _fwGateBias = _o->fwGateBias ? CreateBlob(_fbb, _o->fwGateBias.get(), _rehasher) : 0;
  auto _fwCandidateWeight = _o->fwCandidateWeight ? CreateBlob(_fbb, _o->fwCandidateWeight.get(), _rehasher) : 0;
  auto _fwCandidateBias = _o->fwCandidateBias ? CreateBlob(_fbb, _o->fwCandidateBias.get(), _rehasher) : 0;
  auto _fwRecurrentBias = _o->fwRecurrentBias ? CreateBlob(_fbb, _o->fwRecurrentBias.get(), _rehasher) : 0;
  auto _bwGateWeight = _o->bwGateWeight ? CreateBlob(_fbb, _o->bwGateWeight.get(), _rehasher) : 0;
  auto _bwGateBias = _o->bwGateBias ? CreateBlob(_fbb, _o->bwGateBias.get(), _rehasher) : 0;
  auto _bwCandidateWeight = _o->bwCandidateWeight ? CreateBlob(_fbb, _o->bwCandidateWeight.get(), _rehasher) : 0;
  auto _bwCandidateBias = _o->bwCandidateBias ? CreateBlob(_fbb, _o->bwCandidateBias.get(), _rehasher) : 0;
  auto _bwRecurrentBias = _o->bwRecurrentBias ? CreateBlob(_fbb, _o->bwRecurrentBias.get(), _rehasher) : 0;
  return MNN::CreateRNNParam(
      _fbb,
      _numUnits,
      _isBidirectionalRNN,
      _linearBeforeReset,
      _keepAllOutputs,
      _fwGateWeight,
      _fwGateBias,
      _fwCandidateWeight,
      _fwCandidateBias,
      _fwRecurrentBias,
      _bwGateWeight,
      _bwGateBias,
      _bwCandidateWeight,
      _bwCandidateBias,
      _bwRecurrentBias);
}

inline BatchMatMulParamT *BatchMatMulParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BatchMatMulParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BatchMatMulParam::UnPackTo(BatchMatMulParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = adjX(); _o->adjX = _e; };
  { auto _e = adjY(); _o->adjY = _e; };
}

inline flatbuffers::Offset<BatchMatMulParam> BatchMatMulParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchMatMulParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchMatMulParam> CreateBatchMatMulParam(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchMatMulParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _adjX = _o->adjX;
  auto _adjY = _o->adjY;
  return MNN::CreateBatchMatMulParam(
      _fbb,
      _adjX,
      _adjY);
}

inline DepthSpaceParamT *DepthSpaceParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DepthSpaceParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DepthSpaceParam::UnPackTo(DepthSpaceParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blockSize(); _o->blockSize = _e; };
  { auto _e = mode(); _o->mode = _e; };
}

inline flatbuffers::Offset<DepthSpaceParam> DepthSpaceParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthSpaceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthSpaceParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthSpaceParam> CreateDepthSpaceParam(flatbuffers::FlatBufferBuilder &_fbb, const DepthSpaceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthSpaceParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blockSize = _o->blockSize;
  auto _mode = _o->mode;
  return MNN::CreateDepthSpaceParam(
      _fbb,
      _blockSize,
      _mode);
}

inline ReverseSequenceParamT *ReverseSequenceParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReverseSequenceParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReverseSequenceParam::UnPackTo(ReverseSequenceParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = batchDim(); _o->batchDim = _e; };
  { auto _e = seqDim(); _o->seqDim = _e; };
}

inline flatbuffers::Offset<ReverseSequenceParam> ReverseSequenceParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverseSequenceParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseSequenceParam> CreateReverseSequenceParam(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseSequenceParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _batchDim = _o->batchDim;
  auto _seqDim = _o->seqDim;
  return MNN::CreateReverseSequenceParam(
      _fbb,
      _batchDim,
      _seqDim);
}

inline DetectionPostProcessParamT *DetectionPostProcessParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DetectionPostProcessParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DetectionPostProcessParam::UnPackTo(DetectionPostProcessParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = maxDetections(); _o->maxDetections = _e; };
  { auto _e = maxClassesPerDetection(); _o->maxClassesPerDetection = _e; };
  { auto _e = detectionsPerClass(); _o->detectionsPerClass = _e; };
  { auto _e = nmsScoreThreshold(); _o->nmsScoreThreshold = _e; };
  { auto _e = iouThreshold(); _o->iouThreshold = _e; };
  { auto _e = numClasses(); _o->numClasses = _e; };
  { auto _e = useRegularNMS(); _o->useRegularNMS = _e; };
  { auto _e = centerSizeEncoding(); if (_e) { _o->centerSizeEncoding.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->centerSizeEncoding[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<DetectionPostProcessParam> DetectionPostProcessParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectionPostProcessParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectionPostProcessParam> CreateDetectionPostProcessParam(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionPostProcessParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _maxDetections = _o->maxDetections;
  auto _maxClassesPerDetection = _o->maxClassesPerDetection;
  auto _detectionsPerClass = _o->detectionsPerClass;
  auto _nmsScoreThreshold = _o->nmsScoreThreshold;
  auto _iouThreshold = _o->iouThreshold;
  auto _numClasses = _o->numClasses;
  auto _useRegularNMS = _o->useRegularNMS;
  auto _centerSizeEncoding = _o->centerSizeEncoding.size() ? _fbb.CreateVector(_o->centerSizeEncoding) : 0;
  return MNN::CreateDetectionPostProcessParam(
      _fbb,
      _maxDetections,
      _maxClassesPerDetection,
      _detectionsPerClass,
      _nmsScoreThreshold,
      _iouThreshold,
      _numClasses,
      _useRegularNMS,
      _centerSizeEncoding);
}

inline OneHotParamT *OneHotParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OneHotParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OneHotParam::UnPackTo(OneHotParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dType(); _o->dType = _e; };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<OneHotParam> OneHotParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOneHotParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OneHotParam> CreateOneHotParam(flatbuffers::FlatBufferBuilder &_fbb, const OneHotParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OneHotParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dType = _o->dType;
  auto _axis = _o->axis;
  return MNN::CreateOneHotParam(
      _fbb,
      _dType,
      _axis);
}

inline PadParamT *PadParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PadParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PadParam::UnPackTo(PadParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; };
}

inline flatbuffers::Offset<PadParam> PadParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePadParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadParam> CreatePadParam(flatbuffers::FlatBufferBuilder &_fbb, const PadParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  return MNN::CreatePadParam(
      _fbb,
      _mode);
}

inline LayerNormT *LayerNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LayerNormT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LayerNorm::UnPackTo(LayerNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } };
  { auto _e = epsilon(); _o->epsilon = _e; };
  { auto _e = gamma(); if (_e) { _o->gamma.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->gamma[_i] = _e->Get(_i); } } };
  { auto _e = beta(); if (_e) { _o->beta.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->beta[_i] = _e->Get(_i); } } };
  { auto _e = group(); _o->group = _e; };
  { auto _e = external(); if (_e) { _o->external.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->external[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<LayerNorm> LayerNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLayerNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LayerNorm> CreateLayerNorm(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LayerNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  auto _epsilon = _o->epsilon;
  auto _gamma = _o->gamma.size() ? _fbb.CreateVector(_o->gamma) : 0;
  auto _beta = _o->beta.size() ? _fbb.CreateVector(_o->beta) : 0;
  auto _group = _o->group;
  auto _external = _o->external.size() ? _fbb.CreateVector(_o->external) : 0;
  return MNN::CreateLayerNorm(
      _fbb,
      _axis,
      _epsilon,
      _gamma,
      _beta,
      _group,
      _external);
}

inline RandomUniformT *RandomUniform::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RandomUniformT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RandomUniform::UnPackTo(RandomUniformT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seed(); _o->seed = _e; };
  { auto _e = seed2(); _o->seed2 = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = low(); _o->low = _e; };
  { auto _e = high(); _o->high = _e; };
}

inline flatbuffers::Offset<RandomUniform> RandomUniform::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomUniformT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandomUniform(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RandomUniform> CreateRandomUniform(flatbuffers::FlatBufferBuilder &_fbb, const RandomUniformT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RandomUniformT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seed = _o->seed;
  auto _seed2 = _o->seed2;
  auto _type = _o->type;
  auto _low = _o->low;
  auto _high = _o->high;
  return MNN::CreateRandomUniform(
      _fbb,
      _seed,
      _seed2,
      _type,
      _low,
      _high);
}

inline TensorArrayT *TensorArray::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorArrayT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TensorArray::UnPackTo(TensorArrayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dynamic_size(); _o->dynamic_size = _e; };
  { auto _e = identical_element_shapes(); _o->identical_element_shapes = _e; };
  { auto _e = element_shape(); if (_e) { _o->element_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->element_shape[_i] = _e->Get(_i); } } };
  { auto _e = T(); _o->T = _e; };
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = keepdims(); _o->keepdims = _e; };
  { auto _e = new_axis(); _o->new_axis = _e; };
}

inline flatbuffers::Offset<TensorArray> TensorArray::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorArray(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorArray> CreateTensorArray(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorArrayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dynamic_size = _o->dynamic_size;
  auto _identical_element_shapes = _o->identical_element_shapes;
  auto _element_shape = _o->element_shape.size() ? _fbb.CreateVector(_o->element_shape) : 0;
  auto _T = _o->T;
  auto _axis = _o->axis;
  auto _keepdims = _o->keepdims;
  auto _new_axis = _o->new_axis;
  return MNN::CreateTensorArray(
      _fbb,
      _dynamic_size,
      _identical_element_shapes,
      _element_shape,
      _T,
      _axis,
      _keepdims,
      _new_axis);
}

inline LSTMBlockCellT *LSTMBlockCell::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LSTMBlockCellT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LSTMBlockCell::UnPackTo(LSTMBlockCellT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cell_clip(); _o->cell_clip = _e; };
  { auto _e = forget_bias(); _o->forget_bias = _e; };
  { auto _e = use_peephole(); _o->use_peephole = _e; };
}

inline flatbuffers::Offset<LSTMBlockCell> LSTMBlockCell::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMBlockCellT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSTMBlockCell(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTMBlockCell> CreateLSTMBlockCell(flatbuffers::FlatBufferBuilder &_fbb, const LSTMBlockCellT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMBlockCellT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cell_clip = _o->cell_clip;
  auto _forget_bias = _o->forget_bias;
  auto _use_peephole = _o->use_peephole;
  return MNN::CreateLSTMBlockCell(
      _fbb,
      _cell_clip,
      _forget_bias,
      _use_peephole);
}

inline const flatbuffers::TypeTable *BinaryOpOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BinaryOpOperationTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28 };
  static const char * const names[] = {
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "MAX_TEMP",
    "MIN_TEMP",
    "POW",
    "REALDIV",
    "MINIMUM",
    "MAXIMUM",
    "GREATER",
    "GREATER_EQUAL",
    "LESS",
    "FLOORDIV",
    "SquaredDifference",
    "EQUAL",
    "LESS_EQUAL",
    "FLOORMOD",
    "MOD",
    "ATAN2",
    "LOGICALOR",
    "NOTEQUAL",
    "BITWISE_AND",
    "BITWISE_OR",
    "BITWISE_XOR",
    "LOGICALXOR",
    "LEFTSHIFT",
    "RIGHTSHIFT"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 28, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReductionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ReductionTypeTypeTable
  };
  static const char * const names[] = {
    "SUM",
    "ASUM",
    "SUMSQ",
    "MEAN",
    "MAXIMUM",
    "MINIMUM",
    "PROD",
    "ANY",
    "ALL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnaryOpOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    UnaryOpOperationTypeTable
  };
  static const char * const names[] = {
    "ABS",
    "NEG",
    "FLOOR",
    "CEIL",
    "SQUARE",
    "SQRT",
    "RSQRT",
    "EXP",
    "LOG",
    "SIN",
    "COS",
    "TAN",
    "ASIN",
    "ACOS",
    "ATAN",
    "RECIPROCAL",
    "LOG1P",
    "BNLL",
    "ACOSH",
    "SINH",
    "ASINH",
    "ATANH",
    "SIGN",
    "ROUND",
    "COSH",
    "ERF",
    "ERFC",
    "ERFINV",
    "EXPM1",
    "SIGMOID",
    "TANH",
    "HARDSWISH",
    "GELU",
    "GELU_STANDARD"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 34, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CropAndResizeMethodTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CropAndResizeMethodTypeTable
  };
  static const char * const names[] = {
    "BILINEAR",
    "NEAREST"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthToSpaceModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DepthToSpaceModeTypeTable
  };
  static const char * const names[] = {
    "DCR",
    "CRD"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadValueModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadValueModeTypeTable
  };
  static const char * const names[] = {
    "CONSTANT",
    "REFLECT",
    "SYMMETRIC",
    "EDGE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BinaryOpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "opType",
    "T",
    "activationType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PackParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "dataType",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StridedSliceParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "Index",
    "T",
    "beginMask",
    "endMask",
    "ellipsisMask",
    "newAxisMask",
    "shrinkAxisMask"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqueezeParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "squeezeDims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CastParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "srcT",
    "dstT"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReductionParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ReductionTypeTypeTable,
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "operation",
    "dim",
    "coeff",
    "keepDims",
    "dType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "Tindices",
    "Tparams",
    "validateIndices",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpandDimsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T",
    "Tdim",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SeluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "scale",
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AsStringTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T",
    "precision",
    "scientific",
    "shortest",
    "width",
    "fillString"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceJoinTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "keepDims",
    "separator"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnaryOpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    UnaryOpOperationTypeTable,
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "opType",
    "T"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopKV2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T",
    "sorted",
    "largest"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CropAndResizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CropAndResizeMethodTypeTable
  };
  static const char * const names[] = {
    "extrapolationValue",
    "method"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FillTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherV2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "Taxis",
    "Tindices",
    "Tparams"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NonMaxSuppressionV2TypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RangeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "Tidx"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RankTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "outputDataType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TransposeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "Tperm"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SliceTfTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantizeMaxMinTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CropTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "axis",
    "offset"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpaceBatchTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlobTypeTable
  };
  static const char * const names[] = {
    "blockShape",
    "padding"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MatMulTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T",
    "transposeA",
    "transposeB",
    "weight",
    "bias"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MomentsParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "dim",
    "keepDims",
    "dType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RNNParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlobTypeTable
  };
  static const char * const names[] = {
    "numUnits",
    "isBidirectionalRNN",
    "linearBeforeReset",
    "keepAllOutputs",
    "fwGateWeight",
    "fwGateBias",
    "fwCandidateWeight",
    "fwCandidateBias",
    "fwRecurrentBias",
    "bwGateWeight",
    "bwGateBias",
    "bwCandidateWeight",
    "bwCandidateBias",
    "bwRecurrentBias"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchMatMulParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "adjX",
    "adjY"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthSpaceParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DepthToSpaceModeTypeTable
  };
  static const char * const names[] = {
    "blockSize",
    "mode"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReverseSequenceParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "batchDim",
    "seqDim"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DetectionPostProcessParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "maxDetections",
    "maxClassesPerDetection",
    "detectionsPerClass",
    "nmsScoreThreshold",
    "iouThreshold",
    "numClasses",
    "useRegularNMS",
    "centerSizeEncoding"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OneHotParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "dType",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadValueModeTypeTable
  };
  static const char * const names[] = {
    "mode"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LayerNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "axis",
    "epsilon",
    "gamma",
    "beta",
    "group",
    "external"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RandomUniformTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "seed",
    "seed2",
    "type",
    "low",
    "high"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorArrayTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "dynamic_size",
    "identical_element_shapes",
    "element_shape",
    "T",
    "axis",
    "keepdims",
    "new_axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LSTMBlockCellTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "cell_clip",
    "forget_bias",
    "use_peephole"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace MNN

#endif  // FLATBUFFERS_GENERATED_TENSORFLOWOP_MNN_H_
