// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRAININFO_MNNTRAIN_H_
#define FLATBUFFERS_GENERATED_TRAININFO_MNNTRAIN_H_

#include "flatbuffers/flatbuffers.h"

namespace MNNTrain {

struct OpInfo;
struct OpInfoT;

struct KV;
struct KVT;

struct TrainInfo;
struct TrainInfoT;

inline const flatbuffers::TypeTable *OpInfoTypeTable();

inline const flatbuffers::TypeTable *KVTypeTable();

inline const flatbuffers::TypeTable *TrainInfoTypeTable();

struct OpInfoT : public flatbuffers::NativeTable {
  typedef OpInfo TableType;
  std::string op;
  std::string weight;
  std::string bias;
  OpInfoT() {
  }
};

struct OpInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpInfoTypeTable();
  }
  const flatbuffers::String *op() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::String *weight() const {
    return GetPointer<const flatbuffers::String *>(6);
  }
  const flatbuffers::String *bias() const {
    return GetPointer<const flatbuffers::String *>(8);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(op()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyString(weight()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyString(bias()) &&
           verifier.EndTable();
  }
  OpInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OpInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_op(flatbuffers::Offset<flatbuffers::String> op) {
    fbb_.AddOffset(4, op);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::String> weight) {
    fbb_.AddOffset(6, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::String> bias) {
    fbb_.AddOffset(8, bias);
  }
  explicit OpInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpInfoBuilder &operator=(const OpInfoBuilder &);
  flatbuffers::Offset<OpInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpInfo> CreateOpInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> op = 0,
    flatbuffers::Offset<flatbuffers::String> weight = 0,
    flatbuffers::Offset<flatbuffers::String> bias = 0) {
  OpInfoBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_op(op);
  return builder_.Finish();
}

flatbuffers::Offset<OpInfo> CreateOpInfo(flatbuffers::FlatBufferBuilder &_fbb, const OpInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KVT : public flatbuffers::NativeTable {
  typedef KV TableType;
  std::string key;
  std::string value;
  KVT() {
  }
};

struct KV FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KVT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KVTypeTable();
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  KVT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KVT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<KV> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KVT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KVBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(4, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(6, value);
  }
  explicit KVBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KVBuilder &operator=(const KVBuilder &);
  flatbuffers::Offset<KV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KV>(end);
    return o;
  }
};

inline flatbuffers::Offset<KV> CreateKV(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  KVBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

flatbuffers::Offset<KV> CreateKV(flatbuffers::FlatBufferBuilder &_fbb, const KVT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TrainInfoT : public flatbuffers::NativeTable {
  typedef TrainInfo TableType;
  std::vector<std::unique_ptr<KVT>> trainables;
  std::vector<std::unique_ptr<OpInfoT>> convolutions;
  std::vector<std::unique_ptr<KVT>> batchnormal;
  TrainInfoT() {
  }
};

struct TrainInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrainInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TrainInfoTypeTable();
  }
  const flatbuffers::Vector<flatbuffers::Offset<KV>> *trainables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KV>> *>(4);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OpInfo>> *convolutions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OpInfo>> *>(6);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KV>> *batchnormal() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KV>> *>(8);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(trainables()) &&
           verifier.VerifyVectorOfTables(trainables()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(convolutions()) &&
           verifier.VerifyVectorOfTables(convolutions()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(batchnormal()) &&
           verifier.VerifyVectorOfTables(batchnormal()) &&
           verifier.EndTable();
  }
  TrainInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TrainInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TrainInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrainInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TrainInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trainables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KV>>> trainables) {
    fbb_.AddOffset(4, trainables);
  }
  void add_convolutions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OpInfo>>> convolutions) {
    fbb_.AddOffset(6, convolutions);
  }
  void add_batchnormal(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KV>>> batchnormal) {
    fbb_.AddOffset(8, batchnormal);
  }
  explicit TrainInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TrainInfoBuilder &operator=(const TrainInfoBuilder &);
  flatbuffers::Offset<TrainInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrainInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrainInfo> CreateTrainInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KV>>> trainables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OpInfo>>> convolutions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KV>>> batchnormal = 0) {
  TrainInfoBuilder builder_(_fbb);
  builder_.add_batchnormal(batchnormal);
  builder_.add_convolutions(convolutions);
  builder_.add_trainables(trainables);
  return builder_.Finish();
}

flatbuffers::Offset<TrainInfo> CreateTrainInfo(flatbuffers::FlatBufferBuilder &_fbb, const TrainInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline OpInfoT *OpInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OpInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OpInfo::UnPackTo(OpInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = op(); if (_e) _o->op = _e->str(); };
  { auto _e = weight(); if (_e) _o->weight = _e->str(); };
  { auto _e = bias(); if (_e) _o->bias = _e->str(); };
}

inline flatbuffers::Offset<OpInfo> OpInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OpInfo> CreateOpInfo(flatbuffers::FlatBufferBuilder &_fbb, const OpInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _op = _o->op.empty() ? 0 : _fbb.CreateString(_o->op);
  auto _weight = _o->weight.empty() ? 0 : _fbb.CreateString(_o->weight);
  auto _bias = _o->bias.empty() ? 0 : _fbb.CreateString(_o->bias);
  return MNNTrain::CreateOpInfo(
      _fbb,
      _op,
      _weight,
      _bias);
}

inline KVT *KV::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new KVT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void KV::UnPackTo(KVT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); };
  { auto _e = value(); if (_e) _o->value = _e->str(); };
}

inline flatbuffers::Offset<KV> KV::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KVT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKV(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<KV> CreateKV(flatbuffers::FlatBufferBuilder &_fbb, const KVT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KVT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _o->key.empty() ? 0 : _fbb.CreateString(_o->key);
  auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
  return MNNTrain::CreateKV(
      _fbb,
      _key,
      _value);
}

inline TrainInfoT *TrainInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TrainInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TrainInfo::UnPackTo(TrainInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = trainables(); if (_e) { _o->trainables.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->trainables[_i] = std::unique_ptr<KVT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = convolutions(); if (_e) { _o->convolutions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->convolutions[_i] = std::unique_ptr<OpInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = batchnormal(); if (_e) { _o->batchnormal.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->batchnormal[_i] = std::unique_ptr<KVT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<TrainInfo> TrainInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrainInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTrainInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TrainInfo> CreateTrainInfo(flatbuffers::FlatBufferBuilder &_fbb, const TrainInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TrainInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _trainables = _o->trainables.size() ? _fbb.CreateVector<flatbuffers::Offset<KV>> (_o->trainables.size(), [](size_t i, _VectorArgs *__va) { return CreateKV(*__va->__fbb, __va->__o->trainables[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _convolutions = _o->convolutions.size() ? _fbb.CreateVector<flatbuffers::Offset<OpInfo>> (_o->convolutions.size(), [](size_t i, _VectorArgs *__va) { return CreateOpInfo(*__va->__fbb, __va->__o->convolutions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _batchnormal = _o->batchnormal.size() ? _fbb.CreateVector<flatbuffers::Offset<KV>> (_o->batchnormal.size(), [](size_t i, _VectorArgs *__va) { return CreateKV(*__va->__fbb, __va->__o->batchnormal[i].get(), __va->__rehasher); }, &_va ) : 0;
  return MNNTrain::CreateTrainInfo(
      _fbb,
      _trainables,
      _convolutions,
      _batchnormal);
}

inline const flatbuffers::TypeTable *OpInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "op",
    "weight",
    "bias"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *KVTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "key",
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TrainInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    KVTypeTable,
    OpInfoTypeTable
  };
  static const char * const names[] = {
    "trainables",
    "convolutions",
    "batchnormal"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace MNNTrain

#endif  // FLATBUFFERS_GENERATED_TRAININFO_MNNTRAIN_H_
