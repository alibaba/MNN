// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MNN_MNN_H_
#define FLATBUFFERS_GENERATED_MNN_MNN_H_


#include "CaffeOp_generated.h"
#include "ExtraInfo_generated.h"
#include "TFQuantizeOp_generated.h"
#include "Tensor_generated.h"
#include "TensorflowOp_generated.h"
#include "Type_generated.h"
#include "UserDefine_generated.h"

namespace MNN {

struct Plugin;
struct PluginT;

struct Extra;
struct ExtraT;

struct StringVec;
struct StringVecT;

struct AttentionParam;
struct AttentionParamT;

struct FmhaV2Param;
struct FmhaV2ParamT;

struct FmhcaParam;
struct FmhcaParamT;

struct WhileParam;
struct WhileParamT;

struct IfParam;
struct IfParamT;

struct RegionCommand;
struct RegionCommandT;

struct LoopParam;
struct LoopParamT;

struct Op;
struct OpT;

struct View;
struct ViewT;

struct Region;
struct RegionT;

struct TensorDescribe;
struct TensorDescribeT;

struct SubGraphProto;
struct SubGraphProtoT;

struct TensorQuantInfo;
struct TensorQuantInfoT;

struct Net;
struct NetT;

inline const flatbuffers::TypeTable *PluginTypeTable();

inline const flatbuffers::TypeTable *ExtraTypeTable();

inline const flatbuffers::TypeTable *StringVecTypeTable();

inline const flatbuffers::TypeTable *AttentionParamTypeTable();

inline const flatbuffers::TypeTable *FmhaV2ParamTypeTable();

inline const flatbuffers::TypeTable *FmhcaParamTypeTable();

inline const flatbuffers::TypeTable *WhileParamTypeTable();

inline const flatbuffers::TypeTable *IfParamTypeTable();

inline const flatbuffers::TypeTable *RegionCommandTypeTable();

inline const flatbuffers::TypeTable *LoopParamTypeTable();

inline const flatbuffers::TypeTable *OpTypeTable();

inline const flatbuffers::TypeTable *ViewTypeTable();

inline const flatbuffers::TypeTable *RegionTypeTable();

inline const flatbuffers::TypeTable *TensorDescribeTypeTable();

inline const flatbuffers::TypeTable *SubGraphProtoTypeTable();

inline const flatbuffers::TypeTable *TensorQuantInfoTypeTable();

inline const flatbuffers::TypeTable *NetTypeTable();

enum OpType {
  OpType_AbsVal = 0,
  OpType_QuantizedAdd = 1,
  OpType_ArgMax = 2,
  OpType_AsString = 3,
  OpType_InstanceNorm = 4,
  OpType_BatchToSpaceND = 5,
  OpType_Copy = 6,
  OpType_BinaryOp = 7,
  OpType_Bnll = 8,
  OpType_Cast = 9,
  OpType_Concat = 10,
  OpType_Const = 11,
  OpType_Convolution = 12,
  OpType_ConvolutionDepthwise = 13,
  OpType_Crop = 14,
  OpType_CropAndResize = 15,
  OpType_ImageProcess = 16,
  OpType_Deconvolution = 17,
  OpType_DeconvolutionDepthwise = 18,
  OpType_Dequantize = 19,
  OpType_DetectionOutput = 20,
  OpType_Dropout = 21,
  OpType_Eltwise = 22,
  OpType_ELU = 23,
  OpType_Unique = 24,
  OpType_Exp = 25,
  OpType_ExpandDims = 26,
  OpType_Fill = 27,
  OpType_Flatten = 28,
  OpType_Im2Col = 29,
  OpType_Gather = 30,
  OpType_GatherV2 = 31,
  OpType_Im2Seq = 32,
  OpType_InnerProduct = 33,
  OpType_Input = 34,
  OpType_Interp = 35,
  OpType_Log = 36,
  OpType_LRN = 37,
  OpType_LSTM = 38,
  OpType_MatMul = 39,
  OpType_MVN = 40,
  OpType_NonMaxSuppression = 41,
  OpType_NonMaxSuppressionV2 = 42,
  OpType_Normalize = 43,
  OpType_Pack = 44,
  OpType_Padding = 45,
  OpType_Permute = 46,
  OpType_Pooling = 47,
  OpType_Power = 48,
  OpType_PReLU = 49,
  OpType_PriorBox = 50,
  OpType_Proposal = 51,
  OpType_QuantizedAvgPool = 52,
  OpType_QuantizedBiasAdd = 53,
  OpType_QuantizedConcat = 54,
  OpType_QuantizedDepthwiseConv2D = 55,
  OpType_QuantizedLogistic = 56,
  OpType_RasterAndInterpolate = 57,
  OpType_QuantizedMaxPool = 58,
  OpType_Texture = 59,
  OpType_RasterDiff = 60,
  OpType_QuantizedReshape = 61,
  OpType_QuantizedSoftmax = 62,
  OpType_QuantizeMaxMin = 63,
  OpType_QuantizeV2 = 64,
  OpType_Range = 65,
  OpType_Rank = 66,
  OpType_ReduceJoin = 67,
  OpType_Reduction = 68,
  OpType_ReLU = 69,
  OpType_ReLU6 = 70,
  OpType_RequantizationRange = 71,
  OpType_Requantize = 72,
  OpType_Reshape = 73,
  OpType_Resize = 74,
  OpType_RNN = 75,
  OpType_ROIPooling = 76,
  OpType_Scale = 77,
  OpType_Selu = 78,
  OpType_Seq2Out = 79,
  OpType_Shape = 80,
  OpType_Sigmoid = 81,
  OpType_Size = 82,
  OpType_Slice = 83,
  OpType_SliceTf = 84,
  OpType_Softmax = 85,
  OpType_SpaceToBatchND = 86,
  OpType_SpatialProduct = 87,
  OpType_Col2Im = 88,
  OpType_Segment = 89,
  OpType_Squeeze = 90,
  OpType_StridedSlice = 91,
  OpType_StringJoin = 92,
  OpType_StringSplit = 93,
  OpType_StringToNumber = 94,
  OpType_TanH = 95,
  OpType_TfQuantizedConv2D = 96,
  OpType_Threshold = 97,
  OpType_Tile = 98,
  OpType_TopKV2 = 99,
  OpType_Transpose = 100,
  OpType_UnaryOp = 101,
  OpType_Unpack = 102,
  OpType_Where = 103,
  OpType_Moments = 104,
  OpType_RNNSequenceGRU = 105,
  OpType_BatchMatMul = 106,
  OpType_Unsqueeze = 107,
  OpType_CosineSimilarity = 108,
  OpType_DepthToSpace = 109,
  OpType_SpaceToDepth = 110,
  OpType_ReverseSequence = 111,
  OpType_Pooling3D = 112,
  OpType_Convolution3D = 113,
  OpType_MatrixBandPart = 114,
  OpType_GatherND = 115,
  OpType_DetectionPostProcess = 116,
  OpType_UnravelIndex = 117,
  OpType_ScatterNd = 118,
  OpType_OneHot = 119,
  OpType_BroadcastTo = 120,
  OpType_Dilation2D = 121,
  OpType_Interp3D = 122,
  OpType_Raster = 128,
  OpType_ConvertTensor = 129,
  OpType_ArgMin = 130,
  OpType_LinSpace = 131,
  OpType_RandomUniform = 132,
  OpType_TensorArray = 133,
  OpType_TensorArraySize = 134,
  OpType_TensorArrayRead = 135,
  OpType_TensorArrayWrite = 136,
  OpType_TensorArrayGather = 137,
  OpType_TensorArrayScatter = 138,
  OpType_TensorArraySplit = 139,
  OpType_TensorArrayConcat = 140,
  OpType_LSTMBlockCell = 141,
  OpType_Reverse = 142,
  OpType_ROIAlign = 143,
  OpType_RandomNormal = 144,
  OpType_TensorArrayInsert = 145,
  OpType_TensorArrayErase = 146,
  OpType_EyeLike = 147,
  OpType_CumSum = 148,
  OpType_Det = 149,
  OpType_CumProd = 150,
  OpType_ScatterElements = 151,
  OpType_GatherElements = 152,
  OpType_Svd = 153,
  OpType_Histogram = 154,
  OpType_DynamicQuant = 155,
  OpType_Plugin = 256,
  OpType_Select = 257,
  OpType_ZerosLike = 258,
  OpType_Broastcast = 259,
  OpType_SetDiff1D = 260,
  OpType_ReluGrad = 261,
  OpType_Identity = 262,
  OpType_PoolGrad = 263,
  OpType_SoftmaxGrad = 264,
  OpType_Conv2DBackPropFilter = 265,
  OpType_TrainableParam = 266,
  OpType_BatchNorm = 267,
  OpType_ConvTranspose3D = 268,
  OpType_ZeroGrad = 269,
  OpType_Attention = 299,
  OpType_FmhaV2 = 300,
  OpType_Fmhca = 301,
  OpType_SeqLen2Spatial = 302,
  OpType_SplitGeLU = 303,
  OpType_GroupNorm = 304,
  OpType_Extra = 512,
  OpType_ConvInt8 = 513,
  OpType_Int8ToFloat = 514,
  OpType_DepthwiseConvInt8 = 515,
  OpType_PoolInt8 = 516,
  OpType_FloatToInt8 = 517,
  OpType_EltwiseInt8 = 518,
  OpType_While = 600,
  OpType_If = 601,
  OpType_LayerNorm = 603,
  OpType_GridSample = 604,
  OpType_MIN = OpType_AbsVal,
  OpType_MAX = OpType_GridSample
};

inline const OpType (&EnumValuesOpType())[182] {
  static const OpType values[] = {
    OpType_AbsVal,
    OpType_QuantizedAdd,
    OpType_ArgMax,
    OpType_AsString,
    OpType_InstanceNorm,
    OpType_BatchToSpaceND,
    OpType_Copy,
    OpType_BinaryOp,
    OpType_Bnll,
    OpType_Cast,
    OpType_Concat,
    OpType_Const,
    OpType_Convolution,
    OpType_ConvolutionDepthwise,
    OpType_Crop,
    OpType_CropAndResize,
    OpType_ImageProcess,
    OpType_Deconvolution,
    OpType_DeconvolutionDepthwise,
    OpType_Dequantize,
    OpType_DetectionOutput,
    OpType_Dropout,
    OpType_Eltwise,
    OpType_ELU,
    OpType_Unique,
    OpType_Exp,
    OpType_ExpandDims,
    OpType_Fill,
    OpType_Flatten,
    OpType_Im2Col,
    OpType_Gather,
    OpType_GatherV2,
    OpType_Im2Seq,
    OpType_InnerProduct,
    OpType_Input,
    OpType_Interp,
    OpType_Log,
    OpType_LRN,
    OpType_LSTM,
    OpType_MatMul,
    OpType_MVN,
    OpType_NonMaxSuppression,
    OpType_NonMaxSuppressionV2,
    OpType_Normalize,
    OpType_Pack,
    OpType_Padding,
    OpType_Permute,
    OpType_Pooling,
    OpType_Power,
    OpType_PReLU,
    OpType_PriorBox,
    OpType_Proposal,
    OpType_QuantizedAvgPool,
    OpType_QuantizedBiasAdd,
    OpType_QuantizedConcat,
    OpType_QuantizedDepthwiseConv2D,
    OpType_QuantizedLogistic,
    OpType_RasterAndInterpolate,
    OpType_QuantizedMaxPool,
    OpType_Texture,
    OpType_RasterDiff,
    OpType_QuantizedReshape,
    OpType_QuantizedSoftmax,
    OpType_QuantizeMaxMin,
    OpType_QuantizeV2,
    OpType_Range,
    OpType_Rank,
    OpType_ReduceJoin,
    OpType_Reduction,
    OpType_ReLU,
    OpType_ReLU6,
    OpType_RequantizationRange,
    OpType_Requantize,
    OpType_Reshape,
    OpType_Resize,
    OpType_RNN,
    OpType_ROIPooling,
    OpType_Scale,
    OpType_Selu,
    OpType_Seq2Out,
    OpType_Shape,
    OpType_Sigmoid,
    OpType_Size,
    OpType_Slice,
    OpType_SliceTf,
    OpType_Softmax,
    OpType_SpaceToBatchND,
    OpType_SpatialProduct,
    OpType_Col2Im,
    OpType_Segment,
    OpType_Squeeze,
    OpType_StridedSlice,
    OpType_StringJoin,
    OpType_StringSplit,
    OpType_StringToNumber,
    OpType_TanH,
    OpType_TfQuantizedConv2D,
    OpType_Threshold,
    OpType_Tile,
    OpType_TopKV2,
    OpType_Transpose,
    OpType_UnaryOp,
    OpType_Unpack,
    OpType_Where,
    OpType_Moments,
    OpType_RNNSequenceGRU,
    OpType_BatchMatMul,
    OpType_Unsqueeze,
    OpType_CosineSimilarity,
    OpType_DepthToSpace,
    OpType_SpaceToDepth,
    OpType_ReverseSequence,
    OpType_Pooling3D,
    OpType_Convolution3D,
    OpType_MatrixBandPart,
    OpType_GatherND,
    OpType_DetectionPostProcess,
    OpType_UnravelIndex,
    OpType_ScatterNd,
    OpType_OneHot,
    OpType_BroadcastTo,
    OpType_Dilation2D,
    OpType_Interp3D,
    OpType_Raster,
    OpType_ConvertTensor,
    OpType_ArgMin,
    OpType_LinSpace,
    OpType_RandomUniform,
    OpType_TensorArray,
    OpType_TensorArraySize,
    OpType_TensorArrayRead,
    OpType_TensorArrayWrite,
    OpType_TensorArrayGather,
    OpType_TensorArrayScatter,
    OpType_TensorArraySplit,
    OpType_TensorArrayConcat,
    OpType_LSTMBlockCell,
    OpType_Reverse,
    OpType_ROIAlign,
    OpType_RandomNormal,
    OpType_TensorArrayInsert,
    OpType_TensorArrayErase,
    OpType_EyeLike,
    OpType_CumSum,
    OpType_Det,
    OpType_CumProd,
    OpType_ScatterElements,
    OpType_GatherElements,
    OpType_Svd,
    OpType_Histogram,
    OpType_DynamicQuant,
    OpType_Plugin,
    OpType_Select,
    OpType_ZerosLike,
    OpType_Broastcast,
    OpType_SetDiff1D,
    OpType_ReluGrad,
    OpType_Identity,
    OpType_PoolGrad,
    OpType_SoftmaxGrad,
    OpType_Conv2DBackPropFilter,
    OpType_TrainableParam,
    OpType_BatchNorm,
    OpType_ConvTranspose3D,
    OpType_ZeroGrad,
    OpType_Attention,
    OpType_FmhaV2,
    OpType_Fmhca,
    OpType_SeqLen2Spatial,
    OpType_SplitGeLU,
    OpType_GroupNorm,
    OpType_Extra,
    OpType_ConvInt8,
    OpType_Int8ToFloat,
    OpType_DepthwiseConvInt8,
    OpType_PoolInt8,
    OpType_FloatToInt8,
    OpType_EltwiseInt8,
    OpType_While,
    OpType_If,
    OpType_LayerNorm,
    OpType_GridSample
  };
  return values;
}

inline const char * const *EnumNamesOpType() {
  static const char * const names[] = {
    "AbsVal",
    "QuantizedAdd",
    "ArgMax",
    "AsString",
    "InstanceNorm",
    "BatchToSpaceND",
    "Copy",
    "BinaryOp",
    "Bnll",
    "Cast",
    "Concat",
    "Const",
    "Convolution",
    "ConvolutionDepthwise",
    "Crop",
    "CropAndResize",
    "ImageProcess",
    "Deconvolution",
    "DeconvolutionDepthwise",
    "Dequantize",
    "DetectionOutput",
    "Dropout",
    "Eltwise",
    "ELU",
    "Unique",
    "Exp",
    "ExpandDims",
    "Fill",
    "Flatten",
    "Im2Col",
    "Gather",
    "GatherV2",
    "Im2Seq",
    "InnerProduct",
    "Input",
    "Interp",
    "Log",
    "LRN",
    "LSTM",
    "MatMul",
    "MVN",
    "NonMaxSuppression",
    "NonMaxSuppressionV2",
    "Normalize",
    "Pack",
    "Padding",
    "Permute",
    "Pooling",
    "Power",
    "PReLU",
    "PriorBox",
    "Proposal",
    "QuantizedAvgPool",
    "QuantizedBiasAdd",
    "QuantizedConcat",
    "QuantizedDepthwiseConv2D",
    "QuantizedLogistic",
    "RasterAndInterpolate",
    "QuantizedMaxPool",
    "Texture",
    "RasterDiff",
    "QuantizedReshape",
    "QuantizedSoftmax",
    "QuantizeMaxMin",
    "QuantizeV2",
    "Range",
    "Rank",
    "ReduceJoin",
    "Reduction",
    "ReLU",
    "ReLU6",
    "RequantizationRange",
    "Requantize",
    "Reshape",
    "Resize",
    "RNN",
    "ROIPooling",
    "Scale",
    "Selu",
    "Seq2Out",
    "Shape",
    "Sigmoid",
    "Size",
    "Slice",
    "SliceTf",
    "Softmax",
    "SpaceToBatchND",
    "SpatialProduct",
    "Col2Im",
    "Segment",
    "Squeeze",
    "StridedSlice",
    "StringJoin",
    "StringSplit",
    "StringToNumber",
    "TanH",
    "TfQuantizedConv2D",
    "Threshold",
    "Tile",
    "TopKV2",
    "Transpose",
    "UnaryOp",
    "Unpack",
    "Where",
    "Moments",
    "RNNSequenceGRU",
    "BatchMatMul",
    "Unsqueeze",
    "CosineSimilarity",
    "DepthToSpace",
    "SpaceToDepth",
    "ReverseSequence",
    "Pooling3D",
    "Convolution3D",
    "MatrixBandPart",
    "GatherND",
    "DetectionPostProcess",
    "UnravelIndex",
    "ScatterNd",
    "OneHot",
    "BroadcastTo",
    "Dilation2D",
    "Interp3D",
    "",
    "",
    "",
    "",
    "",
    "Raster",
    "ConvertTensor",
    "ArgMin",
    "LinSpace",
    "RandomUniform",
    "TensorArray",
    "TensorArraySize",
    "TensorArrayRead",
    "TensorArrayWrite",
    "TensorArrayGather",
    "TensorArrayScatter",
    "TensorArraySplit",
    "TensorArrayConcat",
    "LSTMBlockCell",
    "Reverse",
    "ROIAlign",
    "RandomNormal",
    "TensorArrayInsert",
    "TensorArrayErase",
    "EyeLike",
    "CumSum",
    "Det",
    "CumProd",
    "ScatterElements",
    "GatherElements",
    "Svd",
    "Histogram",
    "DynamicQuant",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Plugin",
    "Select",
    "ZerosLike",
    "Broastcast",
    "SetDiff1D",
    "ReluGrad",
    "Identity",
    "PoolGrad",
    "SoftmaxGrad",
    "Conv2DBackPropFilter",
    "TrainableParam",
    "BatchNorm",
    "ConvTranspose3D",
    "ZeroGrad",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Attention",
    "FmhaV2",
    "Fmhca",
    "SeqLen2Spatial",
    "SplitGeLU",
    "GroupNorm",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Extra",
    "ConvInt8",
    "Int8ToFloat",
    "DepthwiseConvInt8",
    "PoolInt8",
    "FloatToInt8",
    "EltwiseInt8",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "While",
    "If",
    "",
    "LayerNorm",
    "GridSample",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpType(OpType e) {
  if (e < OpType_AbsVal || e > OpType_GridSample) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesOpType()[index];
}

enum OpParameter {
  OpParameter_NONE = 0,
  OpParameter_QuantizedAdd = 1,
  OpParameter_ArgMax = 2,
  OpParameter_AsString = 3,
  OpParameter_Axis = 4,
  OpParameter_BatchNorm = 5,
  OpParameter_BinaryOp = 6,
  OpParameter_Blob = 7,
  OpParameter_CastParam = 8,
  OpParameter_Convolution2D = 9,
  OpParameter_Crop = 10,
  OpParameter_CropAndResize = 11,
  OpParameter_Dequantize = 12,
  OpParameter_DetectionOutput = 13,
  OpParameter_Eltwise = 14,
  OpParameter_ExpandDims = 15,
  OpParameter_Fill = 16,
  OpParameter_Flatten = 17,
  OpParameter_Gather = 18,
  OpParameter_GatherV2 = 19,
  OpParameter_InnerProduct = 20,
  OpParameter_Input = 21,
  OpParameter_Interp = 22,
  OpParameter_LRN = 23,
  OpParameter_LSTM = 24,
  OpParameter_MatMul = 25,
  OpParameter_NonMaxSuppressionV2 = 26,
  OpParameter_Normalize = 27,
  OpParameter_PackParam = 28,
  OpParameter_Permute = 29,
  OpParameter_Plugin = 30,
  OpParameter_Pool = 31,
  OpParameter_PRelu = 32,
  OpParameter_PriorBox = 33,
  OpParameter_Proposal = 34,
  OpParameter_QuantizedAvgPool = 35,
  OpParameter_QuantizedBiasAdd = 36,
  OpParameter_QuantizedConcat = 37,
  OpParameter_QuantizedLogistic = 38,
  OpParameter_QuantizedMatMul = 39,
  OpParameter_QuantizedMaxPool = 40,
  OpParameter_QuantizedRelu = 41,
  OpParameter_QuantizedRelu6 = 42,
  OpParameter_QuantizedReshape = 43,
  OpParameter_QuantizedSoftmax = 44,
  OpParameter_QuantizeMaxMin = 45,
  OpParameter_QuantizeV2 = 46,
  OpParameter_Range = 47,
  OpParameter_Rank = 48,
  OpParameter_ReduceJoin = 49,
  OpParameter_ReductionParam = 50,
  OpParameter_Relu = 51,
  OpParameter_Relu6 = 52,
  OpParameter_RequantizationRange = 53,
  OpParameter_Requantize = 54,
  OpParameter_Reshape = 55,
  OpParameter_Resize = 56,
  OpParameter_RoiParameters = 57,
  OpParameter_Scale = 58,
  OpParameter_Selu = 59,
  OpParameter_Size = 60,
  OpParameter_Slice = 61,
  OpParameter_SliceTf = 62,
  OpParameter_SpaceBatch = 63,
  OpParameter_SqueezeParam = 64,
  OpParameter_StridedSliceParam = 65,
  OpParameter_TensorConvertInfo = 66,
  OpParameter_TfQuantizedConv2D = 67,
  OpParameter_TopKV2 = 68,
  OpParameter_Transpose = 69,
  OpParameter_UnaryOp = 70,
  OpParameter_MomentsParam = 71,
  OpParameter_RNNParam = 72,
  OpParameter_BatchMatMulParam = 73,
  OpParameter_QuantizedFloatParam = 74,
  OpParameter_DepthSpaceParam = 75,
  OpParameter_EltwiseInt8 = 76,
  OpParameter_ReverseSequenceParam = 77,
  OpParameter_Extra = 78,
  OpParameter_Pool3D = 79,
  OpParameter_Convolution3D = 80,
  OpParameter_ELU = 81,
  OpParameter_DetectionPostProcessParam = 82,
  OpParameter_OneHotParam = 83,
  OpParameter_PadParam = 84,
  OpParameter_WhileParam = 85,
  OpParameter_IfParam = 86,
  OpParameter_RandomUniform = 87,
  OpParameter_LayerNorm = 88,
  OpParameter_TensorArray = 89,
  OpParameter_LSTMBlockCell = 90,
  OpParameter_GridSample = 91,
  OpParameter_LoopParam = 92,
  OpParameter_ImageProcessParam = 93,
  OpParameter_CumSum = 94,
  OpParameter_GroupNorm = 95,
  OpParameter_FmhaV2Param = 96,
  OpParameter_FmhcaParam = 97,
  OpParameter_AttentionParam = 98,
  OpParameter_MIN = OpParameter_NONE,
  OpParameter_MAX = OpParameter_AttentionParam
};

inline const OpParameter (&EnumValuesOpParameter())[99] {
  static const OpParameter values[] = {
    OpParameter_NONE,
    OpParameter_QuantizedAdd,
    OpParameter_ArgMax,
    OpParameter_AsString,
    OpParameter_Axis,
    OpParameter_BatchNorm,
    OpParameter_BinaryOp,
    OpParameter_Blob,
    OpParameter_CastParam,
    OpParameter_Convolution2D,
    OpParameter_Crop,
    OpParameter_CropAndResize,
    OpParameter_Dequantize,
    OpParameter_DetectionOutput,
    OpParameter_Eltwise,
    OpParameter_ExpandDims,
    OpParameter_Fill,
    OpParameter_Flatten,
    OpParameter_Gather,
    OpParameter_GatherV2,
    OpParameter_InnerProduct,
    OpParameter_Input,
    OpParameter_Interp,
    OpParameter_LRN,
    OpParameter_LSTM,
    OpParameter_MatMul,
    OpParameter_NonMaxSuppressionV2,
    OpParameter_Normalize,
    OpParameter_PackParam,
    OpParameter_Permute,
    OpParameter_Plugin,
    OpParameter_Pool,
    OpParameter_PRelu,
    OpParameter_PriorBox,
    OpParameter_Proposal,
    OpParameter_QuantizedAvgPool,
    OpParameter_QuantizedBiasAdd,
    OpParameter_QuantizedConcat,
    OpParameter_QuantizedLogistic,
    OpParameter_QuantizedMatMul,
    OpParameter_QuantizedMaxPool,
    OpParameter_QuantizedRelu,
    OpParameter_QuantizedRelu6,
    OpParameter_QuantizedReshape,
    OpParameter_QuantizedSoftmax,
    OpParameter_QuantizeMaxMin,
    OpParameter_QuantizeV2,
    OpParameter_Range,
    OpParameter_Rank,
    OpParameter_ReduceJoin,
    OpParameter_ReductionParam,
    OpParameter_Relu,
    OpParameter_Relu6,
    OpParameter_RequantizationRange,
    OpParameter_Requantize,
    OpParameter_Reshape,
    OpParameter_Resize,
    OpParameter_RoiParameters,
    OpParameter_Scale,
    OpParameter_Selu,
    OpParameter_Size,
    OpParameter_Slice,
    OpParameter_SliceTf,
    OpParameter_SpaceBatch,
    OpParameter_SqueezeParam,
    OpParameter_StridedSliceParam,
    OpParameter_TensorConvertInfo,
    OpParameter_TfQuantizedConv2D,
    OpParameter_TopKV2,
    OpParameter_Transpose,
    OpParameter_UnaryOp,
    OpParameter_MomentsParam,
    OpParameter_RNNParam,
    OpParameter_BatchMatMulParam,
    OpParameter_QuantizedFloatParam,
    OpParameter_DepthSpaceParam,
    OpParameter_EltwiseInt8,
    OpParameter_ReverseSequenceParam,
    OpParameter_Extra,
    OpParameter_Pool3D,
    OpParameter_Convolution3D,
    OpParameter_ELU,
    OpParameter_DetectionPostProcessParam,
    OpParameter_OneHotParam,
    OpParameter_PadParam,
    OpParameter_WhileParam,
    OpParameter_IfParam,
    OpParameter_RandomUniform,
    OpParameter_LayerNorm,
    OpParameter_TensorArray,
    OpParameter_LSTMBlockCell,
    OpParameter_GridSample,
    OpParameter_LoopParam,
    OpParameter_ImageProcessParam,
    OpParameter_CumSum,
    OpParameter_GroupNorm,
    OpParameter_FmhaV2Param,
    OpParameter_FmhcaParam,
    OpParameter_AttentionParam
  };
  return values;
}

inline const char * const *EnumNamesOpParameter() {
  static const char * const names[] = {
    "NONE",
    "QuantizedAdd",
    "ArgMax",
    "AsString",
    "Axis",
    "BatchNorm",
    "BinaryOp",
    "Blob",
    "CastParam",
    "Convolution2D",
    "Crop",
    "CropAndResize",
    "Dequantize",
    "DetectionOutput",
    "Eltwise",
    "ExpandDims",
    "Fill",
    "Flatten",
    "Gather",
    "GatherV2",
    "InnerProduct",
    "Input",
    "Interp",
    "LRN",
    "LSTM",
    "MatMul",
    "NonMaxSuppressionV2",
    "Normalize",
    "PackParam",
    "Permute",
    "Plugin",
    "Pool",
    "PRelu",
    "PriorBox",
    "Proposal",
    "QuantizedAvgPool",
    "QuantizedBiasAdd",
    "QuantizedConcat",
    "QuantizedLogistic",
    "QuantizedMatMul",
    "QuantizedMaxPool",
    "QuantizedRelu",
    "QuantizedRelu6",
    "QuantizedReshape",
    "QuantizedSoftmax",
    "QuantizeMaxMin",
    "QuantizeV2",
    "Range",
    "Rank",
    "ReduceJoin",
    "ReductionParam",
    "Relu",
    "Relu6",
    "RequantizationRange",
    "Requantize",
    "Reshape",
    "Resize",
    "RoiParameters",
    "Scale",
    "Selu",
    "Size",
    "Slice",
    "SliceTf",
    "SpaceBatch",
    "SqueezeParam",
    "StridedSliceParam",
    "TensorConvertInfo",
    "TfQuantizedConv2D",
    "TopKV2",
    "Transpose",
    "UnaryOp",
    "MomentsParam",
    "RNNParam",
    "BatchMatMulParam",
    "QuantizedFloatParam",
    "DepthSpaceParam",
    "EltwiseInt8",
    "ReverseSequenceParam",
    "Extra",
    "Pool3D",
    "Convolution3D",
    "ELU",
    "DetectionPostProcessParam",
    "OneHotParam",
    "PadParam",
    "WhileParam",
    "IfParam",
    "RandomUniform",
    "LayerNorm",
    "TensorArray",
    "LSTMBlockCell",
    "GridSample",
    "LoopParam",
    "ImageProcessParam",
    "CumSum",
    "GroupNorm",
    "FmhaV2Param",
    "FmhcaParam",
    "AttentionParam",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpParameter(OpParameter e) {
  if (e < OpParameter_NONE || e > OpParameter_AttentionParam) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesOpParameter()[index];
}

template<typename T> struct OpParameterTraits {
  static const OpParameter enum_value = OpParameter_NONE;
};

template<> struct OpParameterTraits<QuantizedAdd> {
  static const OpParameter enum_value = OpParameter_QuantizedAdd;
};

template<> struct OpParameterTraits<ArgMax> {
  static const OpParameter enum_value = OpParameter_ArgMax;
};

template<> struct OpParameterTraits<AsString> {
  static const OpParameter enum_value = OpParameter_AsString;
};

template<> struct OpParameterTraits<Axis> {
  static const OpParameter enum_value = OpParameter_Axis;
};

template<> struct OpParameterTraits<BatchNorm> {
  static const OpParameter enum_value = OpParameter_BatchNorm;
};

template<> struct OpParameterTraits<BinaryOp> {
  static const OpParameter enum_value = OpParameter_BinaryOp;
};

template<> struct OpParameterTraits<Blob> {
  static const OpParameter enum_value = OpParameter_Blob;
};

template<> struct OpParameterTraits<CastParam> {
  static const OpParameter enum_value = OpParameter_CastParam;
};

template<> struct OpParameterTraits<Convolution2D> {
  static const OpParameter enum_value = OpParameter_Convolution2D;
};

template<> struct OpParameterTraits<Crop> {
  static const OpParameter enum_value = OpParameter_Crop;
};

template<> struct OpParameterTraits<CropAndResize> {
  static const OpParameter enum_value = OpParameter_CropAndResize;
};

template<> struct OpParameterTraits<Dequantize> {
  static const OpParameter enum_value = OpParameter_Dequantize;
};

template<> struct OpParameterTraits<DetectionOutput> {
  static const OpParameter enum_value = OpParameter_DetectionOutput;
};

template<> struct OpParameterTraits<Eltwise> {
  static const OpParameter enum_value = OpParameter_Eltwise;
};

template<> struct OpParameterTraits<ExpandDims> {
  static const OpParameter enum_value = OpParameter_ExpandDims;
};

template<> struct OpParameterTraits<Fill> {
  static const OpParameter enum_value = OpParameter_Fill;
};

template<> struct OpParameterTraits<Flatten> {
  static const OpParameter enum_value = OpParameter_Flatten;
};

template<> struct OpParameterTraits<Gather> {
  static const OpParameter enum_value = OpParameter_Gather;
};

template<> struct OpParameterTraits<GatherV2> {
  static const OpParameter enum_value = OpParameter_GatherV2;
};

template<> struct OpParameterTraits<InnerProduct> {
  static const OpParameter enum_value = OpParameter_InnerProduct;
};

template<> struct OpParameterTraits<Input> {
  static const OpParameter enum_value = OpParameter_Input;
};

template<> struct OpParameterTraits<Interp> {
  static const OpParameter enum_value = OpParameter_Interp;
};

template<> struct OpParameterTraits<LRN> {
  static const OpParameter enum_value = OpParameter_LRN;
};

template<> struct OpParameterTraits<LSTM> {
  static const OpParameter enum_value = OpParameter_LSTM;
};

template<> struct OpParameterTraits<MatMul> {
  static const OpParameter enum_value = OpParameter_MatMul;
};

template<> struct OpParameterTraits<NonMaxSuppressionV2> {
  static const OpParameter enum_value = OpParameter_NonMaxSuppressionV2;
};

template<> struct OpParameterTraits<Normalize> {
  static const OpParameter enum_value = OpParameter_Normalize;
};

template<> struct OpParameterTraits<PackParam> {
  static const OpParameter enum_value = OpParameter_PackParam;
};

template<> struct OpParameterTraits<Permute> {
  static const OpParameter enum_value = OpParameter_Permute;
};

template<> struct OpParameterTraits<Plugin> {
  static const OpParameter enum_value = OpParameter_Plugin;
};

template<> struct OpParameterTraits<Pool> {
  static const OpParameter enum_value = OpParameter_Pool;
};

template<> struct OpParameterTraits<PRelu> {
  static const OpParameter enum_value = OpParameter_PRelu;
};

template<> struct OpParameterTraits<PriorBox> {
  static const OpParameter enum_value = OpParameter_PriorBox;
};

template<> struct OpParameterTraits<Proposal> {
  static const OpParameter enum_value = OpParameter_Proposal;
};

template<> struct OpParameterTraits<QuantizedAvgPool> {
  static const OpParameter enum_value = OpParameter_QuantizedAvgPool;
};

template<> struct OpParameterTraits<QuantizedBiasAdd> {
  static const OpParameter enum_value = OpParameter_QuantizedBiasAdd;
};

template<> struct OpParameterTraits<QuantizedConcat> {
  static const OpParameter enum_value = OpParameter_QuantizedConcat;
};

template<> struct OpParameterTraits<QuantizedLogistic> {
  static const OpParameter enum_value = OpParameter_QuantizedLogistic;
};

template<> struct OpParameterTraits<QuantizedMatMul> {
  static const OpParameter enum_value = OpParameter_QuantizedMatMul;
};

template<> struct OpParameterTraits<QuantizedMaxPool> {
  static const OpParameter enum_value = OpParameter_QuantizedMaxPool;
};

template<> struct OpParameterTraits<QuantizedRelu> {
  static const OpParameter enum_value = OpParameter_QuantizedRelu;
};

template<> struct OpParameterTraits<QuantizedRelu6> {
  static const OpParameter enum_value = OpParameter_QuantizedRelu6;
};

template<> struct OpParameterTraits<QuantizedReshape> {
  static const OpParameter enum_value = OpParameter_QuantizedReshape;
};

template<> struct OpParameterTraits<QuantizedSoftmax> {
  static const OpParameter enum_value = OpParameter_QuantizedSoftmax;
};

template<> struct OpParameterTraits<QuantizeMaxMin> {
  static const OpParameter enum_value = OpParameter_QuantizeMaxMin;
};

template<> struct OpParameterTraits<QuantizeV2> {
  static const OpParameter enum_value = OpParameter_QuantizeV2;
};

template<> struct OpParameterTraits<Range> {
  static const OpParameter enum_value = OpParameter_Range;
};

template<> struct OpParameterTraits<Rank> {
  static const OpParameter enum_value = OpParameter_Rank;
};

template<> struct OpParameterTraits<ReduceJoin> {
  static const OpParameter enum_value = OpParameter_ReduceJoin;
};

template<> struct OpParameterTraits<ReductionParam> {
  static const OpParameter enum_value = OpParameter_ReductionParam;
};

template<> struct OpParameterTraits<Relu> {
  static const OpParameter enum_value = OpParameter_Relu;
};

template<> struct OpParameterTraits<Relu6> {
  static const OpParameter enum_value = OpParameter_Relu6;
};

template<> struct OpParameterTraits<RequantizationRange> {
  static const OpParameter enum_value = OpParameter_RequantizationRange;
};

template<> struct OpParameterTraits<Requantize> {
  static const OpParameter enum_value = OpParameter_Requantize;
};

template<> struct OpParameterTraits<Reshape> {
  static const OpParameter enum_value = OpParameter_Reshape;
};

template<> struct OpParameterTraits<Resize> {
  static const OpParameter enum_value = OpParameter_Resize;
};

template<> struct OpParameterTraits<RoiParameters> {
  static const OpParameter enum_value = OpParameter_RoiParameters;
};

template<> struct OpParameterTraits<Scale> {
  static const OpParameter enum_value = OpParameter_Scale;
};

template<> struct OpParameterTraits<Selu> {
  static const OpParameter enum_value = OpParameter_Selu;
};

template<> struct OpParameterTraits<Size> {
  static const OpParameter enum_value = OpParameter_Size;
};

template<> struct OpParameterTraits<Slice> {
  static const OpParameter enum_value = OpParameter_Slice;
};

template<> struct OpParameterTraits<SliceTf> {
  static const OpParameter enum_value = OpParameter_SliceTf;
};

template<> struct OpParameterTraits<SpaceBatch> {
  static const OpParameter enum_value = OpParameter_SpaceBatch;
};

template<> struct OpParameterTraits<SqueezeParam> {
  static const OpParameter enum_value = OpParameter_SqueezeParam;
};

template<> struct OpParameterTraits<StridedSliceParam> {
  static const OpParameter enum_value = OpParameter_StridedSliceParam;
};

template<> struct OpParameterTraits<TensorConvertInfo> {
  static const OpParameter enum_value = OpParameter_TensorConvertInfo;
};

template<> struct OpParameterTraits<TfQuantizedConv2D> {
  static const OpParameter enum_value = OpParameter_TfQuantizedConv2D;
};

template<> struct OpParameterTraits<TopKV2> {
  static const OpParameter enum_value = OpParameter_TopKV2;
};

template<> struct OpParameterTraits<Transpose> {
  static const OpParameter enum_value = OpParameter_Transpose;
};

template<> struct OpParameterTraits<UnaryOp> {
  static const OpParameter enum_value = OpParameter_UnaryOp;
};

template<> struct OpParameterTraits<MomentsParam> {
  static const OpParameter enum_value = OpParameter_MomentsParam;
};

template<> struct OpParameterTraits<RNNParam> {
  static const OpParameter enum_value = OpParameter_RNNParam;
};

template<> struct OpParameterTraits<BatchMatMulParam> {
  static const OpParameter enum_value = OpParameter_BatchMatMulParam;
};

template<> struct OpParameterTraits<QuantizedFloatParam> {
  static const OpParameter enum_value = OpParameter_QuantizedFloatParam;
};

template<> struct OpParameterTraits<DepthSpaceParam> {
  static const OpParameter enum_value = OpParameter_DepthSpaceParam;
};

template<> struct OpParameterTraits<EltwiseInt8> {
  static const OpParameter enum_value = OpParameter_EltwiseInt8;
};

template<> struct OpParameterTraits<ReverseSequenceParam> {
  static const OpParameter enum_value = OpParameter_ReverseSequenceParam;
};

template<> struct OpParameterTraits<Extra> {
  static const OpParameter enum_value = OpParameter_Extra;
};

template<> struct OpParameterTraits<Pool3D> {
  static const OpParameter enum_value = OpParameter_Pool3D;
};

template<> struct OpParameterTraits<Convolution3D> {
  static const OpParameter enum_value = OpParameter_Convolution3D;
};

template<> struct OpParameterTraits<ELU> {
  static const OpParameter enum_value = OpParameter_ELU;
};

template<> struct OpParameterTraits<DetectionPostProcessParam> {
  static const OpParameter enum_value = OpParameter_DetectionPostProcessParam;
};

template<> struct OpParameterTraits<OneHotParam> {
  static const OpParameter enum_value = OpParameter_OneHotParam;
};

template<> struct OpParameterTraits<PadParam> {
  static const OpParameter enum_value = OpParameter_PadParam;
};

template<> struct OpParameterTraits<WhileParam> {
  static const OpParameter enum_value = OpParameter_WhileParam;
};

template<> struct OpParameterTraits<IfParam> {
  static const OpParameter enum_value = OpParameter_IfParam;
};

template<> struct OpParameterTraits<RandomUniform> {
  static const OpParameter enum_value = OpParameter_RandomUniform;
};

template<> struct OpParameterTraits<LayerNorm> {
  static const OpParameter enum_value = OpParameter_LayerNorm;
};

template<> struct OpParameterTraits<TensorArray> {
  static const OpParameter enum_value = OpParameter_TensorArray;
};

template<> struct OpParameterTraits<LSTMBlockCell> {
  static const OpParameter enum_value = OpParameter_LSTMBlockCell;
};

template<> struct OpParameterTraits<GridSample> {
  static const OpParameter enum_value = OpParameter_GridSample;
};

template<> struct OpParameterTraits<LoopParam> {
  static const OpParameter enum_value = OpParameter_LoopParam;
};

template<> struct OpParameterTraits<ImageProcessParam> {
  static const OpParameter enum_value = OpParameter_ImageProcessParam;
};

template<> struct OpParameterTraits<CumSum> {
  static const OpParameter enum_value = OpParameter_CumSum;
};

template<> struct OpParameterTraits<GroupNorm> {
  static const OpParameter enum_value = OpParameter_GroupNorm;
};

template<> struct OpParameterTraits<FmhaV2Param> {
  static const OpParameter enum_value = OpParameter_FmhaV2Param;
};

template<> struct OpParameterTraits<FmhcaParam> {
  static const OpParameter enum_value = OpParameter_FmhcaParam;
};

template<> struct OpParameterTraits<AttentionParam> {
  static const OpParameter enum_value = OpParameter_AttentionParam;
};

struct OpParameterUnion {
  OpParameter type;
  void *value;

  OpParameterUnion() : type(OpParameter_NONE), value(nullptr) {}
  OpParameterUnion(OpParameterUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(OpParameter_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OpParameterUnion(const OpParameterUnion &) FLATBUFFERS_NOEXCEPT;
  OpParameterUnion &operator=(const OpParameterUnion &u) FLATBUFFERS_NOEXCEPT
    { OpParameterUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OpParameterUnion &operator=(OpParameterUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OpParameterUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = OpParameterTraits<typename T::TableType>::enum_value;
    if (type != OpParameter_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, OpParameter type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  QuantizedAddT *AsQuantizedAdd() {
    return type == OpParameter_QuantizedAdd ?
      reinterpret_cast<QuantizedAddT *>(value) : nullptr;
  }
  const QuantizedAddT *AsQuantizedAdd() const {
    return type == OpParameter_QuantizedAdd ?
      reinterpret_cast<const QuantizedAddT *>(value) : nullptr;
  }
  ArgMaxT *AsArgMax() {
    return type == OpParameter_ArgMax ?
      reinterpret_cast<ArgMaxT *>(value) : nullptr;
  }
  const ArgMaxT *AsArgMax() const {
    return type == OpParameter_ArgMax ?
      reinterpret_cast<const ArgMaxT *>(value) : nullptr;
  }
  AsStringT *AsAsString() {
    return type == OpParameter_AsString ?
      reinterpret_cast<AsStringT *>(value) : nullptr;
  }
  const AsStringT *AsAsString() const {
    return type == OpParameter_AsString ?
      reinterpret_cast<const AsStringT *>(value) : nullptr;
  }
  AxisT *AsAxis() {
    return type == OpParameter_Axis ?
      reinterpret_cast<AxisT *>(value) : nullptr;
  }
  const AxisT *AsAxis() const {
    return type == OpParameter_Axis ?
      reinterpret_cast<const AxisT *>(value) : nullptr;
  }
  BatchNormT *AsBatchNorm() {
    return type == OpParameter_BatchNorm ?
      reinterpret_cast<BatchNormT *>(value) : nullptr;
  }
  const BatchNormT *AsBatchNorm() const {
    return type == OpParameter_BatchNorm ?
      reinterpret_cast<const BatchNormT *>(value) : nullptr;
  }
  BinaryOpT *AsBinaryOp() {
    return type == OpParameter_BinaryOp ?
      reinterpret_cast<BinaryOpT *>(value) : nullptr;
  }
  const BinaryOpT *AsBinaryOp() const {
    return type == OpParameter_BinaryOp ?
      reinterpret_cast<const BinaryOpT *>(value) : nullptr;
  }
  BlobT *AsBlob() {
    return type == OpParameter_Blob ?
      reinterpret_cast<BlobT *>(value) : nullptr;
  }
  const BlobT *AsBlob() const {
    return type == OpParameter_Blob ?
      reinterpret_cast<const BlobT *>(value) : nullptr;
  }
  CastParamT *AsCastParam() {
    return type == OpParameter_CastParam ?
      reinterpret_cast<CastParamT *>(value) : nullptr;
  }
  const CastParamT *AsCastParam() const {
    return type == OpParameter_CastParam ?
      reinterpret_cast<const CastParamT *>(value) : nullptr;
  }
  Convolution2DT *AsConvolution2D() {
    return type == OpParameter_Convolution2D ?
      reinterpret_cast<Convolution2DT *>(value) : nullptr;
  }
  const Convolution2DT *AsConvolution2D() const {
    return type == OpParameter_Convolution2D ?
      reinterpret_cast<const Convolution2DT *>(value) : nullptr;
  }
  CropT *AsCrop() {
    return type == OpParameter_Crop ?
      reinterpret_cast<CropT *>(value) : nullptr;
  }
  const CropT *AsCrop() const {
    return type == OpParameter_Crop ?
      reinterpret_cast<const CropT *>(value) : nullptr;
  }
  CropAndResizeT *AsCropAndResize() {
    return type == OpParameter_CropAndResize ?
      reinterpret_cast<CropAndResizeT *>(value) : nullptr;
  }
  const CropAndResizeT *AsCropAndResize() const {
    return type == OpParameter_CropAndResize ?
      reinterpret_cast<const CropAndResizeT *>(value) : nullptr;
  }
  DequantizeT *AsDequantize() {
    return type == OpParameter_Dequantize ?
      reinterpret_cast<DequantizeT *>(value) : nullptr;
  }
  const DequantizeT *AsDequantize() const {
    return type == OpParameter_Dequantize ?
      reinterpret_cast<const DequantizeT *>(value) : nullptr;
  }
  DetectionOutputT *AsDetectionOutput() {
    return type == OpParameter_DetectionOutput ?
      reinterpret_cast<DetectionOutputT *>(value) : nullptr;
  }
  const DetectionOutputT *AsDetectionOutput() const {
    return type == OpParameter_DetectionOutput ?
      reinterpret_cast<const DetectionOutputT *>(value) : nullptr;
  }
  EltwiseT *AsEltwise() {
    return type == OpParameter_Eltwise ?
      reinterpret_cast<EltwiseT *>(value) : nullptr;
  }
  const EltwiseT *AsEltwise() const {
    return type == OpParameter_Eltwise ?
      reinterpret_cast<const EltwiseT *>(value) : nullptr;
  }
  ExpandDimsT *AsExpandDims() {
    return type == OpParameter_ExpandDims ?
      reinterpret_cast<ExpandDimsT *>(value) : nullptr;
  }
  const ExpandDimsT *AsExpandDims() const {
    return type == OpParameter_ExpandDims ?
      reinterpret_cast<const ExpandDimsT *>(value) : nullptr;
  }
  FillT *AsFill() {
    return type == OpParameter_Fill ?
      reinterpret_cast<FillT *>(value) : nullptr;
  }
  const FillT *AsFill() const {
    return type == OpParameter_Fill ?
      reinterpret_cast<const FillT *>(value) : nullptr;
  }
  FlattenT *AsFlatten() {
    return type == OpParameter_Flatten ?
      reinterpret_cast<FlattenT *>(value) : nullptr;
  }
  const FlattenT *AsFlatten() const {
    return type == OpParameter_Flatten ?
      reinterpret_cast<const FlattenT *>(value) : nullptr;
  }
  GatherT *AsGather() {
    return type == OpParameter_Gather ?
      reinterpret_cast<GatherT *>(value) : nullptr;
  }
  const GatherT *AsGather() const {
    return type == OpParameter_Gather ?
      reinterpret_cast<const GatherT *>(value) : nullptr;
  }
  GatherV2T *AsGatherV2() {
    return type == OpParameter_GatherV2 ?
      reinterpret_cast<GatherV2T *>(value) : nullptr;
  }
  const GatherV2T *AsGatherV2() const {
    return type == OpParameter_GatherV2 ?
      reinterpret_cast<const GatherV2T *>(value) : nullptr;
  }
  InnerProductT *AsInnerProduct() {
    return type == OpParameter_InnerProduct ?
      reinterpret_cast<InnerProductT *>(value) : nullptr;
  }
  const InnerProductT *AsInnerProduct() const {
    return type == OpParameter_InnerProduct ?
      reinterpret_cast<const InnerProductT *>(value) : nullptr;
  }
  InputT *AsInput() {
    return type == OpParameter_Input ?
      reinterpret_cast<InputT *>(value) : nullptr;
  }
  const InputT *AsInput() const {
    return type == OpParameter_Input ?
      reinterpret_cast<const InputT *>(value) : nullptr;
  }
  InterpT *AsInterp() {
    return type == OpParameter_Interp ?
      reinterpret_cast<InterpT *>(value) : nullptr;
  }
  const InterpT *AsInterp() const {
    return type == OpParameter_Interp ?
      reinterpret_cast<const InterpT *>(value) : nullptr;
  }
  LRNT *AsLRN() {
    return type == OpParameter_LRN ?
      reinterpret_cast<LRNT *>(value) : nullptr;
  }
  const LRNT *AsLRN() const {
    return type == OpParameter_LRN ?
      reinterpret_cast<const LRNT *>(value) : nullptr;
  }
  LSTMT *AsLSTM() {
    return type == OpParameter_LSTM ?
      reinterpret_cast<LSTMT *>(value) : nullptr;
  }
  const LSTMT *AsLSTM() const {
    return type == OpParameter_LSTM ?
      reinterpret_cast<const LSTMT *>(value) : nullptr;
  }
  MatMulT *AsMatMul() {
    return type == OpParameter_MatMul ?
      reinterpret_cast<MatMulT *>(value) : nullptr;
  }
  const MatMulT *AsMatMul() const {
    return type == OpParameter_MatMul ?
      reinterpret_cast<const MatMulT *>(value) : nullptr;
  }
  NonMaxSuppressionV2T *AsNonMaxSuppressionV2() {
    return type == OpParameter_NonMaxSuppressionV2 ?
      reinterpret_cast<NonMaxSuppressionV2T *>(value) : nullptr;
  }
  const NonMaxSuppressionV2T *AsNonMaxSuppressionV2() const {
    return type == OpParameter_NonMaxSuppressionV2 ?
      reinterpret_cast<const NonMaxSuppressionV2T *>(value) : nullptr;
  }
  NormalizeT *AsNormalize() {
    return type == OpParameter_Normalize ?
      reinterpret_cast<NormalizeT *>(value) : nullptr;
  }
  const NormalizeT *AsNormalize() const {
    return type == OpParameter_Normalize ?
      reinterpret_cast<const NormalizeT *>(value) : nullptr;
  }
  PackParamT *AsPackParam() {
    return type == OpParameter_PackParam ?
      reinterpret_cast<PackParamT *>(value) : nullptr;
  }
  const PackParamT *AsPackParam() const {
    return type == OpParameter_PackParam ?
      reinterpret_cast<const PackParamT *>(value) : nullptr;
  }
  PermuteT *AsPermute() {
    return type == OpParameter_Permute ?
      reinterpret_cast<PermuteT *>(value) : nullptr;
  }
  const PermuteT *AsPermute() const {
    return type == OpParameter_Permute ?
      reinterpret_cast<const PermuteT *>(value) : nullptr;
  }
  PluginT *AsPlugin() {
    return type == OpParameter_Plugin ?
      reinterpret_cast<PluginT *>(value) : nullptr;
  }
  const PluginT *AsPlugin() const {
    return type == OpParameter_Plugin ?
      reinterpret_cast<const PluginT *>(value) : nullptr;
  }
  PoolT *AsPool() {
    return type == OpParameter_Pool ?
      reinterpret_cast<PoolT *>(value) : nullptr;
  }
  const PoolT *AsPool() const {
    return type == OpParameter_Pool ?
      reinterpret_cast<const PoolT *>(value) : nullptr;
  }
  PReluT *AsPRelu() {
    return type == OpParameter_PRelu ?
      reinterpret_cast<PReluT *>(value) : nullptr;
  }
  const PReluT *AsPRelu() const {
    return type == OpParameter_PRelu ?
      reinterpret_cast<const PReluT *>(value) : nullptr;
  }
  PriorBoxT *AsPriorBox() {
    return type == OpParameter_PriorBox ?
      reinterpret_cast<PriorBoxT *>(value) : nullptr;
  }
  const PriorBoxT *AsPriorBox() const {
    return type == OpParameter_PriorBox ?
      reinterpret_cast<const PriorBoxT *>(value) : nullptr;
  }
  ProposalT *AsProposal() {
    return type == OpParameter_Proposal ?
      reinterpret_cast<ProposalT *>(value) : nullptr;
  }
  const ProposalT *AsProposal() const {
    return type == OpParameter_Proposal ?
      reinterpret_cast<const ProposalT *>(value) : nullptr;
  }
  QuantizedAvgPoolT *AsQuantizedAvgPool() {
    return type == OpParameter_QuantizedAvgPool ?
      reinterpret_cast<QuantizedAvgPoolT *>(value) : nullptr;
  }
  const QuantizedAvgPoolT *AsQuantizedAvgPool() const {
    return type == OpParameter_QuantizedAvgPool ?
      reinterpret_cast<const QuantizedAvgPoolT *>(value) : nullptr;
  }
  QuantizedBiasAddT *AsQuantizedBiasAdd() {
    return type == OpParameter_QuantizedBiasAdd ?
      reinterpret_cast<QuantizedBiasAddT *>(value) : nullptr;
  }
  const QuantizedBiasAddT *AsQuantizedBiasAdd() const {
    return type == OpParameter_QuantizedBiasAdd ?
      reinterpret_cast<const QuantizedBiasAddT *>(value) : nullptr;
  }
  QuantizedConcatT *AsQuantizedConcat() {
    return type == OpParameter_QuantizedConcat ?
      reinterpret_cast<QuantizedConcatT *>(value) : nullptr;
  }
  const QuantizedConcatT *AsQuantizedConcat() const {
    return type == OpParameter_QuantizedConcat ?
      reinterpret_cast<const QuantizedConcatT *>(value) : nullptr;
  }
  QuantizedLogisticT *AsQuantizedLogistic() {
    return type == OpParameter_QuantizedLogistic ?
      reinterpret_cast<QuantizedLogisticT *>(value) : nullptr;
  }
  const QuantizedLogisticT *AsQuantizedLogistic() const {
    return type == OpParameter_QuantizedLogistic ?
      reinterpret_cast<const QuantizedLogisticT *>(value) : nullptr;
  }
  QuantizedMatMulT *AsQuantizedMatMul() {
    return type == OpParameter_QuantizedMatMul ?
      reinterpret_cast<QuantizedMatMulT *>(value) : nullptr;
  }
  const QuantizedMatMulT *AsQuantizedMatMul() const {
    return type == OpParameter_QuantizedMatMul ?
      reinterpret_cast<const QuantizedMatMulT *>(value) : nullptr;
  }
  QuantizedMaxPoolT *AsQuantizedMaxPool() {
    return type == OpParameter_QuantizedMaxPool ?
      reinterpret_cast<QuantizedMaxPoolT *>(value) : nullptr;
  }
  const QuantizedMaxPoolT *AsQuantizedMaxPool() const {
    return type == OpParameter_QuantizedMaxPool ?
      reinterpret_cast<const QuantizedMaxPoolT *>(value) : nullptr;
  }
  QuantizedReluT *AsQuantizedRelu() {
    return type == OpParameter_QuantizedRelu ?
      reinterpret_cast<QuantizedReluT *>(value) : nullptr;
  }
  const QuantizedReluT *AsQuantizedRelu() const {
    return type == OpParameter_QuantizedRelu ?
      reinterpret_cast<const QuantizedReluT *>(value) : nullptr;
  }
  QuantizedRelu6T *AsQuantizedRelu6() {
    return type == OpParameter_QuantizedRelu6 ?
      reinterpret_cast<QuantizedRelu6T *>(value) : nullptr;
  }
  const QuantizedRelu6T *AsQuantizedRelu6() const {
    return type == OpParameter_QuantizedRelu6 ?
      reinterpret_cast<const QuantizedRelu6T *>(value) : nullptr;
  }
  QuantizedReshapeT *AsQuantizedReshape() {
    return type == OpParameter_QuantizedReshape ?
      reinterpret_cast<QuantizedReshapeT *>(value) : nullptr;
  }
  const QuantizedReshapeT *AsQuantizedReshape() const {
    return type == OpParameter_QuantizedReshape ?
      reinterpret_cast<const QuantizedReshapeT *>(value) : nullptr;
  }
  QuantizedSoftmaxT *AsQuantizedSoftmax() {
    return type == OpParameter_QuantizedSoftmax ?
      reinterpret_cast<QuantizedSoftmaxT *>(value) : nullptr;
  }
  const QuantizedSoftmaxT *AsQuantizedSoftmax() const {
    return type == OpParameter_QuantizedSoftmax ?
      reinterpret_cast<const QuantizedSoftmaxT *>(value) : nullptr;
  }
  QuantizeMaxMinT *AsQuantizeMaxMin() {
    return type == OpParameter_QuantizeMaxMin ?
      reinterpret_cast<QuantizeMaxMinT *>(value) : nullptr;
  }
  const QuantizeMaxMinT *AsQuantizeMaxMin() const {
    return type == OpParameter_QuantizeMaxMin ?
      reinterpret_cast<const QuantizeMaxMinT *>(value) : nullptr;
  }
  QuantizeV2T *AsQuantizeV2() {
    return type == OpParameter_QuantizeV2 ?
      reinterpret_cast<QuantizeV2T *>(value) : nullptr;
  }
  const QuantizeV2T *AsQuantizeV2() const {
    return type == OpParameter_QuantizeV2 ?
      reinterpret_cast<const QuantizeV2T *>(value) : nullptr;
  }
  RangeT *AsRange() {
    return type == OpParameter_Range ?
      reinterpret_cast<RangeT *>(value) : nullptr;
  }
  const RangeT *AsRange() const {
    return type == OpParameter_Range ?
      reinterpret_cast<const RangeT *>(value) : nullptr;
  }
  RankT *AsRank() {
    return type == OpParameter_Rank ?
      reinterpret_cast<RankT *>(value) : nullptr;
  }
  const RankT *AsRank() const {
    return type == OpParameter_Rank ?
      reinterpret_cast<const RankT *>(value) : nullptr;
  }
  ReduceJoinT *AsReduceJoin() {
    return type == OpParameter_ReduceJoin ?
      reinterpret_cast<ReduceJoinT *>(value) : nullptr;
  }
  const ReduceJoinT *AsReduceJoin() const {
    return type == OpParameter_ReduceJoin ?
      reinterpret_cast<const ReduceJoinT *>(value) : nullptr;
  }
  ReductionParamT *AsReductionParam() {
    return type == OpParameter_ReductionParam ?
      reinterpret_cast<ReductionParamT *>(value) : nullptr;
  }
  const ReductionParamT *AsReductionParam() const {
    return type == OpParameter_ReductionParam ?
      reinterpret_cast<const ReductionParamT *>(value) : nullptr;
  }
  ReluT *AsRelu() {
    return type == OpParameter_Relu ?
      reinterpret_cast<ReluT *>(value) : nullptr;
  }
  const ReluT *AsRelu() const {
    return type == OpParameter_Relu ?
      reinterpret_cast<const ReluT *>(value) : nullptr;
  }
  Relu6T *AsRelu6() {
    return type == OpParameter_Relu6 ?
      reinterpret_cast<Relu6T *>(value) : nullptr;
  }
  const Relu6T *AsRelu6() const {
    return type == OpParameter_Relu6 ?
      reinterpret_cast<const Relu6T *>(value) : nullptr;
  }
  RequantizationRangeT *AsRequantizationRange() {
    return type == OpParameter_RequantizationRange ?
      reinterpret_cast<RequantizationRangeT *>(value) : nullptr;
  }
  const RequantizationRangeT *AsRequantizationRange() const {
    return type == OpParameter_RequantizationRange ?
      reinterpret_cast<const RequantizationRangeT *>(value) : nullptr;
  }
  RequantizeT *AsRequantize() {
    return type == OpParameter_Requantize ?
      reinterpret_cast<RequantizeT *>(value) : nullptr;
  }
  const RequantizeT *AsRequantize() const {
    return type == OpParameter_Requantize ?
      reinterpret_cast<const RequantizeT *>(value) : nullptr;
  }
  ReshapeT *AsReshape() {
    return type == OpParameter_Reshape ?
      reinterpret_cast<ReshapeT *>(value) : nullptr;
  }
  const ReshapeT *AsReshape() const {
    return type == OpParameter_Reshape ?
      reinterpret_cast<const ReshapeT *>(value) : nullptr;
  }
  ResizeT *AsResize() {
    return type == OpParameter_Resize ?
      reinterpret_cast<ResizeT *>(value) : nullptr;
  }
  const ResizeT *AsResize() const {
    return type == OpParameter_Resize ?
      reinterpret_cast<const ResizeT *>(value) : nullptr;
  }
  RoiParametersT *AsRoiParameters() {
    return type == OpParameter_RoiParameters ?
      reinterpret_cast<RoiParametersT *>(value) : nullptr;
  }
  const RoiParametersT *AsRoiParameters() const {
    return type == OpParameter_RoiParameters ?
      reinterpret_cast<const RoiParametersT *>(value) : nullptr;
  }
  ScaleT *AsScale() {
    return type == OpParameter_Scale ?
      reinterpret_cast<ScaleT *>(value) : nullptr;
  }
  const ScaleT *AsScale() const {
    return type == OpParameter_Scale ?
      reinterpret_cast<const ScaleT *>(value) : nullptr;
  }
  SeluT *AsSelu() {
    return type == OpParameter_Selu ?
      reinterpret_cast<SeluT *>(value) : nullptr;
  }
  const SeluT *AsSelu() const {
    return type == OpParameter_Selu ?
      reinterpret_cast<const SeluT *>(value) : nullptr;
  }
  SizeT *AsSize() {
    return type == OpParameter_Size ?
      reinterpret_cast<SizeT *>(value) : nullptr;
  }
  const SizeT *AsSize() const {
    return type == OpParameter_Size ?
      reinterpret_cast<const SizeT *>(value) : nullptr;
  }
  SliceT *AsSlice() {
    return type == OpParameter_Slice ?
      reinterpret_cast<SliceT *>(value) : nullptr;
  }
  const SliceT *AsSlice() const {
    return type == OpParameter_Slice ?
      reinterpret_cast<const SliceT *>(value) : nullptr;
  }
  SliceTfT *AsSliceTf() {
    return type == OpParameter_SliceTf ?
      reinterpret_cast<SliceTfT *>(value) : nullptr;
  }
  const SliceTfT *AsSliceTf() const {
    return type == OpParameter_SliceTf ?
      reinterpret_cast<const SliceTfT *>(value) : nullptr;
  }
  SpaceBatchT *AsSpaceBatch() {
    return type == OpParameter_SpaceBatch ?
      reinterpret_cast<SpaceBatchT *>(value) : nullptr;
  }
  const SpaceBatchT *AsSpaceBatch() const {
    return type == OpParameter_SpaceBatch ?
      reinterpret_cast<const SpaceBatchT *>(value) : nullptr;
  }
  SqueezeParamT *AsSqueezeParam() {
    return type == OpParameter_SqueezeParam ?
      reinterpret_cast<SqueezeParamT *>(value) : nullptr;
  }
  const SqueezeParamT *AsSqueezeParam() const {
    return type == OpParameter_SqueezeParam ?
      reinterpret_cast<const SqueezeParamT *>(value) : nullptr;
  }
  StridedSliceParamT *AsStridedSliceParam() {
    return type == OpParameter_StridedSliceParam ?
      reinterpret_cast<StridedSliceParamT *>(value) : nullptr;
  }
  const StridedSliceParamT *AsStridedSliceParam() const {
    return type == OpParameter_StridedSliceParam ?
      reinterpret_cast<const StridedSliceParamT *>(value) : nullptr;
  }
  TensorConvertInfoT *AsTensorConvertInfo() {
    return type == OpParameter_TensorConvertInfo ?
      reinterpret_cast<TensorConvertInfoT *>(value) : nullptr;
  }
  const TensorConvertInfoT *AsTensorConvertInfo() const {
    return type == OpParameter_TensorConvertInfo ?
      reinterpret_cast<const TensorConvertInfoT *>(value) : nullptr;
  }
  TfQuantizedConv2DT *AsTfQuantizedConv2D() {
    return type == OpParameter_TfQuantizedConv2D ?
      reinterpret_cast<TfQuantizedConv2DT *>(value) : nullptr;
  }
  const TfQuantizedConv2DT *AsTfQuantizedConv2D() const {
    return type == OpParameter_TfQuantizedConv2D ?
      reinterpret_cast<const TfQuantizedConv2DT *>(value) : nullptr;
  }
  TopKV2T *AsTopKV2() {
    return type == OpParameter_TopKV2 ?
      reinterpret_cast<TopKV2T *>(value) : nullptr;
  }
  const TopKV2T *AsTopKV2() const {
    return type == OpParameter_TopKV2 ?
      reinterpret_cast<const TopKV2T *>(value) : nullptr;
  }
  TransposeT *AsTranspose() {
    return type == OpParameter_Transpose ?
      reinterpret_cast<TransposeT *>(value) : nullptr;
  }
  const TransposeT *AsTranspose() const {
    return type == OpParameter_Transpose ?
      reinterpret_cast<const TransposeT *>(value) : nullptr;
  }
  UnaryOpT *AsUnaryOp() {
    return type == OpParameter_UnaryOp ?
      reinterpret_cast<UnaryOpT *>(value) : nullptr;
  }
  const UnaryOpT *AsUnaryOp() const {
    return type == OpParameter_UnaryOp ?
      reinterpret_cast<const UnaryOpT *>(value) : nullptr;
  }
  MomentsParamT *AsMomentsParam() {
    return type == OpParameter_MomentsParam ?
      reinterpret_cast<MomentsParamT *>(value) : nullptr;
  }
  const MomentsParamT *AsMomentsParam() const {
    return type == OpParameter_MomentsParam ?
      reinterpret_cast<const MomentsParamT *>(value) : nullptr;
  }
  RNNParamT *AsRNNParam() {
    return type == OpParameter_RNNParam ?
      reinterpret_cast<RNNParamT *>(value) : nullptr;
  }
  const RNNParamT *AsRNNParam() const {
    return type == OpParameter_RNNParam ?
      reinterpret_cast<const RNNParamT *>(value) : nullptr;
  }
  BatchMatMulParamT *AsBatchMatMulParam() {
    return type == OpParameter_BatchMatMulParam ?
      reinterpret_cast<BatchMatMulParamT *>(value) : nullptr;
  }
  const BatchMatMulParamT *AsBatchMatMulParam() const {
    return type == OpParameter_BatchMatMulParam ?
      reinterpret_cast<const BatchMatMulParamT *>(value) : nullptr;
  }
  QuantizedFloatParamT *AsQuantizedFloatParam() {
    return type == OpParameter_QuantizedFloatParam ?
      reinterpret_cast<QuantizedFloatParamT *>(value) : nullptr;
  }
  const QuantizedFloatParamT *AsQuantizedFloatParam() const {
    return type == OpParameter_QuantizedFloatParam ?
      reinterpret_cast<const QuantizedFloatParamT *>(value) : nullptr;
  }
  DepthSpaceParamT *AsDepthSpaceParam() {
    return type == OpParameter_DepthSpaceParam ?
      reinterpret_cast<DepthSpaceParamT *>(value) : nullptr;
  }
  const DepthSpaceParamT *AsDepthSpaceParam() const {
    return type == OpParameter_DepthSpaceParam ?
      reinterpret_cast<const DepthSpaceParamT *>(value) : nullptr;
  }
  EltwiseInt8T *AsEltwiseInt8() {
    return type == OpParameter_EltwiseInt8 ?
      reinterpret_cast<EltwiseInt8T *>(value) : nullptr;
  }
  const EltwiseInt8T *AsEltwiseInt8() const {
    return type == OpParameter_EltwiseInt8 ?
      reinterpret_cast<const EltwiseInt8T *>(value) : nullptr;
  }
  ReverseSequenceParamT *AsReverseSequenceParam() {
    return type == OpParameter_ReverseSequenceParam ?
      reinterpret_cast<ReverseSequenceParamT *>(value) : nullptr;
  }
  const ReverseSequenceParamT *AsReverseSequenceParam() const {
    return type == OpParameter_ReverseSequenceParam ?
      reinterpret_cast<const ReverseSequenceParamT *>(value) : nullptr;
  }
  ExtraT *AsExtra() {
    return type == OpParameter_Extra ?
      reinterpret_cast<ExtraT *>(value) : nullptr;
  }
  const ExtraT *AsExtra() const {
    return type == OpParameter_Extra ?
      reinterpret_cast<const ExtraT *>(value) : nullptr;
  }
  Pool3DT *AsPool3D() {
    return type == OpParameter_Pool3D ?
      reinterpret_cast<Pool3DT *>(value) : nullptr;
  }
  const Pool3DT *AsPool3D() const {
    return type == OpParameter_Pool3D ?
      reinterpret_cast<const Pool3DT *>(value) : nullptr;
  }
  Convolution3DT *AsConvolution3D() {
    return type == OpParameter_Convolution3D ?
      reinterpret_cast<Convolution3DT *>(value) : nullptr;
  }
  const Convolution3DT *AsConvolution3D() const {
    return type == OpParameter_Convolution3D ?
      reinterpret_cast<const Convolution3DT *>(value) : nullptr;
  }
  ELUT *AsELU() {
    return type == OpParameter_ELU ?
      reinterpret_cast<ELUT *>(value) : nullptr;
  }
  const ELUT *AsELU() const {
    return type == OpParameter_ELU ?
      reinterpret_cast<const ELUT *>(value) : nullptr;
  }
  DetectionPostProcessParamT *AsDetectionPostProcessParam() {
    return type == OpParameter_DetectionPostProcessParam ?
      reinterpret_cast<DetectionPostProcessParamT *>(value) : nullptr;
  }
  const DetectionPostProcessParamT *AsDetectionPostProcessParam() const {
    return type == OpParameter_DetectionPostProcessParam ?
      reinterpret_cast<const DetectionPostProcessParamT *>(value) : nullptr;
  }
  OneHotParamT *AsOneHotParam() {
    return type == OpParameter_OneHotParam ?
      reinterpret_cast<OneHotParamT *>(value) : nullptr;
  }
  const OneHotParamT *AsOneHotParam() const {
    return type == OpParameter_OneHotParam ?
      reinterpret_cast<const OneHotParamT *>(value) : nullptr;
  }
  PadParamT *AsPadParam() {
    return type == OpParameter_PadParam ?
      reinterpret_cast<PadParamT *>(value) : nullptr;
  }
  const PadParamT *AsPadParam() const {
    return type == OpParameter_PadParam ?
      reinterpret_cast<const PadParamT *>(value) : nullptr;
  }
  WhileParamT *AsWhileParam() {
    return type == OpParameter_WhileParam ?
      reinterpret_cast<WhileParamT *>(value) : nullptr;
  }
  const WhileParamT *AsWhileParam() const {
    return type == OpParameter_WhileParam ?
      reinterpret_cast<const WhileParamT *>(value) : nullptr;
  }
  IfParamT *AsIfParam() {
    return type == OpParameter_IfParam ?
      reinterpret_cast<IfParamT *>(value) : nullptr;
  }
  const IfParamT *AsIfParam() const {
    return type == OpParameter_IfParam ?
      reinterpret_cast<const IfParamT *>(value) : nullptr;
  }
  RandomUniformT *AsRandomUniform() {
    return type == OpParameter_RandomUniform ?
      reinterpret_cast<RandomUniformT *>(value) : nullptr;
  }
  const RandomUniformT *AsRandomUniform() const {
    return type == OpParameter_RandomUniform ?
      reinterpret_cast<const RandomUniformT *>(value) : nullptr;
  }
  LayerNormT *AsLayerNorm() {
    return type == OpParameter_LayerNorm ?
      reinterpret_cast<LayerNormT *>(value) : nullptr;
  }
  const LayerNormT *AsLayerNorm() const {
    return type == OpParameter_LayerNorm ?
      reinterpret_cast<const LayerNormT *>(value) : nullptr;
  }
  TensorArrayT *AsTensorArray() {
    return type == OpParameter_TensorArray ?
      reinterpret_cast<TensorArrayT *>(value) : nullptr;
  }
  const TensorArrayT *AsTensorArray() const {
    return type == OpParameter_TensorArray ?
      reinterpret_cast<const TensorArrayT *>(value) : nullptr;
  }
  LSTMBlockCellT *AsLSTMBlockCell() {
    return type == OpParameter_LSTMBlockCell ?
      reinterpret_cast<LSTMBlockCellT *>(value) : nullptr;
  }
  const LSTMBlockCellT *AsLSTMBlockCell() const {
    return type == OpParameter_LSTMBlockCell ?
      reinterpret_cast<const LSTMBlockCellT *>(value) : nullptr;
  }
  GridSampleT *AsGridSample() {
    return type == OpParameter_GridSample ?
      reinterpret_cast<GridSampleT *>(value) : nullptr;
  }
  const GridSampleT *AsGridSample() const {
    return type == OpParameter_GridSample ?
      reinterpret_cast<const GridSampleT *>(value) : nullptr;
  }
  LoopParamT *AsLoopParam() {
    return type == OpParameter_LoopParam ?
      reinterpret_cast<LoopParamT *>(value) : nullptr;
  }
  const LoopParamT *AsLoopParam() const {
    return type == OpParameter_LoopParam ?
      reinterpret_cast<const LoopParamT *>(value) : nullptr;
  }
  ImageProcessParamT *AsImageProcessParam() {
    return type == OpParameter_ImageProcessParam ?
      reinterpret_cast<ImageProcessParamT *>(value) : nullptr;
  }
  const ImageProcessParamT *AsImageProcessParam() const {
    return type == OpParameter_ImageProcessParam ?
      reinterpret_cast<const ImageProcessParamT *>(value) : nullptr;
  }
  CumSumT *AsCumSum() {
    return type == OpParameter_CumSum ?
      reinterpret_cast<CumSumT *>(value) : nullptr;
  }
  const CumSumT *AsCumSum() const {
    return type == OpParameter_CumSum ?
      reinterpret_cast<const CumSumT *>(value) : nullptr;
  }
  GroupNormT *AsGroupNorm() {
    return type == OpParameter_GroupNorm ?
      reinterpret_cast<GroupNormT *>(value) : nullptr;
  }
  const GroupNormT *AsGroupNorm() const {
    return type == OpParameter_GroupNorm ?
      reinterpret_cast<const GroupNormT *>(value) : nullptr;
  }
  FmhaV2ParamT *AsFmhaV2Param() {
    return type == OpParameter_FmhaV2Param ?
      reinterpret_cast<FmhaV2ParamT *>(value) : nullptr;
  }
  const FmhaV2ParamT *AsFmhaV2Param() const {
    return type == OpParameter_FmhaV2Param ?
      reinterpret_cast<const FmhaV2ParamT *>(value) : nullptr;
  }
  FmhcaParamT *AsFmhcaParam() {
    return type == OpParameter_FmhcaParam ?
      reinterpret_cast<FmhcaParamT *>(value) : nullptr;
  }
  const FmhcaParamT *AsFmhcaParam() const {
    return type == OpParameter_FmhcaParam ?
      reinterpret_cast<const FmhcaParamT *>(value) : nullptr;
  }
  AttentionParamT *AsAttentionParam() {
    return type == OpParameter_AttentionParam ?
      reinterpret_cast<AttentionParamT *>(value) : nullptr;
  }
  const AttentionParamT *AsAttentionParam() const {
    return type == OpParameter_AttentionParam ?
      reinterpret_cast<const AttentionParamT *>(value) : nullptr;
  }
};

bool VerifyOpParameter(flatbuffers::Verifier &verifier, const void *obj, OpParameter type);
bool VerifyOpParameterVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ForwardType {
  ForwardType_CPU = 0,
  ForwardType_METAL = 1,
  ForwardType_OPENCL = 2,
  ForwardType_OPENGLES = 3,
  ForwardType_VULKAN = 4,
  ForwardType_MIN = ForwardType_CPU,
  ForwardType_MAX = ForwardType_VULKAN
};

inline const ForwardType (&EnumValuesForwardType())[5] {
  static const ForwardType values[] = {
    ForwardType_CPU,
    ForwardType_METAL,
    ForwardType_OPENCL,
    ForwardType_OPENGLES,
    ForwardType_VULKAN
  };
  return values;
}

inline const char * const *EnumNamesForwardType() {
  static const char * const names[] = {
    "CPU",
    "METAL",
    "OPENCL",
    "OPENGLES",
    "VULKAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameForwardType(ForwardType e) {
  if (e < ForwardType_CPU || e > ForwardType_VULKAN) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesForwardType()[index];
}

enum Usage {
  Usage_INFERENCE = 0,
  Usage_TRAIN = 1,
  Usage_INFERENCE_STATIC = 2,
  Usage_MIN = Usage_INFERENCE,
  Usage_MAX = Usage_INFERENCE_STATIC
};

inline const Usage (&EnumValuesUsage())[3] {
  static const Usage values[] = {
    Usage_INFERENCE,
    Usage_TRAIN,
    Usage_INFERENCE_STATIC
  };
  return values;
}

inline const char * const *EnumNamesUsage() {
  static const char * const names[] = {
    "INFERENCE",
    "TRAIN",
    "INFERENCE_STATIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameUsage(Usage e) {
  if (e < Usage_INFERENCE || e > Usage_INFERENCE_STATIC) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesUsage()[index];
}

struct PluginT : public flatbuffers::NativeTable {
  typedef Plugin TableType;
  std::string type;
  std::vector<std::unique_ptr<AttributeT>> attr;
  PluginT() {
  }
};

struct Plugin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PluginT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PluginTypeTable();
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Attribute>> *attr() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Attribute>> *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           verifier.EndTable();
  }
  PluginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PluginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Plugin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PluginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PluginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(4, type);
  }
  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attribute>>> attr) {
    fbb_.AddOffset(6, attr);
  }
  explicit PluginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PluginBuilder &operator=(const PluginBuilder &);
  flatbuffers::Offset<Plugin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Plugin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Plugin> CreatePlugin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attribute>>> attr = 0) {
  PluginBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Plugin> CreatePlugin(flatbuffers::FlatBufferBuilder &_fbb, const PluginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExtraT : public flatbuffers::NativeTable {
  typedef Extra TableType;
  std::string type;
  std::string engine;
  std::vector<int8_t> info;
  std::vector<std::unique_ptr<AttributeT>> attr;
  bool vector;
  ExtraT()
      : vector(false) {
  }
};

struct Extra FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExtraT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExtraTypeTable();
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::String *engine() const {
    return GetPointer<const flatbuffers::String *>(6);
  }
  const flatbuffers::Vector<int8_t> *info() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Attribute>> *attr() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Attribute>> *>(10);
  }
  bool vector() const {
    return GetField<uint8_t>(12, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyString(engine()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(info()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           VerifyField<uint8_t>(verifier, 12) &&
           verifier.EndTable();
  }
  ExtraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExtraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Extra> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExtraBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(4, type);
  }
  void add_engine(flatbuffers::Offset<flatbuffers::String> engine) {
    fbb_.AddOffset(6, engine);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<int8_t>> info) {
    fbb_.AddOffset(8, info);
  }
  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attribute>>> attr) {
    fbb_.AddOffset(10, attr);
  }
  void add_vector(bool vector) {
    fbb_.AddElement<uint8_t>(12, static_cast<uint8_t>(vector), 0);
  }
  explicit ExtraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExtraBuilder &operator=(const ExtraBuilder &);
  flatbuffers::Offset<Extra> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Extra>(end);
    return o;
  }
};

inline flatbuffers::Offset<Extra> CreateExtra(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> engine = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attribute>>> attr = 0,
    bool vector = false) {
  ExtraBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_info(info);
  builder_.add_engine(engine);
  builder_.add_type(type);
  builder_.add_vector(vector);
  return builder_.Finish();
}

flatbuffers::Offset<Extra> CreateExtra(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StringVecT : public flatbuffers::NativeTable {
  typedef StringVec TableType;
  std::vector<std::string> data;
  StringVecT() {
  }
};

struct StringVec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringVecT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StringVecTypeTable();
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfStrings(data()) &&
           verifier.EndTable();
  }
  StringVecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringVecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StringVec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringVecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringVecBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> data) {
    fbb_.AddOffset(4, data);
  }
  explicit StringVecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringVecBuilder &operator=(const StringVecBuilder &);
  flatbuffers::Offset<StringVec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringVec>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringVec> CreateStringVec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> data = 0) {
  StringVecBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

flatbuffers::Offset<StringVec> CreateStringVec(flatbuffers::FlatBufferBuilder &_fbb, const StringVecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttentionParamT : public flatbuffers::NativeTable {
  typedef AttentionParam TableType;
  bool kv_cache;
  AttentionParamT()
      : kv_cache(true) {
  }
};

struct AttentionParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttentionParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AttentionParamTypeTable();
  }
  bool kv_cache() const {
    return GetField<uint8_t>(4, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  AttentionParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttentionParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttentionParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttentionParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttentionParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kv_cache(bool kv_cache) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(kv_cache), 1);
  }
  explicit AttentionParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttentionParamBuilder &operator=(const AttentionParamBuilder &);
  flatbuffers::Offset<AttentionParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttentionParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttentionParam> CreateAttentionParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool kv_cache = true) {
  AttentionParamBuilder builder_(_fbb);
  builder_.add_kv_cache(kv_cache);
  return builder_.Finish();
}

flatbuffers::Offset<AttentionParam> CreateAttentionParam(flatbuffers::FlatBufferBuilder &_fbb, const AttentionParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FmhaV2ParamT : public flatbuffers::NativeTable {
  typedef FmhaV2Param TableType;
  int32_t heads;
  FmhaV2ParamT()
      : heads(0) {
  }
};

struct FmhaV2Param FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FmhaV2ParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FmhaV2ParamTypeTable();
  }
  int32_t heads() const {
    return GetField<int32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  FmhaV2ParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FmhaV2ParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FmhaV2Param> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FmhaV2ParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FmhaV2ParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_heads(int32_t heads) {
    fbb_.AddElement<int32_t>(4, heads, 0);
  }
  explicit FmhaV2ParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FmhaV2ParamBuilder &operator=(const FmhaV2ParamBuilder &);
  flatbuffers::Offset<FmhaV2Param> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FmhaV2Param>(end);
    return o;
  }
};

inline flatbuffers::Offset<FmhaV2Param> CreateFmhaV2Param(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t heads = 0) {
  FmhaV2ParamBuilder builder_(_fbb);
  builder_.add_heads(heads);
  return builder_.Finish();
}

flatbuffers::Offset<FmhaV2Param> CreateFmhaV2Param(flatbuffers::FlatBufferBuilder &_fbb, const FmhaV2ParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FmhcaParamT : public flatbuffers::NativeTable {
  typedef FmhcaParam TableType;
  int32_t heads;
  FmhcaParamT()
      : heads(0) {
  }
};

struct FmhcaParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FmhcaParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FmhcaParamTypeTable();
  }
  int32_t heads() const {
    return GetField<int32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  FmhcaParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FmhcaParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FmhcaParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FmhcaParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FmhcaParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_heads(int32_t heads) {
    fbb_.AddElement<int32_t>(4, heads, 0);
  }
  explicit FmhcaParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FmhcaParamBuilder &operator=(const FmhcaParamBuilder &);
  flatbuffers::Offset<FmhcaParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FmhcaParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<FmhcaParam> CreateFmhcaParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t heads = 0) {
  FmhcaParamBuilder builder_(_fbb);
  builder_.add_heads(heads);
  return builder_.Finish();
}

flatbuffers::Offset<FmhcaParam> CreateFmhcaParam(flatbuffers::FlatBufferBuilder &_fbb, const FmhcaParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhileParamT : public flatbuffers::NativeTable {
  typedef WhileParam TableType;
  std::string cond_graph;
  std::string body_graph;
  std::vector<std::unique_ptr<StringVecT>> aliases_inputs;
  std::vector<std::string> aliases_outputs;
  std::vector<std::unique_ptr<StringVecT>> aliases_updates;
  WhileParamT() {
  }
};

struct WhileParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WhileParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WhileParamTypeTable();
  }
  const flatbuffers::String *cond_graph() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::String *body_graph() const {
    return GetPointer<const flatbuffers::String *>(6);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StringVec>> *aliases_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringVec>> *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *aliases_outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(10);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StringVec>> *aliases_updates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringVec>> *>(12);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(cond_graph()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyString(body_graph()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(aliases_inputs()) &&
           verifier.VerifyVectorOfTables(aliases_inputs()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(aliases_outputs()) &&
           verifier.VerifyVectorOfStrings(aliases_outputs()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(aliases_updates()) &&
           verifier.VerifyVectorOfTables(aliases_updates()) &&
           verifier.EndTable();
  }
  WhileParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhileParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WhileParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhileParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cond_graph(flatbuffers::Offset<flatbuffers::String> cond_graph) {
    fbb_.AddOffset(4, cond_graph);
  }
  void add_body_graph(flatbuffers::Offset<flatbuffers::String> body_graph) {
    fbb_.AddOffset(6, body_graph);
  }
  void add_aliases_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringVec>>> aliases_inputs) {
    fbb_.AddOffset(8, aliases_inputs);
  }
  void add_aliases_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> aliases_outputs) {
    fbb_.AddOffset(10, aliases_outputs);
  }
  void add_aliases_updates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringVec>>> aliases_updates) {
    fbb_.AddOffset(12, aliases_updates);
  }
  explicit WhileParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhileParamBuilder &operator=(const WhileParamBuilder &);
  flatbuffers::Offset<WhileParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhileParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhileParam> CreateWhileParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> cond_graph = 0,
    flatbuffers::Offset<flatbuffers::String> body_graph = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringVec>>> aliases_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> aliases_outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringVec>>> aliases_updates = 0) {
  WhileParamBuilder builder_(_fbb);
  builder_.add_aliases_updates(aliases_updates);
  builder_.add_aliases_outputs(aliases_outputs);
  builder_.add_aliases_inputs(aliases_inputs);
  builder_.add_body_graph(body_graph);
  builder_.add_cond_graph(cond_graph);
  return builder_.Finish();
}

flatbuffers::Offset<WhileParam> CreateWhileParam(flatbuffers::FlatBufferBuilder &_fbb, const WhileParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IfParamT : public flatbuffers::NativeTable {
  typedef IfParam TableType;
  std::string then_graph;
  std::string else_graph;
  std::vector<std::unique_ptr<StringVecT>> aliases_inputs;
  std::vector<std::unique_ptr<StringVecT>> aliases_outputs;
  IfParamT() {
  }
};

struct IfParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IfParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IfParamTypeTable();
  }
  const flatbuffers::String *then_graph() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::String *else_graph() const {
    return GetPointer<const flatbuffers::String *>(6);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StringVec>> *aliases_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringVec>> *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StringVec>> *aliases_outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringVec>> *>(10);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(then_graph()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyString(else_graph()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(aliases_inputs()) &&
           verifier.VerifyVectorOfTables(aliases_inputs()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(aliases_outputs()) &&
           verifier.VerifyVectorOfTables(aliases_outputs()) &&
           verifier.EndTable();
  }
  IfParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IfParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IfParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IfParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_then_graph(flatbuffers::Offset<flatbuffers::String> then_graph) {
    fbb_.AddOffset(4, then_graph);
  }
  void add_else_graph(flatbuffers::Offset<flatbuffers::String> else_graph) {
    fbb_.AddOffset(6, else_graph);
  }
  void add_aliases_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringVec>>> aliases_inputs) {
    fbb_.AddOffset(8, aliases_inputs);
  }
  void add_aliases_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringVec>>> aliases_outputs) {
    fbb_.AddOffset(10, aliases_outputs);
  }
  explicit IfParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IfParamBuilder &operator=(const IfParamBuilder &);
  flatbuffers::Offset<IfParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IfParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<IfParam> CreateIfParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> then_graph = 0,
    flatbuffers::Offset<flatbuffers::String> else_graph = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringVec>>> aliases_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringVec>>> aliases_outputs = 0) {
  IfParamBuilder builder_(_fbb);
  builder_.add_aliases_outputs(aliases_outputs);
  builder_.add_aliases_inputs(aliases_inputs);
  builder_.add_else_graph(else_graph);
  builder_.add_then_graph(then_graph);
  return builder_.Finish();
}

flatbuffers::Offset<IfParam> CreateIfParam(flatbuffers::FlatBufferBuilder &_fbb, const IfParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegionCommandT : public flatbuffers::NativeTable {
  typedef RegionCommand TableType;
  std::unique_ptr<OpT> op;
  std::vector<int32_t> steps;
  std::vector<int32_t> size;
  std::vector<int32_t> indexes;
  std::vector<std::unique_ptr<ViewT>> view;
  int32_t fuse;
  std::vector<int32_t> iterIndexes;
  RegionCommandT()
      : fuse(-1) {
  }
};

struct RegionCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegionCommandT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RegionCommandTypeTable();
  }
  const Op *op() const {
    return GetPointer<const Op *>(4);
  }
  const flatbuffers::Vector<int32_t> *steps() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  const flatbuffers::Vector<int32_t> *indexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(10);
  }
  const flatbuffers::Vector<flatbuffers::Offset<View>> *view() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<View>> *>(12);
  }
  int32_t fuse() const {
    return GetField<int32_t>(14, -1);
  }
  const flatbuffers::Vector<int32_t> *iterIndexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(16);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyTable(op()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(steps()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(size()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(indexes()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(view()) &&
           verifier.VerifyVectorOfTables(view()) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyOffset(verifier, 16) &&
           verifier.VerifyVector(iterIndexes()) &&
           verifier.EndTable();
  }
  RegionCommandT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegionCommandT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RegionCommand> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionCommandT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegionCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_op(flatbuffers::Offset<Op> op) {
    fbb_.AddOffset(4, op);
  }
  void add_steps(flatbuffers::Offset<flatbuffers::Vector<int32_t>> steps) {
    fbb_.AddOffset(6, steps);
  }
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(8, size);
  }
  void add_indexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> indexes) {
    fbb_.AddOffset(10, indexes);
  }
  void add_view(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<View>>> view) {
    fbb_.AddOffset(12, view);
  }
  void add_fuse(int32_t fuse) {
    fbb_.AddElement<int32_t>(14, fuse, -1);
  }
  void add_iterIndexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> iterIndexes) {
    fbb_.AddOffset(16, iterIndexes);
  }
  explicit RegionCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegionCommandBuilder &operator=(const RegionCommandBuilder &);
  flatbuffers::Offset<RegionCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegionCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegionCommand> CreateRegionCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Op> op = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> steps = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> indexes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<View>>> view = 0,
    int32_t fuse = -1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> iterIndexes = 0) {
  RegionCommandBuilder builder_(_fbb);
  builder_.add_iterIndexes(iterIndexes);
  builder_.add_fuse(fuse);
  builder_.add_view(view);
  builder_.add_indexes(indexes);
  builder_.add_size(size);
  builder_.add_steps(steps);
  builder_.add_op(op);
  return builder_.Finish();
}

flatbuffers::Offset<RegionCommand> CreateRegionCommand(flatbuffers::FlatBufferBuilder &_fbb, const RegionCommandT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoopParamT : public flatbuffers::NativeTable {
  typedef LoopParam TableType;
  int32_t tensorNumber;
  std::vector<int32_t> outputIndexes;
  std::vector<int32_t> inputIndexes;
  std::vector<std::unique_ptr<TensorDescribeT>> extraTensorInfos;
  bool parallel;
  int32_t loopNumber;
  std::vector<std::unique_ptr<RegionCommandT>> commands;
  std::vector<std::unique_ptr<RegionCommandT>> initCommand;
  LoopParamT()
      : tensorNumber(0),
        parallel(true),
        loopNumber(0) {
  }
};

struct LoopParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoopParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LoopParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSORNUMBER = 4,
    VT_OUTPUTINDEXES = 6,
    VT_INPUTINDEXES = 8,
    VT_EXTRATENSORINFOS = 10,
    VT_PARALLEL = 12,
    VT_LOOPNUMBER = 14,
    VT_COMMANDS = 16,
    VT_INITCOMMAND = 18
  };
  int32_t tensorNumber() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<int32_t> *outputIndexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<int32_t> *inputIndexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>> *extraTensorInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>> *>(10);
  }
  bool parallel() const {
    return GetField<uint8_t>(12, 1) != 0;
  }
  int32_t loopNumber() const {
    return GetField<int32_t>(14, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RegionCommand>> *commands() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RegionCommand>> *>(16);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RegionCommand>> *initCommand() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RegionCommand>> *>(18);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(outputIndexes()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(inputIndexes()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(extraTensorInfos()) &&
           verifier.VerifyVectorOfTables(extraTensorInfos()) &&
           VerifyField<uint8_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyOffset(verifier, 16) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyVector(initCommand()) &&
           verifier.VerifyVectorOfTables(initCommand()) &&
           verifier.EndTable();
  }
  LoopParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoopParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoopParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoopParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoopParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensorNumber(int32_t tensorNumber) {
    fbb_.AddElement<int32_t>(4, tensorNumber, 0);
  }
  void add_outputIndexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputIndexes) {
    fbb_.AddOffset(6, outputIndexes);
  }
  void add_inputIndexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputIndexes) {
    fbb_.AddOffset(8, inputIndexes);
  }
  void add_extraTensorInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>>> extraTensorInfos) {
    fbb_.AddOffset(10, extraTensorInfos);
  }
  void add_parallel(bool parallel) {
    fbb_.AddElement<uint8_t>(12, static_cast<uint8_t>(parallel), 1);
  }
  void add_loopNumber(int32_t loopNumber) {
    fbb_.AddElement<int32_t>(14, loopNumber, 0);
  }
  void add_commands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RegionCommand>>> commands) {
    fbb_.AddOffset(16, commands);
  }
  void add_initCommand(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RegionCommand>>> initCommand) {
    fbb_.AddOffset(18, initCommand);
  }
  explicit LoopParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoopParamBuilder &operator=(const LoopParamBuilder &);
  flatbuffers::Offset<LoopParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoopParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoopParam> CreateLoopParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tensorNumber = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputIndexes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputIndexes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>>> extraTensorInfos = 0,
    bool parallel = true,
    int32_t loopNumber = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RegionCommand>>> commands = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RegionCommand>>> initCommand = 0) {
  LoopParamBuilder builder_(_fbb);
  builder_.add_initCommand(initCommand);
  builder_.add_commands(commands);
  builder_.add_loopNumber(loopNumber);
  builder_.add_extraTensorInfos(extraTensorInfos);
  builder_.add_inputIndexes(inputIndexes);
  builder_.add_outputIndexes(outputIndexes);
  builder_.add_tensorNumber(tensorNumber);
  builder_.add_parallel(parallel);
  return builder_.Finish();
}

flatbuffers::Offset<LoopParam> CreateLoopParam(flatbuffers::FlatBufferBuilder &_fbb, const LoopParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpT : public flatbuffers::NativeTable {
  typedef Op TableType;
  std::vector<int32_t> inputIndexes;
  OpParameterUnion main;
  std::string name;
  std::vector<int32_t> outputIndexes;
  OpType type;
  MNN_DATA_FORMAT defaultDimentionFormat;
  std::string externalPath;
  OpT()
      : type(OpType_AbsVal),
        defaultDimentionFormat(MNN_DATA_FORMAT_NHWC) {
  }
};

struct Op FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpTypeTable();
  }
  const flatbuffers::Vector<int32_t> *inputIndexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  OpParameter main_type() const {
    return static_cast<OpParameter>(GetField<uint8_t>(6, 0));
  }
  const void *main() const {
    return GetPointer<const void *>(8);
  }
  template<typename T> const T *main_as() const;
  const QuantizedAdd *main_as_QuantizedAdd() const {
    return main_type() == OpParameter_QuantizedAdd ? static_cast<const QuantizedAdd *>(main()) : nullptr;
  }
  const ArgMax *main_as_ArgMax() const {
    return main_type() == OpParameter_ArgMax ? static_cast<const ArgMax *>(main()) : nullptr;
  }
  const AsString *main_as_AsString() const {
    return main_type() == OpParameter_AsString ? static_cast<const AsString *>(main()) : nullptr;
  }
  const Axis *main_as_Axis() const {
    return main_type() == OpParameter_Axis ? static_cast<const Axis *>(main()) : nullptr;
  }
  const BatchNorm *main_as_BatchNorm() const {
    return main_type() == OpParameter_BatchNorm ? static_cast<const BatchNorm *>(main()) : nullptr;
  }
  const BinaryOp *main_as_BinaryOp() const {
    return main_type() == OpParameter_BinaryOp ? static_cast<const BinaryOp *>(main()) : nullptr;
  }
  const Blob *main_as_Blob() const {
    return main_type() == OpParameter_Blob ? static_cast<const Blob *>(main()) : nullptr;
  }
  const CastParam *main_as_CastParam() const {
    return main_type() == OpParameter_CastParam ? static_cast<const CastParam *>(main()) : nullptr;
  }
  const Convolution2D *main_as_Convolution2D() const {
    return main_type() == OpParameter_Convolution2D ? static_cast<const Convolution2D *>(main()) : nullptr;
  }
  const Crop *main_as_Crop() const {
    return main_type() == OpParameter_Crop ? static_cast<const Crop *>(main()) : nullptr;
  }
  const CropAndResize *main_as_CropAndResize() const {
    return main_type() == OpParameter_CropAndResize ? static_cast<const CropAndResize *>(main()) : nullptr;
  }
  const Dequantize *main_as_Dequantize() const {
    return main_type() == OpParameter_Dequantize ? static_cast<const Dequantize *>(main()) : nullptr;
  }
  const DetectionOutput *main_as_DetectionOutput() const {
    return main_type() == OpParameter_DetectionOutput ? static_cast<const DetectionOutput *>(main()) : nullptr;
  }
  const Eltwise *main_as_Eltwise() const {
    return main_type() == OpParameter_Eltwise ? static_cast<const Eltwise *>(main()) : nullptr;
  }
  const ExpandDims *main_as_ExpandDims() const {
    return main_type() == OpParameter_ExpandDims ? static_cast<const ExpandDims *>(main()) : nullptr;
  }
  const Fill *main_as_Fill() const {
    return main_type() == OpParameter_Fill ? static_cast<const Fill *>(main()) : nullptr;
  }
  const Flatten *main_as_Flatten() const {
    return main_type() == OpParameter_Flatten ? static_cast<const Flatten *>(main()) : nullptr;
  }
  const Gather *main_as_Gather() const {
    return main_type() == OpParameter_Gather ? static_cast<const Gather *>(main()) : nullptr;
  }
  const GatherV2 *main_as_GatherV2() const {
    return main_type() == OpParameter_GatherV2 ? static_cast<const GatherV2 *>(main()) : nullptr;
  }
  const InnerProduct *main_as_InnerProduct() const {
    return main_type() == OpParameter_InnerProduct ? static_cast<const InnerProduct *>(main()) : nullptr;
  }
  const Input *main_as_Input() const {
    return main_type() == OpParameter_Input ? static_cast<const Input *>(main()) : nullptr;
  }
  const Interp *main_as_Interp() const {
    return main_type() == OpParameter_Interp ? static_cast<const Interp *>(main()) : nullptr;
  }
  const LRN *main_as_LRN() const {
    return main_type() == OpParameter_LRN ? static_cast<const LRN *>(main()) : nullptr;
  }
  const LSTM *main_as_LSTM() const {
    return main_type() == OpParameter_LSTM ? static_cast<const LSTM *>(main()) : nullptr;
  }
  const MatMul *main_as_MatMul() const {
    return main_type() == OpParameter_MatMul ? static_cast<const MatMul *>(main()) : nullptr;
  }
  const NonMaxSuppressionV2 *main_as_NonMaxSuppressionV2() const {
    return main_type() == OpParameter_NonMaxSuppressionV2 ? static_cast<const NonMaxSuppressionV2 *>(main()) : nullptr;
  }
  const Normalize *main_as_Normalize() const {
    return main_type() == OpParameter_Normalize ? static_cast<const Normalize *>(main()) : nullptr;
  }
  const PackParam *main_as_PackParam() const {
    return main_type() == OpParameter_PackParam ? static_cast<const PackParam *>(main()) : nullptr;
  }
  const Permute *main_as_Permute() const {
    return main_type() == OpParameter_Permute ? static_cast<const Permute *>(main()) : nullptr;
  }
  const Plugin *main_as_Plugin() const {
    return main_type() == OpParameter_Plugin ? static_cast<const Plugin *>(main()) : nullptr;
  }
  const Pool *main_as_Pool() const {
    return main_type() == OpParameter_Pool ? static_cast<const Pool *>(main()) : nullptr;
  }
  const PRelu *main_as_PRelu() const {
    return main_type() == OpParameter_PRelu ? static_cast<const PRelu *>(main()) : nullptr;
  }
  const PriorBox *main_as_PriorBox() const {
    return main_type() == OpParameter_PriorBox ? static_cast<const PriorBox *>(main()) : nullptr;
  }
  const Proposal *main_as_Proposal() const {
    return main_type() == OpParameter_Proposal ? static_cast<const Proposal *>(main()) : nullptr;
  }
  const QuantizedAvgPool *main_as_QuantizedAvgPool() const {
    return main_type() == OpParameter_QuantizedAvgPool ? static_cast<const QuantizedAvgPool *>(main()) : nullptr;
  }
  const QuantizedBiasAdd *main_as_QuantizedBiasAdd() const {
    return main_type() == OpParameter_QuantizedBiasAdd ? static_cast<const QuantizedBiasAdd *>(main()) : nullptr;
  }
  const QuantizedConcat *main_as_QuantizedConcat() const {
    return main_type() == OpParameter_QuantizedConcat ? static_cast<const QuantizedConcat *>(main()) : nullptr;
  }
  const QuantizedLogistic *main_as_QuantizedLogistic() const {
    return main_type() == OpParameter_QuantizedLogistic ? static_cast<const QuantizedLogistic *>(main()) : nullptr;
  }
  const QuantizedMatMul *main_as_QuantizedMatMul() const {
    return main_type() == OpParameter_QuantizedMatMul ? static_cast<const QuantizedMatMul *>(main()) : nullptr;
  }
  const QuantizedMaxPool *main_as_QuantizedMaxPool() const {
    return main_type() == OpParameter_QuantizedMaxPool ? static_cast<const QuantizedMaxPool *>(main()) : nullptr;
  }
  const QuantizedRelu *main_as_QuantizedRelu() const {
    return main_type() == OpParameter_QuantizedRelu ? static_cast<const QuantizedRelu *>(main()) : nullptr;
  }
  const QuantizedRelu6 *main_as_QuantizedRelu6() const {
    return main_type() == OpParameter_QuantizedRelu6 ? static_cast<const QuantizedRelu6 *>(main()) : nullptr;
  }
  const QuantizedReshape *main_as_QuantizedReshape() const {
    return main_type() == OpParameter_QuantizedReshape ? static_cast<const QuantizedReshape *>(main()) : nullptr;
  }
  const QuantizedSoftmax *main_as_QuantizedSoftmax() const {
    return main_type() == OpParameter_QuantizedSoftmax ? static_cast<const QuantizedSoftmax *>(main()) : nullptr;
  }
  const QuantizeMaxMin *main_as_QuantizeMaxMin() const {
    return main_type() == OpParameter_QuantizeMaxMin ? static_cast<const QuantizeMaxMin *>(main()) : nullptr;
  }
  const QuantizeV2 *main_as_QuantizeV2() const {
    return main_type() == OpParameter_QuantizeV2 ? static_cast<const QuantizeV2 *>(main()) : nullptr;
  }
  const Range *main_as_Range() const {
    return main_type() == OpParameter_Range ? static_cast<const Range *>(main()) : nullptr;
  }
  const Rank *main_as_Rank() const {
    return main_type() == OpParameter_Rank ? static_cast<const Rank *>(main()) : nullptr;
  }
  const ReduceJoin *main_as_ReduceJoin() const {
    return main_type() == OpParameter_ReduceJoin ? static_cast<const ReduceJoin *>(main()) : nullptr;
  }
  const ReductionParam *main_as_ReductionParam() const {
    return main_type() == OpParameter_ReductionParam ? static_cast<const ReductionParam *>(main()) : nullptr;
  }
  const Relu *main_as_Relu() const {
    return main_type() == OpParameter_Relu ? static_cast<const Relu *>(main()) : nullptr;
  }
  const Relu6 *main_as_Relu6() const {
    return main_type() == OpParameter_Relu6 ? static_cast<const Relu6 *>(main()) : nullptr;
  }
  const RequantizationRange *main_as_RequantizationRange() const {
    return main_type() == OpParameter_RequantizationRange ? static_cast<const RequantizationRange *>(main()) : nullptr;
  }
  const Requantize *main_as_Requantize() const {
    return main_type() == OpParameter_Requantize ? static_cast<const Requantize *>(main()) : nullptr;
  }
  const Reshape *main_as_Reshape() const {
    return main_type() == OpParameter_Reshape ? static_cast<const Reshape *>(main()) : nullptr;
  }
  const Resize *main_as_Resize() const {
    return main_type() == OpParameter_Resize ? static_cast<const Resize *>(main()) : nullptr;
  }
  const RoiParameters *main_as_RoiParameters() const {
    return main_type() == OpParameter_RoiParameters ? static_cast<const RoiParameters *>(main()) : nullptr;
  }
  const Scale *main_as_Scale() const {
    return main_type() == OpParameter_Scale ? static_cast<const Scale *>(main()) : nullptr;
  }
  const Selu *main_as_Selu() const {
    return main_type() == OpParameter_Selu ? static_cast<const Selu *>(main()) : nullptr;
  }
  const Size *main_as_Size() const {
    return main_type() == OpParameter_Size ? static_cast<const Size *>(main()) : nullptr;
  }
  const Slice *main_as_Slice() const {
    return main_type() == OpParameter_Slice ? static_cast<const Slice *>(main()) : nullptr;
  }
  const SliceTf *main_as_SliceTf() const {
    return main_type() == OpParameter_SliceTf ? static_cast<const SliceTf *>(main()) : nullptr;
  }
  const SpaceBatch *main_as_SpaceBatch() const {
    return main_type() == OpParameter_SpaceBatch ? static_cast<const SpaceBatch *>(main()) : nullptr;
  }
  const SqueezeParam *main_as_SqueezeParam() const {
    return main_type() == OpParameter_SqueezeParam ? static_cast<const SqueezeParam *>(main()) : nullptr;
  }
  const StridedSliceParam *main_as_StridedSliceParam() const {
    return main_type() == OpParameter_StridedSliceParam ? static_cast<const StridedSliceParam *>(main()) : nullptr;
  }
  const TensorConvertInfo *main_as_TensorConvertInfo() const {
    return main_type() == OpParameter_TensorConvertInfo ? static_cast<const TensorConvertInfo *>(main()) : nullptr;
  }
  const TfQuantizedConv2D *main_as_TfQuantizedConv2D() const {
    return main_type() == OpParameter_TfQuantizedConv2D ? static_cast<const TfQuantizedConv2D *>(main()) : nullptr;
  }
  const TopKV2 *main_as_TopKV2() const {
    return main_type() == OpParameter_TopKV2 ? static_cast<const TopKV2 *>(main()) : nullptr;
  }
  const Transpose *main_as_Transpose() const {
    return main_type() == OpParameter_Transpose ? static_cast<const Transpose *>(main()) : nullptr;
  }
  const UnaryOp *main_as_UnaryOp() const {
    return main_type() == OpParameter_UnaryOp ? static_cast<const UnaryOp *>(main()) : nullptr;
  }
  const MomentsParam *main_as_MomentsParam() const {
    return main_type() == OpParameter_MomentsParam ? static_cast<const MomentsParam *>(main()) : nullptr;
  }
  const RNNParam *main_as_RNNParam() const {
    return main_type() == OpParameter_RNNParam ? static_cast<const RNNParam *>(main()) : nullptr;
  }
  const BatchMatMulParam *main_as_BatchMatMulParam() const {
    return main_type() == OpParameter_BatchMatMulParam ? static_cast<const BatchMatMulParam *>(main()) : nullptr;
  }
  const QuantizedFloatParam *main_as_QuantizedFloatParam() const {
    return main_type() == OpParameter_QuantizedFloatParam ? static_cast<const QuantizedFloatParam *>(main()) : nullptr;
  }
  const DepthSpaceParam *main_as_DepthSpaceParam() const {
    return main_type() == OpParameter_DepthSpaceParam ? static_cast<const DepthSpaceParam *>(main()) : nullptr;
  }
  const EltwiseInt8 *main_as_EltwiseInt8() const {
    return main_type() == OpParameter_EltwiseInt8 ? static_cast<const EltwiseInt8 *>(main()) : nullptr;
  }
  const ReverseSequenceParam *main_as_ReverseSequenceParam() const {
    return main_type() == OpParameter_ReverseSequenceParam ? static_cast<const ReverseSequenceParam *>(main()) : nullptr;
  }
  const Extra *main_as_Extra() const {
    return main_type() == OpParameter_Extra ? static_cast<const Extra *>(main()) : nullptr;
  }
  const Pool3D *main_as_Pool3D() const {
    return main_type() == OpParameter_Pool3D ? static_cast<const Pool3D *>(main()) : nullptr;
  }
  const Convolution3D *main_as_Convolution3D() const {
    return main_type() == OpParameter_Convolution3D ? static_cast<const Convolution3D *>(main()) : nullptr;
  }
  const ELU *main_as_ELU() const {
    return main_type() == OpParameter_ELU ? static_cast<const ELU *>(main()) : nullptr;
  }
  const DetectionPostProcessParam *main_as_DetectionPostProcessParam() const {
    return main_type() == OpParameter_DetectionPostProcessParam ? static_cast<const DetectionPostProcessParam *>(main()) : nullptr;
  }
  const OneHotParam *main_as_OneHotParam() const {
    return main_type() == OpParameter_OneHotParam ? static_cast<const OneHotParam *>(main()) : nullptr;
  }
  const PadParam *main_as_PadParam() const {
    return main_type() == OpParameter_PadParam ? static_cast<const PadParam *>(main()) : nullptr;
  }
  const WhileParam *main_as_WhileParam() const {
    return main_type() == OpParameter_WhileParam ? static_cast<const WhileParam *>(main()) : nullptr;
  }
  const IfParam *main_as_IfParam() const {
    return main_type() == OpParameter_IfParam ? static_cast<const IfParam *>(main()) : nullptr;
  }
  const RandomUniform *main_as_RandomUniform() const {
    return main_type() == OpParameter_RandomUniform ? static_cast<const RandomUniform *>(main()) : nullptr;
  }
  const LayerNorm *main_as_LayerNorm() const {
    return main_type() == OpParameter_LayerNorm ? static_cast<const LayerNorm *>(main()) : nullptr;
  }
  const TensorArray *main_as_TensorArray() const {
    return main_type() == OpParameter_TensorArray ? static_cast<const TensorArray *>(main()) : nullptr;
  }
  const LSTMBlockCell *main_as_LSTMBlockCell() const {
    return main_type() == OpParameter_LSTMBlockCell ? static_cast<const LSTMBlockCell *>(main()) : nullptr;
  }
  const GridSample *main_as_GridSample() const {
    return main_type() == OpParameter_GridSample ? static_cast<const GridSample *>(main()) : nullptr;
  }
  const LoopParam *main_as_LoopParam() const {
    return main_type() == OpParameter_LoopParam ? static_cast<const LoopParam *>(main()) : nullptr;
  }
  const ImageProcessParam *main_as_ImageProcessParam() const {
    return main_type() == OpParameter_ImageProcessParam ? static_cast<const ImageProcessParam *>(main()) : nullptr;
  }
  const CumSum *main_as_CumSum() const {
    return main_type() == OpParameter_CumSum ? static_cast<const CumSum *>(main()) : nullptr;
  }
  const GroupNorm *main_as_GroupNorm() const {
    return main_type() == OpParameter_GroupNorm ? static_cast<const GroupNorm *>(main()) : nullptr;
  }
  const FmhaV2Param *main_as_FmhaV2Param() const {
    return main_type() == OpParameter_FmhaV2Param ? static_cast<const FmhaV2Param *>(main()) : nullptr;
  }
  const FmhcaParam *main_as_FmhcaParam() const {
    return main_type() == OpParameter_FmhcaParam ? static_cast<const FmhcaParam *>(main()) : nullptr;
  }
  const AttentionParam *main_as_AttentionParam() const {
    return main_type() == OpParameter_AttentionParam ? static_cast<const AttentionParam *>(main()) : nullptr;
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(10);
  }
  const flatbuffers::Vector<int32_t> *outputIndexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(12);
  }
  OpType type() const {
    return static_cast<OpType>(GetField<int32_t>(14, 0));
  }
  MNN_DATA_FORMAT defaultDimentionFormat() const {
    return static_cast<MNN_DATA_FORMAT>(GetField<int8_t>(16, 1));
  }
  const flatbuffers::String *externalPath() const {
    return GetPointer<const flatbuffers::String *>(18);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(inputIndexes()) &&
           VerifyField<uint8_t>(verifier, 6) &&
           VerifyOffset(verifier, 8) &&
           VerifyOpParameter(verifier, main(), main_type()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(outputIndexes()) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int8_t>(verifier, 16) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyString(externalPath()) &&
           verifier.EndTable();
  }
  OpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Op> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const QuantizedAdd *Op::main_as<QuantizedAdd>() const {
  return main_as_QuantizedAdd();
}

template<> inline const ArgMax *Op::main_as<ArgMax>() const {
  return main_as_ArgMax();
}

template<> inline const AsString *Op::main_as<AsString>() const {
  return main_as_AsString();
}

template<> inline const Axis *Op::main_as<Axis>() const {
  return main_as_Axis();
}

template<> inline const BatchNorm *Op::main_as<BatchNorm>() const {
  return main_as_BatchNorm();
}

template<> inline const BinaryOp *Op::main_as<BinaryOp>() const {
  return main_as_BinaryOp();
}

template<> inline const Blob *Op::main_as<Blob>() const {
  return main_as_Blob();
}

template<> inline const CastParam *Op::main_as<CastParam>() const {
  return main_as_CastParam();
}

template<> inline const Convolution2D *Op::main_as<Convolution2D>() const {
  return main_as_Convolution2D();
}

template<> inline const Crop *Op::main_as<Crop>() const {
  return main_as_Crop();
}

template<> inline const CropAndResize *Op::main_as<CropAndResize>() const {
  return main_as_CropAndResize();
}

template<> inline const Dequantize *Op::main_as<Dequantize>() const {
  return main_as_Dequantize();
}

template<> inline const DetectionOutput *Op::main_as<DetectionOutput>() const {
  return main_as_DetectionOutput();
}

template<> inline const Eltwise *Op::main_as<Eltwise>() const {
  return main_as_Eltwise();
}

template<> inline const ExpandDims *Op::main_as<ExpandDims>() const {
  return main_as_ExpandDims();
}

template<> inline const Fill *Op::main_as<Fill>() const {
  return main_as_Fill();
}

template<> inline const Flatten *Op::main_as<Flatten>() const {
  return main_as_Flatten();
}

template<> inline const Gather *Op::main_as<Gather>() const {
  return main_as_Gather();
}

template<> inline const GatherV2 *Op::main_as<GatherV2>() const {
  return main_as_GatherV2();
}

template<> inline const InnerProduct *Op::main_as<InnerProduct>() const {
  return main_as_InnerProduct();
}

template<> inline const Input *Op::main_as<Input>() const {
  return main_as_Input();
}

template<> inline const Interp *Op::main_as<Interp>() const {
  return main_as_Interp();
}

template<> inline const LRN *Op::main_as<LRN>() const {
  return main_as_LRN();
}

template<> inline const LSTM *Op::main_as<LSTM>() const {
  return main_as_LSTM();
}

template<> inline const MatMul *Op::main_as<MatMul>() const {
  return main_as_MatMul();
}

template<> inline const NonMaxSuppressionV2 *Op::main_as<NonMaxSuppressionV2>() const {
  return main_as_NonMaxSuppressionV2();
}

template<> inline const Normalize *Op::main_as<Normalize>() const {
  return main_as_Normalize();
}

template<> inline const PackParam *Op::main_as<PackParam>() const {
  return main_as_PackParam();
}

template<> inline const Permute *Op::main_as<Permute>() const {
  return main_as_Permute();
}

template<> inline const Plugin *Op::main_as<Plugin>() const {
  return main_as_Plugin();
}

template<> inline const Pool *Op::main_as<Pool>() const {
  return main_as_Pool();
}

template<> inline const PRelu *Op::main_as<PRelu>() const {
  return main_as_PRelu();
}

template<> inline const PriorBox *Op::main_as<PriorBox>() const {
  return main_as_PriorBox();
}

template<> inline const Proposal *Op::main_as<Proposal>() const {
  return main_as_Proposal();
}

template<> inline const QuantizedAvgPool *Op::main_as<QuantizedAvgPool>() const {
  return main_as_QuantizedAvgPool();
}

template<> inline const QuantizedBiasAdd *Op::main_as<QuantizedBiasAdd>() const {
  return main_as_QuantizedBiasAdd();
}

template<> inline const QuantizedConcat *Op::main_as<QuantizedConcat>() const {
  return main_as_QuantizedConcat();
}

template<> inline const QuantizedLogistic *Op::main_as<QuantizedLogistic>() const {
  return main_as_QuantizedLogistic();
}

template<> inline const QuantizedMatMul *Op::main_as<QuantizedMatMul>() const {
  return main_as_QuantizedMatMul();
}

template<> inline const QuantizedMaxPool *Op::main_as<QuantizedMaxPool>() const {
  return main_as_QuantizedMaxPool();
}

template<> inline const QuantizedRelu *Op::main_as<QuantizedRelu>() const {
  return main_as_QuantizedRelu();
}

template<> inline const QuantizedRelu6 *Op::main_as<QuantizedRelu6>() const {
  return main_as_QuantizedRelu6();
}

template<> inline const QuantizedReshape *Op::main_as<QuantizedReshape>() const {
  return main_as_QuantizedReshape();
}

template<> inline const QuantizedSoftmax *Op::main_as<QuantizedSoftmax>() const {
  return main_as_QuantizedSoftmax();
}

template<> inline const QuantizeMaxMin *Op::main_as<QuantizeMaxMin>() const {
  return main_as_QuantizeMaxMin();
}

template<> inline const QuantizeV2 *Op::main_as<QuantizeV2>() const {
  return main_as_QuantizeV2();
}

template<> inline const Range *Op::main_as<Range>() const {
  return main_as_Range();
}

template<> inline const Rank *Op::main_as<Rank>() const {
  return main_as_Rank();
}

template<> inline const ReduceJoin *Op::main_as<ReduceJoin>() const {
  return main_as_ReduceJoin();
}

template<> inline const ReductionParam *Op::main_as<ReductionParam>() const {
  return main_as_ReductionParam();
}

template<> inline const Relu *Op::main_as<Relu>() const {
  return main_as_Relu();
}

template<> inline const Relu6 *Op::main_as<Relu6>() const {
  return main_as_Relu6();
}

template<> inline const RequantizationRange *Op::main_as<RequantizationRange>() const {
  return main_as_RequantizationRange();
}

template<> inline const Requantize *Op::main_as<Requantize>() const {
  return main_as_Requantize();
}

template<> inline const Reshape *Op::main_as<Reshape>() const {
  return main_as_Reshape();
}

template<> inline const Resize *Op::main_as<Resize>() const {
  return main_as_Resize();
}

template<> inline const RoiParameters *Op::main_as<RoiParameters>() const {
  return main_as_RoiParameters();
}

template<> inline const Scale *Op::main_as<Scale>() const {
  return main_as_Scale();
}

template<> inline const Selu *Op::main_as<Selu>() const {
  return main_as_Selu();
}

template<> inline const Size *Op::main_as<Size>() const {
  return main_as_Size();
}

template<> inline const Slice *Op::main_as<Slice>() const {
  return main_as_Slice();
}

template<> inline const SliceTf *Op::main_as<SliceTf>() const {
  return main_as_SliceTf();
}

template<> inline const SpaceBatch *Op::main_as<SpaceBatch>() const {
  return main_as_SpaceBatch();
}

template<> inline const SqueezeParam *Op::main_as<SqueezeParam>() const {
  return main_as_SqueezeParam();
}

template<> inline const StridedSliceParam *Op::main_as<StridedSliceParam>() const {
  return main_as_StridedSliceParam();
}

template<> inline const TensorConvertInfo *Op::main_as<TensorConvertInfo>() const {
  return main_as_TensorConvertInfo();
}

template<> inline const TfQuantizedConv2D *Op::main_as<TfQuantizedConv2D>() const {
  return main_as_TfQuantizedConv2D();
}

template<> inline const TopKV2 *Op::main_as<TopKV2>() const {
  return main_as_TopKV2();
}

template<> inline const Transpose *Op::main_as<Transpose>() const {
  return main_as_Transpose();
}

template<> inline const UnaryOp *Op::main_as<UnaryOp>() const {
  return main_as_UnaryOp();
}

template<> inline const MomentsParam *Op::main_as<MomentsParam>() const {
  return main_as_MomentsParam();
}

template<> inline const RNNParam *Op::main_as<RNNParam>() const {
  return main_as_RNNParam();
}

template<> inline const BatchMatMulParam *Op::main_as<BatchMatMulParam>() const {
  return main_as_BatchMatMulParam();
}

template<> inline const QuantizedFloatParam *Op::main_as<QuantizedFloatParam>() const {
  return main_as_QuantizedFloatParam();
}

template<> inline const DepthSpaceParam *Op::main_as<DepthSpaceParam>() const {
  return main_as_DepthSpaceParam();
}

template<> inline const EltwiseInt8 *Op::main_as<EltwiseInt8>() const {
  return main_as_EltwiseInt8();
}

template<> inline const ReverseSequenceParam *Op::main_as<ReverseSequenceParam>() const {
  return main_as_ReverseSequenceParam();
}

template<> inline const Extra *Op::main_as<Extra>() const {
  return main_as_Extra();
}

template<> inline const Pool3D *Op::main_as<Pool3D>() const {
  return main_as_Pool3D();
}

template<> inline const Convolution3D *Op::main_as<Convolution3D>() const {
  return main_as_Convolution3D();
}

template<> inline const ELU *Op::main_as<ELU>() const {
  return main_as_ELU();
}

template<> inline const DetectionPostProcessParam *Op::main_as<DetectionPostProcessParam>() const {
  return main_as_DetectionPostProcessParam();
}

template<> inline const OneHotParam *Op::main_as<OneHotParam>() const {
  return main_as_OneHotParam();
}

template<> inline const PadParam *Op::main_as<PadParam>() const {
  return main_as_PadParam();
}

template<> inline const WhileParam *Op::main_as<WhileParam>() const {
  return main_as_WhileParam();
}

template<> inline const IfParam *Op::main_as<IfParam>() const {
  return main_as_IfParam();
}

template<> inline const RandomUniform *Op::main_as<RandomUniform>() const {
  return main_as_RandomUniform();
}

template<> inline const LayerNorm *Op::main_as<LayerNorm>() const {
  return main_as_LayerNorm();
}

template<> inline const TensorArray *Op::main_as<TensorArray>() const {
  return main_as_TensorArray();
}

template<> inline const LSTMBlockCell *Op::main_as<LSTMBlockCell>() const {
  return main_as_LSTMBlockCell();
}

template<> inline const GridSample *Op::main_as<GridSample>() const {
  return main_as_GridSample();
}

template<> inline const LoopParam *Op::main_as<LoopParam>() const {
  return main_as_LoopParam();
}

template<> inline const ImageProcessParam *Op::main_as<ImageProcessParam>() const {
  return main_as_ImageProcessParam();
}

template<> inline const CumSum *Op::main_as<CumSum>() const {
  return main_as_CumSum();
}

template<> inline const GroupNorm *Op::main_as<GroupNorm>() const {
  return main_as_GroupNorm();
}

template<> inline const FmhaV2Param *Op::main_as<FmhaV2Param>() const {
  return main_as_FmhaV2Param();
}

template<> inline const FmhcaParam *Op::main_as<FmhcaParam>() const {
  return main_as_FmhcaParam();
}

template<> inline const AttentionParam *Op::main_as<AttentionParam>() const {
  return main_as_AttentionParam();
}

struct OpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputIndexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputIndexes) {
    fbb_.AddOffset(4, inputIndexes);
  }
  void add_main_type(OpParameter main_type) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(main_type), 0);
  }
  void add_main(flatbuffers::Offset<void> main) {
    fbb_.AddOffset(8, main);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(10, name);
  }
  void add_outputIndexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputIndexes) {
    fbb_.AddOffset(12, outputIndexes);
  }
  void add_type(OpType type) {
    fbb_.AddElement<int32_t>(14, static_cast<int32_t>(type), 0);
  }
  void add_defaultDimentionFormat(MNN_DATA_FORMAT defaultDimentionFormat) {
    fbb_.AddElement<int8_t>(16, static_cast<int8_t>(defaultDimentionFormat), 1);
  }
  void add_externalPath(flatbuffers::Offset<flatbuffers::String> externalPath) {
    fbb_.AddOffset(18, externalPath);
  }
  explicit OpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpBuilder &operator=(const OpBuilder &);
  flatbuffers::Offset<Op> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Op>(end);
    return o;
  }
};

inline flatbuffers::Offset<Op> CreateOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputIndexes = 0,
    OpParameter main_type = OpParameter_NONE,
    flatbuffers::Offset<void> main = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputIndexes = 0,
    OpType type = OpType_AbsVal,
    MNN_DATA_FORMAT defaultDimentionFormat = MNN_DATA_FORMAT_NHWC,
    flatbuffers::Offset<flatbuffers::String> externalPath = 0) {
  OpBuilder builder_(_fbb);
  builder_.add_externalPath(externalPath);
  builder_.add_type(type);
  builder_.add_outputIndexes(outputIndexes);
  builder_.add_name(name);
  builder_.add_main(main);
  builder_.add_inputIndexes(inputIndexes);
  builder_.add_defaultDimentionFormat(defaultDimentionFormat);
  builder_.add_main_type(main_type);
  return builder_.Finish();
}

flatbuffers::Offset<Op> CreateOp(flatbuffers::FlatBufferBuilder &_fbb, const OpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ViewT : public flatbuffers::NativeTable {
  typedef View TableType;
  int32_t offset;
  std::vector<int32_t> stride;
  ViewT()
      : offset(0) {
  }
};

struct View FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ViewT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ViewTypeTable();
  }
  int32_t offset() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(stride()) &&
           verifier.EndTable();
  }
  ViewT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ViewT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<View> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ViewT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ViewBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(4, offset, 0);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(6, stride);
  }
  explicit ViewBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ViewBuilder &operator=(const ViewBuilder &);
  flatbuffers::Offset<View> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<View>(end);
    return o;
  }
};

inline flatbuffers::Offset<View> CreateView(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride = 0) {
  ViewBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_offset(offset);
  return builder_.Finish();
}

flatbuffers::Offset<View> CreateView(flatbuffers::FlatBufferBuilder &_fbb, const ViewT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegionT : public flatbuffers::NativeTable {
  typedef Region TableType;
  std::unique_ptr<ViewT> src;
  std::unique_ptr<ViewT> dst;
  std::vector<int32_t> size;
  int32_t origin;
  RegionT()
      : origin(0) {
  }
};

struct Region FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RegionTypeTable();
  }
  const View *src() const {
    return GetPointer<const View *>(4);
  }
  const View *dst() const {
    return GetPointer<const View *>(6);
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  int32_t origin() const {
    return GetField<int32_t>(10, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyTable(src()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyTable(dst()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(size()) &&
           VerifyField<int32_t>(verifier, 10) &&
           verifier.EndTable();
  }
  RegionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Region> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(flatbuffers::Offset<View> src) {
    fbb_.AddOffset(4, src);
  }
  void add_dst(flatbuffers::Offset<View> dst) {
    fbb_.AddOffset(6, dst);
  }
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(8, size);
  }
  void add_origin(int32_t origin) {
    fbb_.AddElement<int32_t>(10, origin, 0);
  }
  explicit RegionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegionBuilder &operator=(const RegionBuilder &);
  flatbuffers::Offset<Region> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Region>(end);
    return o;
  }
};

inline flatbuffers::Offset<Region> CreateRegion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<View> src = 0,
    flatbuffers::Offset<View> dst = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0,
    int32_t origin = 0) {
  RegionBuilder builder_(_fbb);
  builder_.add_origin(origin);
  builder_.add_size(size);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

flatbuffers::Offset<Region> CreateRegion(flatbuffers::FlatBufferBuilder &_fbb, const RegionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorDescribeT : public flatbuffers::NativeTable {
  typedef TensorDescribe TableType;
  std::unique_ptr<BlobT> blob;
  int32_t index;
  std::string name;
  std::vector<std::unique_ptr<RegionT>> regions;
  std::unique_ptr<TensorQuantInfoT> quantInfo;
  TensorDescribeT()
      : index(0) {
  }
};

struct TensorDescribe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorDescribeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorDescribeTypeTable();
  }
  const Blob *blob() const {
    return GetPointer<const Blob *>(4);
  }
  int32_t index() const {
    return GetField<int32_t>(6, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Region>> *regions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Region>> *>(10);
  }
  const TensorQuantInfo *quantInfo() const {
    return GetPointer<const TensorQuantInfo *>(12);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyTable(blob()) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(regions()) &&
           verifier.VerifyVectorOfTables(regions()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyTable(quantInfo()) &&
           verifier.EndTable();
  }
  TensorDescribeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorDescribeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorDescribe> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorDescribeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blob(flatbuffers::Offset<Blob> blob) {
    fbb_.AddOffset(4, blob);
  }
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(6, index, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(8, name);
  }
  void add_regions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Region>>> regions) {
    fbb_.AddOffset(10, regions);
  }
  void add_quantInfo(flatbuffers::Offset<TensorQuantInfo> quantInfo) {
    fbb_.AddOffset(12, quantInfo);
  }
  explicit TensorDescribeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorDescribeBuilder &operator=(const TensorDescribeBuilder &);
  flatbuffers::Offset<TensorDescribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorDescribe>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorDescribe> CreateTensorDescribe(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Blob> blob = 0,
    int32_t index = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Region>>> regions = 0,
    flatbuffers::Offset<TensorQuantInfo> quantInfo = 0) {
  TensorDescribeBuilder builder_(_fbb);
  builder_.add_quantInfo(quantInfo);
  builder_.add_regions(regions);
  builder_.add_name(name);
  builder_.add_index(index);
  builder_.add_blob(blob);
  return builder_.Finish();
}

flatbuffers::Offset<TensorDescribe> CreateTensorDescribe(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphProtoT : public flatbuffers::NativeTable {
  typedef SubGraphProto TableType;
  std::string name;
  std::vector<int32_t> inputs;
  std::vector<int32_t> outputs;
  std::vector<std::string> tensors;
  std::vector<std::unique_ptr<OpT>> nodes;
  std::vector<std::unique_ptr<TensorDescribeT>> extraTensorDescribe;
  SubGraphProtoT() {
  }
};

struct SubGraphProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGraphProtoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubGraphProtoTypeTable();
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(10);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Op>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Op>> *>(12);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>> *extraTensorDescribe() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>> *>(14);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfStrings(tensors()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyVector(extraTensorDescribe()) &&
           verifier.VerifyVectorOfTables(extraTensorDescribe()) &&
           verifier.EndTable();
  }
  SubGraphProtoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGraphProtoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGraphProto> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphProtoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(4, name);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(6, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(8, outputs);
  }
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensors) {
    fbb_.AddOffset(10, tensors);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Op>>> nodes) {
    fbb_.AddOffset(12, nodes);
  }
  void add_extraTensorDescribe(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>>> extraTensorDescribe) {
    fbb_.AddOffset(14, extraTensorDescribe);
  }
  explicit SubGraphProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGraphProtoBuilder &operator=(const SubGraphProtoBuilder &);
  flatbuffers::Offset<SubGraphProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraphProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraphProto> CreateSubGraphProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Op>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>>> extraTensorDescribe = 0) {
  SubGraphProtoBuilder builder_(_fbb);
  builder_.add_extraTensorDescribe(extraTensorDescribe);
  builder_.add_nodes(nodes);
  builder_.add_tensors(tensors);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_name(name);
  return builder_.Finish();
}

flatbuffers::Offset<SubGraphProto> CreateSubGraphProto(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorQuantInfoT : public flatbuffers::NativeTable {
  typedef TensorQuantInfo TableType;
  float scale;
  float zero;
  float min;
  float max;
  DataType type;
  TensorQuantInfoT()
      : scale(0.0f),
        zero(0.0f),
        min(-128.0f),
        max(127.0f),
        type(DataType_DT_INVALID) {
  }
};

struct TensorQuantInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorQuantInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorQuantInfoTypeTable();
  }
  float scale() const {
    return GetField<float>(4, 0.0f);
  }
  float zero() const {
    return GetField<float>(6, 0.0f);
  }
  float min() const {
    return GetField<float>(8, -128.0f);
  }
  float max() const {
    return GetField<float>(10, 127.0f);
  }
  DataType type() const {
    return static_cast<DataType>(GetField<int32_t>(12, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyField<float>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           verifier.EndTable();
  }
  TensorQuantInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorQuantInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorQuantInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorQuantInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(4, scale, 0.0f);
  }
  void add_zero(float zero) {
    fbb_.AddElement<float>(6, zero, 0.0f);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(8, min, -128.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(10, max, 127.0f);
  }
  void add_type(DataType type) {
    fbb_.AddElement<int32_t>(12, static_cast<int32_t>(type), 0);
  }
  explicit TensorQuantInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorQuantInfoBuilder &operator=(const TensorQuantInfoBuilder &);
  flatbuffers::Offset<TensorQuantInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorQuantInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorQuantInfo> CreateTensorQuantInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 0.0f,
    float zero = 0.0f,
    float min = -128.0f,
    float max = 127.0f,
    DataType type = DataType_DT_INVALID) {
  TensorQuantInfoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_zero(zero);
  builder_.add_scale(scale);
  return builder_.Finish();
}

flatbuffers::Offset<TensorQuantInfo> CreateTensorQuantInfo(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NetT : public flatbuffers::NativeTable {
  typedef Net TableType;
  std::string bizCode;
  std::vector<std::unique_ptr<TensorDescribeT>> extraTensorDescribe;
  std::unique_ptr<ExtraInfoT> extraInfo;
  std::vector<std::unique_ptr<OpT>> oplists;
  std::vector<std::string> outputName;
  ForwardType preferForwardType;
  NetSource sourceType;
  std::vector<std::string> tensorName;
  int32_t tensorNumber;
  Usage usage;
  std::vector<std::unique_ptr<SubGraphProtoT>> subgraphs;
  std::string mnn_uuid;
  NetT()
      : preferForwardType(ForwardType_CPU),
        sourceType(NetSource_CAFFE),
        tensorNumber(0),
        usage(Usage_INFERENCE) {
  }
};

struct Net FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NetT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NetTypeTable();
  }
  const flatbuffers::String *bizCode() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>> *extraTensorDescribe() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>> *>(6);
  }
  const ExtraInfo *extraInfo() const {
    return GetPointer<const ExtraInfo *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Op>> *oplists() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Op>> *>(10);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputName() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(12);
  }
  ForwardType preferForwardType() const {
    return static_cast<ForwardType>(GetField<int8_t>(14, 0));
  }
  NetSource sourceType() const {
    return static_cast<NetSource>(GetField<int8_t>(16, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tensorName() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(18);
  }
  int32_t tensorNumber() const {
    return GetField<int32_t>(20, 0);
  }
  Usage usage() const {
    return static_cast<Usage>(GetField<int8_t>(22, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<SubGraphProto>> *subgraphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SubGraphProto>> *>(24);
  }
  const flatbuffers::String *mnn_uuid() const {
    return GetPointer<const flatbuffers::String *>(26);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(bizCode()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(extraTensorDescribe()) &&
           verifier.VerifyVectorOfTables(extraTensorDescribe()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyTable(extraInfo()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(oplists()) &&
           verifier.VerifyVectorOfTables(oplists()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(outputName()) &&
           verifier.VerifyVectorOfStrings(outputName()) &&
           VerifyField<int8_t>(verifier, 14) &&
           VerifyField<int8_t>(verifier, 16) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyVector(tensorName()) &&
           verifier.VerifyVectorOfStrings(tensorName()) &&
           VerifyField<int32_t>(verifier, 20) &&
           VerifyField<int8_t>(verifier, 22) &&
           VerifyOffset(verifier, 24) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, 26) &&
           verifier.VerifyString(mnn_uuid()) &&
           verifier.EndTable();
  }
  NetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Net> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bizCode(flatbuffers::Offset<flatbuffers::String> bizCode) {
    fbb_.AddOffset(4, bizCode);
  }
  void add_extraTensorDescribe(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>>> extraTensorDescribe) {
    fbb_.AddOffset(6, extraTensorDescribe);
  }
  void add_extraInfo(flatbuffers::Offset<ExtraInfo> extraInfo) {
    fbb_.AddOffset(8, extraInfo);
  }
  void add_oplists(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Op>>> oplists) {
    fbb_.AddOffset(10, oplists);
  }
  void add_outputName(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputName) {
    fbb_.AddOffset(12, outputName);
  }
  void add_preferForwardType(ForwardType preferForwardType) {
    fbb_.AddElement<int8_t>(14, static_cast<int8_t>(preferForwardType), 0);
  }
  void add_sourceType(NetSource sourceType) {
    fbb_.AddElement<int8_t>(16, static_cast<int8_t>(sourceType), 0);
  }
  void add_tensorName(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensorName) {
    fbb_.AddOffset(18, tensorName);
  }
  void add_tensorNumber(int32_t tensorNumber) {
    fbb_.AddElement<int32_t>(20, tensorNumber, 0);
  }
  void add_usage(Usage usage) {
    fbb_.AddElement<int8_t>(22, static_cast<int8_t>(usage), 0);
  }
  void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraphProto>>> subgraphs) {
    fbb_.AddOffset(24, subgraphs);
  }
  void add_mnn_uuid(flatbuffers::Offset<flatbuffers::String> mnn_uuid) {
    fbb_.AddOffset(26, mnn_uuid);
  }
  explicit NetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NetBuilder &operator=(const NetBuilder &);
  flatbuffers::Offset<Net> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Net>(end);
    return o;
  }
};

inline flatbuffers::Offset<Net> CreateNet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> bizCode = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDescribe>>> extraTensorDescribe = 0,
    flatbuffers::Offset<ExtraInfo> extraInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Op>>> oplists = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputName = 0,
    ForwardType preferForwardType = ForwardType_CPU,
    NetSource sourceType = NetSource_CAFFE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensorName = 0,
    int32_t tensorNumber = 0,
    Usage usage = Usage_INFERENCE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraphProto>>> subgraphs = 0,
    flatbuffers::Offset<flatbuffers::String> mnn_uuid = 0) {
  NetBuilder builder_(_fbb);
  builder_.add_mnn_uuid(mnn_uuid);
  builder_.add_subgraphs(subgraphs);
  builder_.add_tensorNumber(tensorNumber);
  builder_.add_tensorName(tensorName);
  builder_.add_outputName(outputName);
  builder_.add_oplists(oplists);
  builder_.add_extraInfo(extraInfo);
  builder_.add_extraTensorDescribe(extraTensorDescribe);
  builder_.add_bizCode(bizCode);
  builder_.add_usage(usage);
  builder_.add_sourceType(sourceType);
  builder_.add_preferForwardType(preferForwardType);
  return builder_.Finish();
}

flatbuffers::Offset<Net> CreateNet(flatbuffers::FlatBufferBuilder &_fbb, const NetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PluginT *Plugin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PluginT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Plugin::UnPackTo(PluginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); };
  { auto _e = attr(); if (_e) { _o->attr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attr[_i] = std::unique_ptr<AttributeT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Plugin> Plugin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PluginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlugin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Plugin> CreatePlugin(flatbuffers::FlatBufferBuilder &_fbb, const PluginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PluginT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _attr = _o->attr.size() ? _fbb.CreateVector<flatbuffers::Offset<Attribute>> (_o->attr.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->attr[i].get(), __va->__rehasher); }, &_va ) : 0;
  return MNN::CreatePlugin(
      _fbb,
      _type,
      _attr);
}

inline ExtraT *Extra::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ExtraT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Extra::UnPackTo(ExtraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); };
  { auto _e = engine(); if (_e) _o->engine = _e->str(); };
  { auto _e = info(); if (_e) { _o->info.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->info[_i] = _e->Get(_i); } } };
  { auto _e = attr(); if (_e) { _o->attr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attr[_i] = std::unique_ptr<AttributeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = vector(); _o->vector = _e; };
}

inline flatbuffers::Offset<Extra> Extra::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExtra(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Extra> CreateExtra(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExtraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _engine = _o->engine.empty() ? 0 : _fbb.CreateString(_o->engine);
  auto _info = _o->info.size() ? _fbb.CreateVector(_o->info) : 0;
  auto _attr = _o->attr.size() ? _fbb.CreateVector<flatbuffers::Offset<Attribute>> (_o->attr.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->attr[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _vector = _o->vector;
  return MNN::CreateExtra(
      _fbb,
      _type,
      _engine,
      _info,
      _attr,
      _vector);
}

inline StringVecT *StringVec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StringVecT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StringVec::UnPackTo(StringVecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<StringVec> StringVec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringVecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStringVec(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StringVec> CreateStringVec(flatbuffers::FlatBufferBuilder &_fbb, const StringVecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StringVecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVectorOfStrings(_o->data) : 0;
  return MNN::CreateStringVec(
      _fbb,
      _data);
}

inline AttentionParamT *AttentionParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttentionParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttentionParam::UnPackTo(AttentionParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kv_cache(); _o->kv_cache = _e; };
}

inline flatbuffers::Offset<AttentionParam> AttentionParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttentionParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttentionParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttentionParam> CreateAttentionParam(flatbuffers::FlatBufferBuilder &_fbb, const AttentionParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttentionParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kv_cache = _o->kv_cache;
  return MNN::CreateAttentionParam(
      _fbb,
      _kv_cache);
}

inline FmhaV2ParamT *FmhaV2Param::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FmhaV2ParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FmhaV2Param::UnPackTo(FmhaV2ParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heads(); _o->heads = _e; };
}

inline flatbuffers::Offset<FmhaV2Param> FmhaV2Param::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FmhaV2ParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFmhaV2Param(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FmhaV2Param> CreateFmhaV2Param(flatbuffers::FlatBufferBuilder &_fbb, const FmhaV2ParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FmhaV2ParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heads = _o->heads;
  return MNN::CreateFmhaV2Param(
      _fbb,
      _heads);
}

inline FmhcaParamT *FmhcaParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FmhcaParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FmhcaParam::UnPackTo(FmhcaParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heads(); _o->heads = _e; };
}

inline flatbuffers::Offset<FmhcaParam> FmhcaParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FmhcaParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFmhcaParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FmhcaParam> CreateFmhcaParam(flatbuffers::FlatBufferBuilder &_fbb, const FmhcaParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FmhcaParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heads = _o->heads;
  return MNN::CreateFmhcaParam(
      _fbb,
      _heads);
}

inline WhileParamT *WhileParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WhileParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WhileParam::UnPackTo(WhileParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cond_graph(); if (_e) _o->cond_graph = _e->str(); };
  { auto _e = body_graph(); if (_e) _o->body_graph = _e->str(); };
  { auto _e = aliases_inputs(); if (_e) { _o->aliases_inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aliases_inputs[_i] = std::unique_ptr<StringVecT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = aliases_outputs(); if (_e) { _o->aliases_outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aliases_outputs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = aliases_updates(); if (_e) { _o->aliases_updates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aliases_updates[_i] = std::unique_ptr<StringVecT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<WhileParam> WhileParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhileParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WhileParam> CreateWhileParam(flatbuffers::FlatBufferBuilder &_fbb, const WhileParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhileParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cond_graph = _o->cond_graph.empty() ? 0 : _fbb.CreateString(_o->cond_graph);
  auto _body_graph = _o->body_graph.empty() ? 0 : _fbb.CreateString(_o->body_graph);
  auto _aliases_inputs = _o->aliases_inputs.size() ? _fbb.CreateVector<flatbuffers::Offset<StringVec>> (_o->aliases_inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateStringVec(*__va->__fbb, __va->__o->aliases_inputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _aliases_outputs = _o->aliases_outputs.size() ? _fbb.CreateVectorOfStrings(_o->aliases_outputs) : 0;
  auto _aliases_updates = _o->aliases_updates.size() ? _fbb.CreateVector<flatbuffers::Offset<StringVec>> (_o->aliases_updates.size(), [](size_t i, _VectorArgs *__va) { return CreateStringVec(*__va->__fbb, __va->__o->aliases_updates[i].get(), __va->__rehasher); }, &_va ) : 0;
  return MNN::CreateWhileParam(
      _fbb,
      _cond_graph,
      _body_graph,
      _aliases_inputs,
      _aliases_outputs,
      _aliases_updates);
}

inline IfParamT *IfParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IfParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IfParam::UnPackTo(IfParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = then_graph(); if (_e) _o->then_graph = _e->str(); };
  { auto _e = else_graph(); if (_e) _o->else_graph = _e->str(); };
  { auto _e = aliases_inputs(); if (_e) { _o->aliases_inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aliases_inputs[_i] = std::unique_ptr<StringVecT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = aliases_outputs(); if (_e) { _o->aliases_outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aliases_outputs[_i] = std::unique_ptr<StringVecT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<IfParam> IfParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIfParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IfParam> CreateIfParam(flatbuffers::FlatBufferBuilder &_fbb, const IfParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IfParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _then_graph = _o->then_graph.empty() ? 0 : _fbb.CreateString(_o->then_graph);
  auto _else_graph = _o->else_graph.empty() ? 0 : _fbb.CreateString(_o->else_graph);
  auto _aliases_inputs = _o->aliases_inputs.size() ? _fbb.CreateVector<flatbuffers::Offset<StringVec>> (_o->aliases_inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateStringVec(*__va->__fbb, __va->__o->aliases_inputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _aliases_outputs = _o->aliases_outputs.size() ? _fbb.CreateVector<flatbuffers::Offset<StringVec>> (_o->aliases_outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateStringVec(*__va->__fbb, __va->__o->aliases_outputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return MNN::CreateIfParam(
      _fbb,
      _then_graph,
      _else_graph,
      _aliases_inputs,
      _aliases_outputs);
}

inline RegionCommandT *RegionCommand::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RegionCommandT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RegionCommand::UnPackTo(RegionCommandT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = op(); if (_e) _o->op = std::unique_ptr<OpT>(_e->UnPack(_resolver)); };
  { auto _e = steps(); if (_e) { _o->steps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->steps[_i] = _e->Get(_i); } } };
  { auto _e = size(); if (_e) { _o->size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size[_i] = _e->Get(_i); } } };
  { auto _e = indexes(); if (_e) { _o->indexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->indexes[_i] = _e->Get(_i); } } };
  { auto _e = view(); if (_e) { _o->view.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->view[_i] = std::unique_ptr<ViewT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = fuse(); _o->fuse = _e; };
  { auto _e = iterIndexes(); if (_e) { _o->iterIndexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->iterIndexes[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<RegionCommand> RegionCommand::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionCommandT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegionCommand(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RegionCommand> CreateRegionCommand(flatbuffers::FlatBufferBuilder &_fbb, const RegionCommandT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegionCommandT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _op = _o->op ? CreateOp(_fbb, _o->op.get(), _rehasher) : 0;
  auto _steps = _o->steps.size() ? _fbb.CreateVector(_o->steps) : 0;
  auto _size = _o->size.size() ? _fbb.CreateVector(_o->size) : 0;
  auto _indexes = _o->indexes.size() ? _fbb.CreateVector(_o->indexes) : 0;
  auto _view = _o->view.size() ? _fbb.CreateVector<flatbuffers::Offset<View>> (_o->view.size(), [](size_t i, _VectorArgs *__va) { return CreateView(*__va->__fbb, __va->__o->view[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _fuse = _o->fuse;
  auto _iterIndexes = _o->iterIndexes.size() ? _fbb.CreateVector(_o->iterIndexes) : 0;
  return MNN::CreateRegionCommand(
      _fbb,
      _op,
      _steps,
      _size,
      _indexes,
      _view,
      _fuse,
      _iterIndexes);
}

inline LoopParamT *LoopParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LoopParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LoopParam::UnPackTo(LoopParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensorNumber(); _o->tensorNumber = _e; };
  { auto _e = outputIndexes(); if (_e) { _o->outputIndexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndexes[_i] = _e->Get(_i); } } };
  { auto _e = inputIndexes(); if (_e) { _o->inputIndexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndexes[_i] = _e->Get(_i); } } };
  { auto _e = extraTensorInfos(); if (_e) { _o->extraTensorInfos.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extraTensorInfos[_i] = std::unique_ptr<TensorDescribeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = parallel(); _o->parallel = _e; };
  { auto _e = loopNumber(); _o->loopNumber = _e; };
  { auto _e = commands(); if (_e) { _o->commands.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->commands[_i] = std::unique_ptr<RegionCommandT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = initCommand(); if (_e) { _o->initCommand.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->initCommand[_i] = std::unique_ptr<RegionCommandT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<LoopParam> LoopParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoopParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoopParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoopParam> CreateLoopParam(flatbuffers::FlatBufferBuilder &_fbb, const LoopParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoopParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensorNumber = _o->tensorNumber;
  auto _outputIndexes = _o->outputIndexes.size() ? _fbb.CreateVector(_o->outputIndexes) : 0;
  auto _inputIndexes = _o->inputIndexes.size() ? _fbb.CreateVector(_o->inputIndexes) : 0;
  auto _extraTensorInfos = _o->extraTensorInfos.size() ? _fbb.CreateVector<flatbuffers::Offset<TensorDescribe>> (_o->extraTensorInfos.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorDescribe(*__va->__fbb, __va->__o->extraTensorInfos[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _parallel = _o->parallel;
  auto _loopNumber = _o->loopNumber;
  auto _commands = _o->commands.size() ? _fbb.CreateVector<flatbuffers::Offset<RegionCommand>> (_o->commands.size(), [](size_t i, _VectorArgs *__va) { return CreateRegionCommand(*__va->__fbb, __va->__o->commands[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _initCommand = _o->initCommand.size() ? _fbb.CreateVector<flatbuffers::Offset<RegionCommand>> (_o->initCommand.size(), [](size_t i, _VectorArgs *__va) { return CreateRegionCommand(*__va->__fbb, __va->__o->initCommand[i].get(), __va->__rehasher); }, &_va ) : 0;
  return MNN::CreateLoopParam(
      _fbb,
      _tensorNumber,
      _outputIndexes,
      _inputIndexes,
      _extraTensorInfos,
      _parallel,
      _loopNumber,
      _commands,
      _initCommand);
}

inline OpT *Op::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OpT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Op::UnPackTo(OpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = inputIndexes(); if (_e) { _o->inputIndexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndexes[_i] = _e->Get(_i); } } };
  { auto _e = main_type(); _o->main.type = _e; };
  { auto _e = main(); if (_e) _o->main.value = OpParameterUnion::UnPack(_e, main_type(), _resolver); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = outputIndexes(); if (_e) { _o->outputIndexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndexes[_i] = _e->Get(_i); } } };
  { auto _e = type(); _o->type = _e; };
  { auto _e = defaultDimentionFormat(); _o->defaultDimentionFormat = _e; };
  { auto _e = externalPath(); if (_e) _o->externalPath = _e->str(); };
}

inline flatbuffers::Offset<Op> Op::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Op> CreateOp(flatbuffers::FlatBufferBuilder &_fbb, const OpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _inputIndexes = _o->inputIndexes.size() ? _fbb.CreateVector(_o->inputIndexes) : 0;
  auto _main_type = _o->main.type;
  auto _main = _o->main.Pack(_fbb);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _outputIndexes = _o->outputIndexes.size() ? _fbb.CreateVector(_o->outputIndexes) : 0;
  auto _type = _o->type;
  auto _defaultDimentionFormat = _o->defaultDimentionFormat;
  auto _externalPath = _o->externalPath.empty() ? 0 : _fbb.CreateString(_o->externalPath);
  return MNN::CreateOp(
      _fbb,
      _inputIndexes,
      _main_type,
      _main,
      _name,
      _outputIndexes,
      _type,
      _defaultDimentionFormat,
      _externalPath);
}

inline ViewT *View::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ViewT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void View::UnPackTo(ViewT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = offset(); _o->offset = _e; };
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<View> View::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ViewT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateView(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<View> CreateView(flatbuffers::FlatBufferBuilder &_fbb, const ViewT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ViewT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _offset = _o->offset;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  return MNN::CreateView(
      _fbb,
      _offset,
      _stride);
}

inline RegionT *Region::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RegionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Region::UnPackTo(RegionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = src(); if (_e) _o->src = std::unique_ptr<ViewT>(_e->UnPack(_resolver)); };
  { auto _e = dst(); if (_e) _o->dst = std::unique_ptr<ViewT>(_e->UnPack(_resolver)); };
  { auto _e = size(); if (_e) { _o->size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size[_i] = _e->Get(_i); } } };
  { auto _e = origin(); _o->origin = _e; };
}

inline flatbuffers::Offset<Region> Region::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Region> CreateRegion(flatbuffers::FlatBufferBuilder &_fbb, const RegionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _src = _o->src ? CreateView(_fbb, _o->src.get(), _rehasher) : 0;
  auto _dst = _o->dst ? CreateView(_fbb, _o->dst.get(), _rehasher) : 0;
  auto _size = _o->size.size() ? _fbb.CreateVector(_o->size) : 0;
  auto _origin = _o->origin;
  return MNN::CreateRegion(
      _fbb,
      _src,
      _dst,
      _size,
      _origin);
}

inline TensorDescribeT *TensorDescribe::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorDescribeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TensorDescribe::UnPackTo(TensorDescribeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blob(); if (_e) _o->blob = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = index(); _o->index = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = regions(); if (_e) { _o->regions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regions[_i] = std::unique_ptr<RegionT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = quantInfo(); if (_e) _o->quantInfo = std::unique_ptr<TensorQuantInfoT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<TensorDescribe> TensorDescribe::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorDescribe(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorDescribe> CreateTensorDescribe(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorDescribeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blob = _o->blob ? CreateBlob(_fbb, _o->blob.get(), _rehasher) : 0;
  auto _index = _o->index;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _regions = _o->regions.size() ? _fbb.CreateVector<flatbuffers::Offset<Region>> (_o->regions.size(), [](size_t i, _VectorArgs *__va) { return CreateRegion(*__va->__fbb, __va->__o->regions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _quantInfo = _o->quantInfo ? CreateTensorQuantInfo(_fbb, _o->quantInfo.get(), _rehasher) : 0;
  return MNN::CreateTensorDescribe(
      _fbb,
      _blob,
      _index,
      _name,
      _regions,
      _quantInfo);
}

inline SubGraphProtoT *SubGraphProto::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SubGraphProtoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SubGraphProto::UnPackTo(SubGraphProtoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } };
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } };
  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensors[_i] = _e->Get(_i)->str(); } } };
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = std::unique_ptr<OpT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = extraTensorDescribe(); if (_e) { _o->extraTensorDescribe.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extraTensorDescribe[_i] = std::unique_ptr<TensorDescribeT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<SubGraphProto> SubGraphProto::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGraphProto(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraphProto> CreateSubGraphProto(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGraphProtoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _tensors = _o->tensors.size() ? _fbb.CreateVectorOfStrings(_o->tensors) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<flatbuffers::Offset<Op>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateOp(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _extraTensorDescribe = _o->extraTensorDescribe.size() ? _fbb.CreateVector<flatbuffers::Offset<TensorDescribe>> (_o->extraTensorDescribe.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorDescribe(*__va->__fbb, __va->__o->extraTensorDescribe[i].get(), __va->__rehasher); }, &_va ) : 0;
  return MNN::CreateSubGraphProto(
      _fbb,
      _name,
      _inputs,
      _outputs,
      _tensors,
      _nodes,
      _extraTensorDescribe);
}

inline TensorQuantInfoT *TensorQuantInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorQuantInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TensorQuantInfo::UnPackTo(TensorQuantInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scale(); _o->scale = _e; };
  { auto _e = zero(); _o->zero = _e; };
  { auto _e = min(); _o->min = _e; };
  { auto _e = max(); _o->max = _e; };
  { auto _e = type(); _o->type = _e; };
}

inline flatbuffers::Offset<TensorQuantInfo> TensorQuantInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorQuantInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorQuantInfo> CreateTensorQuantInfo(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorQuantInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scale = _o->scale;
  auto _zero = _o->zero;
  auto _min = _o->min;
  auto _max = _o->max;
  auto _type = _o->type;
  return MNN::CreateTensorQuantInfo(
      _fbb,
      _scale,
      _zero,
      _min,
      _max,
      _type);
}

inline NetT *Net::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NetT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Net::UnPackTo(NetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bizCode(); if (_e) _o->bizCode = _e->str(); };
  { auto _e = extraTensorDescribe(); if (_e) { _o->extraTensorDescribe.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extraTensorDescribe[_i] = std::unique_ptr<TensorDescribeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = extraInfo(); if (_e) _o->extraInfo = std::unique_ptr<ExtraInfoT>(_e->UnPack(_resolver)); };
  { auto _e = oplists(); if (_e) { _o->oplists.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->oplists[_i] = std::unique_ptr<OpT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = outputName(); if (_e) { _o->outputName.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputName[_i] = _e->Get(_i)->str(); } } };
  { auto _e = preferForwardType(); _o->preferForwardType = _e; };
  { auto _e = sourceType(); _o->sourceType = _e; };
  { auto _e = tensorName(); if (_e) { _o->tensorName.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensorName[_i] = _e->Get(_i)->str(); } } };
  { auto _e = tensorNumber(); _o->tensorNumber = _e; };
  { auto _e = usage(); _o->usage = _e; };
  { auto _e = subgraphs(); if (_e) { _o->subgraphs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->subgraphs[_i] = std::unique_ptr<SubGraphProtoT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = mnn_uuid(); if (_e) _o->mnn_uuid = _e->str(); };
}

inline flatbuffers::Offset<Net> Net::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNet(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Net> CreateNet(flatbuffers::FlatBufferBuilder &_fbb, const NetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bizCode = _o->bizCode.empty() ? 0 : _fbb.CreateString(_o->bizCode);
  auto _extraTensorDescribe = _o->extraTensorDescribe.size() ? _fbb.CreateVector<flatbuffers::Offset<TensorDescribe>> (_o->extraTensorDescribe.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorDescribe(*__va->__fbb, __va->__o->extraTensorDescribe[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _extraInfo = _o->extraInfo ? CreateExtraInfo(_fbb, _o->extraInfo.get(), _rehasher) : 0;
  auto _oplists = _o->oplists.size() ? _fbb.CreateVector<flatbuffers::Offset<Op>> (_o->oplists.size(), [](size_t i, _VectorArgs *__va) { return CreateOp(*__va->__fbb, __va->__o->oplists[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _outputName = _o->outputName.size() ? _fbb.CreateVectorOfStrings(_o->outputName) : 0;
  auto _preferForwardType = _o->preferForwardType;
  auto _sourceType = _o->sourceType;
  auto _tensorName = _o->tensorName.size() ? _fbb.CreateVectorOfStrings(_o->tensorName) : 0;
  auto _tensorNumber = _o->tensorNumber;
  auto _usage = _o->usage;
  auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<flatbuffers::Offset<SubGraphProto>> (_o->subgraphs.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraphProto(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _mnn_uuid = _o->mnn_uuid.empty() ? 0 : _fbb.CreateString(_o->mnn_uuid);
  return MNN::CreateNet(
      _fbb,
      _bizCode,
      _extraTensorDescribe,
      _extraInfo,
      _oplists,
      _outputName,
      _preferForwardType,
      _sourceType,
      _tensorName,
      _tensorNumber,
      _usage,
      _subgraphs,
      _mnn_uuid);
}

inline bool VerifyOpParameter(flatbuffers::Verifier &verifier, const void *obj, OpParameter type) {
  switch (type) {
    case OpParameter_NONE: {
      return true;
    }
    case OpParameter_QuantizedAdd: {
      auto ptr = reinterpret_cast<const QuantizedAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<const ArgMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_AsString: {
      auto ptr = reinterpret_cast<const AsString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Axis: {
      auto ptr = reinterpret_cast<const Axis *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<const BatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_BinaryOp: {
      auto ptr = reinterpret_cast<const BinaryOp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<const Blob *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_CastParam: {
      auto ptr = reinterpret_cast<const CastParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Convolution2D: {
      auto ptr = reinterpret_cast<const Convolution2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Crop: {
      auto ptr = reinterpret_cast<const Crop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_CropAndResize: {
      auto ptr = reinterpret_cast<const CropAndResize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Dequantize: {
      auto ptr = reinterpret_cast<const Dequantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_DetectionOutput: {
      auto ptr = reinterpret_cast<const DetectionOutput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<const Eltwise *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<const ExpandDims *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Fill: {
      auto ptr = reinterpret_cast<const Fill *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<const Flatten *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<const Gather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_GatherV2: {
      auto ptr = reinterpret_cast<const GatherV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_InnerProduct: {
      auto ptr = reinterpret_cast<const InnerProduct *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<const Input *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Interp: {
      auto ptr = reinterpret_cast<const Interp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<const LRN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LSTM: {
      auto ptr = reinterpret_cast<const LSTM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_MatMul: {
      auto ptr = reinterpret_cast<const MatMul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_NonMaxSuppressionV2: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<const Normalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PackParam: {
      auto ptr = reinterpret_cast<const PackParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<const Permute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Plugin: {
      auto ptr = reinterpret_cast<const Plugin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const Pool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<const PRelu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PriorBox: {
      auto ptr = reinterpret_cast<const PriorBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Proposal: {
      auto ptr = reinterpret_cast<const Proposal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedAvgPool: {
      auto ptr = reinterpret_cast<const QuantizedAvgPool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedBiasAdd: {
      auto ptr = reinterpret_cast<const QuantizedBiasAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedConcat: {
      auto ptr = reinterpret_cast<const QuantizedConcat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedLogistic: {
      auto ptr = reinterpret_cast<const QuantizedLogistic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedMatMul: {
      auto ptr = reinterpret_cast<const QuantizedMatMul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedMaxPool: {
      auto ptr = reinterpret_cast<const QuantizedMaxPool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedRelu: {
      auto ptr = reinterpret_cast<const QuantizedRelu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedRelu6: {
      auto ptr = reinterpret_cast<const QuantizedRelu6 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedReshape: {
      auto ptr = reinterpret_cast<const QuantizedReshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedSoftmax: {
      auto ptr = reinterpret_cast<const QuantizedSoftmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizeMaxMin: {
      auto ptr = reinterpret_cast<const QuantizeMaxMin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizeV2: {
      auto ptr = reinterpret_cast<const QuantizeV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Range: {
      auto ptr = reinterpret_cast<const Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Rank: {
      auto ptr = reinterpret_cast<const Rank *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ReduceJoin: {
      auto ptr = reinterpret_cast<const ReduceJoin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ReductionParam: {
      auto ptr = reinterpret_cast<const ReductionParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<const Relu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<const Relu6 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RequantizationRange: {
      auto ptr = reinterpret_cast<const RequantizationRange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Requantize: {
      auto ptr = reinterpret_cast<const Requantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<const Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Resize: {
      auto ptr = reinterpret_cast<const Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RoiParameters: {
      auto ptr = reinterpret_cast<const RoiParameters *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Scale: {
      auto ptr = reinterpret_cast<const Scale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Selu: {
      auto ptr = reinterpret_cast<const Selu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Size: {
      auto ptr = reinterpret_cast<const Size *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<const Slice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_SliceTf: {
      auto ptr = reinterpret_cast<const SliceTf *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_SpaceBatch: {
      auto ptr = reinterpret_cast<const SpaceBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_SqueezeParam: {
      auto ptr = reinterpret_cast<const SqueezeParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_StridedSliceParam: {
      auto ptr = reinterpret_cast<const StridedSliceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TensorConvertInfo: {
      auto ptr = reinterpret_cast<const TensorConvertInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TfQuantizedConv2D: {
      auto ptr = reinterpret_cast<const TfQuantizedConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TopKV2: {
      auto ptr = reinterpret_cast<const TopKV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Transpose: {
      auto ptr = reinterpret_cast<const Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_UnaryOp: {
      auto ptr = reinterpret_cast<const UnaryOp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_MomentsParam: {
      auto ptr = reinterpret_cast<const MomentsParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RNNParam: {
      auto ptr = reinterpret_cast<const RNNParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_BatchMatMulParam: {
      auto ptr = reinterpret_cast<const BatchMatMulParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedFloatParam: {
      auto ptr = reinterpret_cast<const QuantizedFloatParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_DepthSpaceParam: {
      auto ptr = reinterpret_cast<const DepthSpaceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_EltwiseInt8: {
      auto ptr = reinterpret_cast<const EltwiseInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ReverseSequenceParam: {
      auto ptr = reinterpret_cast<const ReverseSequenceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<const Extra *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Pool3D: {
      auto ptr = reinterpret_cast<const Pool3D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Convolution3D: {
      auto ptr = reinterpret_cast<const Convolution3D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<const ELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_DetectionPostProcessParam: {
      auto ptr = reinterpret_cast<const DetectionPostProcessParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_OneHotParam: {
      auto ptr = reinterpret_cast<const OneHotParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PadParam: {
      auto ptr = reinterpret_cast<const PadParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_WhileParam: {
      auto ptr = reinterpret_cast<const WhileParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_IfParam: {
      auto ptr = reinterpret_cast<const IfParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RandomUniform: {
      auto ptr = reinterpret_cast<const RandomUniform *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<const LayerNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TensorArray: {
      auto ptr = reinterpret_cast<const TensorArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LSTMBlockCell: {
      auto ptr = reinterpret_cast<const LSTMBlockCell *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_GridSample: {
      auto ptr = reinterpret_cast<const GridSample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LoopParam: {
      auto ptr = reinterpret_cast<const LoopParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ImageProcessParam: {
      auto ptr = reinterpret_cast<const ImageProcessParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_CumSum: {
      auto ptr = reinterpret_cast<const CumSum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_GroupNorm: {
      auto ptr = reinterpret_cast<const GroupNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_FmhaV2Param: {
      auto ptr = reinterpret_cast<const FmhaV2Param *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_FmhcaParam: {
      auto ptr = reinterpret_cast<const FmhcaParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_AttentionParam: {
      auto ptr = reinterpret_cast<const AttentionParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyOpParameterVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpParameter(
        verifier,  values->Get(i), types->GetEnum<OpParameter>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OpParameterUnion::UnPack(const void *obj, OpParameter type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case OpParameter_QuantizedAdd: {
      auto ptr = reinterpret_cast<const QuantizedAdd *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<const ArgMax *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_AsString: {
      auto ptr = reinterpret_cast<const AsString *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Axis: {
      auto ptr = reinterpret_cast<const Axis *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<const BatchNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_BinaryOp: {
      auto ptr = reinterpret_cast<const BinaryOp *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<const Blob *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_CastParam: {
      auto ptr = reinterpret_cast<const CastParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Convolution2D: {
      auto ptr = reinterpret_cast<const Convolution2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Crop: {
      auto ptr = reinterpret_cast<const Crop *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_CropAndResize: {
      auto ptr = reinterpret_cast<const CropAndResize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Dequantize: {
      auto ptr = reinterpret_cast<const Dequantize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_DetectionOutput: {
      auto ptr = reinterpret_cast<const DetectionOutput *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<const Eltwise *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<const ExpandDims *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Fill: {
      auto ptr = reinterpret_cast<const Fill *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<const Flatten *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<const Gather *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_GatherV2: {
      auto ptr = reinterpret_cast<const GatherV2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_InnerProduct: {
      auto ptr = reinterpret_cast<const InnerProduct *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<const Input *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Interp: {
      auto ptr = reinterpret_cast<const Interp *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<const LRN *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LSTM: {
      auto ptr = reinterpret_cast<const LSTM *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_MatMul: {
      auto ptr = reinterpret_cast<const MatMul *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_NonMaxSuppressionV2: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<const Normalize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_PackParam: {
      auto ptr = reinterpret_cast<const PackParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<const Permute *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Plugin: {
      auto ptr = reinterpret_cast<const Plugin *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const Pool *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<const PRelu *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_PriorBox: {
      auto ptr = reinterpret_cast<const PriorBox *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Proposal: {
      auto ptr = reinterpret_cast<const Proposal *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedAvgPool: {
      auto ptr = reinterpret_cast<const QuantizedAvgPool *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedBiasAdd: {
      auto ptr = reinterpret_cast<const QuantizedBiasAdd *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedConcat: {
      auto ptr = reinterpret_cast<const QuantizedConcat *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedLogistic: {
      auto ptr = reinterpret_cast<const QuantizedLogistic *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedMatMul: {
      auto ptr = reinterpret_cast<const QuantizedMatMul *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedMaxPool: {
      auto ptr = reinterpret_cast<const QuantizedMaxPool *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedRelu: {
      auto ptr = reinterpret_cast<const QuantizedRelu *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedRelu6: {
      auto ptr = reinterpret_cast<const QuantizedRelu6 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedReshape: {
      auto ptr = reinterpret_cast<const QuantizedReshape *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedSoftmax: {
      auto ptr = reinterpret_cast<const QuantizedSoftmax *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizeMaxMin: {
      auto ptr = reinterpret_cast<const QuantizeMaxMin *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizeV2: {
      auto ptr = reinterpret_cast<const QuantizeV2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Range: {
      auto ptr = reinterpret_cast<const Range *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Rank: {
      auto ptr = reinterpret_cast<const Rank *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ReduceJoin: {
      auto ptr = reinterpret_cast<const ReduceJoin *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ReductionParam: {
      auto ptr = reinterpret_cast<const ReductionParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<const Relu *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<const Relu6 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_RequantizationRange: {
      auto ptr = reinterpret_cast<const RequantizationRange *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Requantize: {
      auto ptr = reinterpret_cast<const Requantize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<const Reshape *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Resize: {
      auto ptr = reinterpret_cast<const Resize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_RoiParameters: {
      auto ptr = reinterpret_cast<const RoiParameters *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Scale: {
      auto ptr = reinterpret_cast<const Scale *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Selu: {
      auto ptr = reinterpret_cast<const Selu *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Size: {
      auto ptr = reinterpret_cast<const Size *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<const Slice *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_SliceTf: {
      auto ptr = reinterpret_cast<const SliceTf *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_SpaceBatch: {
      auto ptr = reinterpret_cast<const SpaceBatch *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_SqueezeParam: {
      auto ptr = reinterpret_cast<const SqueezeParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_StridedSliceParam: {
      auto ptr = reinterpret_cast<const StridedSliceParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_TensorConvertInfo: {
      auto ptr = reinterpret_cast<const TensorConvertInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_TfQuantizedConv2D: {
      auto ptr = reinterpret_cast<const TfQuantizedConv2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_TopKV2: {
      auto ptr = reinterpret_cast<const TopKV2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Transpose: {
      auto ptr = reinterpret_cast<const Transpose *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_UnaryOp: {
      auto ptr = reinterpret_cast<const UnaryOp *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_MomentsParam: {
      auto ptr = reinterpret_cast<const MomentsParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_RNNParam: {
      auto ptr = reinterpret_cast<const RNNParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_BatchMatMulParam: {
      auto ptr = reinterpret_cast<const BatchMatMulParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedFloatParam: {
      auto ptr = reinterpret_cast<const QuantizedFloatParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_DepthSpaceParam: {
      auto ptr = reinterpret_cast<const DepthSpaceParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_EltwiseInt8: {
      auto ptr = reinterpret_cast<const EltwiseInt8 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ReverseSequenceParam: {
      auto ptr = reinterpret_cast<const ReverseSequenceParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<const Extra *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Pool3D: {
      auto ptr = reinterpret_cast<const Pool3D *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Convolution3D: {
      auto ptr = reinterpret_cast<const Convolution3D *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<const ELU *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_DetectionPostProcessParam: {
      auto ptr = reinterpret_cast<const DetectionPostProcessParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_OneHotParam: {
      auto ptr = reinterpret_cast<const OneHotParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_PadParam: {
      auto ptr = reinterpret_cast<const PadParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_WhileParam: {
      auto ptr = reinterpret_cast<const WhileParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_IfParam: {
      auto ptr = reinterpret_cast<const IfParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_RandomUniform: {
      auto ptr = reinterpret_cast<const RandomUniform *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<const LayerNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_TensorArray: {
      auto ptr = reinterpret_cast<const TensorArray *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LSTMBlockCell: {
      auto ptr = reinterpret_cast<const LSTMBlockCell *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_GridSample: {
      auto ptr = reinterpret_cast<const GridSample *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LoopParam: {
      auto ptr = reinterpret_cast<const LoopParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ImageProcessParam: {
      auto ptr = reinterpret_cast<const ImageProcessParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_CumSum: {
      auto ptr = reinterpret_cast<const CumSum *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_GroupNorm: {
      auto ptr = reinterpret_cast<const GroupNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_FmhaV2Param: {
      auto ptr = reinterpret_cast<const FmhaV2Param *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_FmhcaParam: {
      auto ptr = reinterpret_cast<const FmhcaParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_AttentionParam: {
      auto ptr = reinterpret_cast<const AttentionParam *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> OpParameterUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case OpParameter_QuantizedAdd: {
      auto ptr = reinterpret_cast<const QuantizedAddT *>(value);
      return CreateQuantizedAdd(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<const ArgMaxT *>(value);
      return CreateArgMax(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_AsString: {
      auto ptr = reinterpret_cast<const AsStringT *>(value);
      return CreateAsString(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Axis: {
      auto ptr = reinterpret_cast<const AxisT *>(value);
      return CreateAxis(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<const BatchNormT *>(value);
      return CreateBatchNorm(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_BinaryOp: {
      auto ptr = reinterpret_cast<const BinaryOpT *>(value);
      return CreateBinaryOp(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<const BlobT *>(value);
      return CreateBlob(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_CastParam: {
      auto ptr = reinterpret_cast<const CastParamT *>(value);
      return CreateCastParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Convolution2D: {
      auto ptr = reinterpret_cast<const Convolution2DT *>(value);
      return CreateConvolution2D(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Crop: {
      auto ptr = reinterpret_cast<const CropT *>(value);
      return CreateCrop(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_CropAndResize: {
      auto ptr = reinterpret_cast<const CropAndResizeT *>(value);
      return CreateCropAndResize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Dequantize: {
      auto ptr = reinterpret_cast<const DequantizeT *>(value);
      return CreateDequantize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_DetectionOutput: {
      auto ptr = reinterpret_cast<const DetectionOutputT *>(value);
      return CreateDetectionOutput(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<const EltwiseT *>(value);
      return CreateEltwise(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<const ExpandDimsT *>(value);
      return CreateExpandDims(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Fill: {
      auto ptr = reinterpret_cast<const FillT *>(value);
      return CreateFill(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<const FlattenT *>(value);
      return CreateFlatten(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<const GatherT *>(value);
      return CreateGather(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_GatherV2: {
      auto ptr = reinterpret_cast<const GatherV2T *>(value);
      return CreateGatherV2(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_InnerProduct: {
      auto ptr = reinterpret_cast<const InnerProductT *>(value);
      return CreateInnerProduct(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<const InputT *>(value);
      return CreateInput(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Interp: {
      auto ptr = reinterpret_cast<const InterpT *>(value);
      return CreateInterp(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<const LRNT *>(value);
      return CreateLRN(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LSTM: {
      auto ptr = reinterpret_cast<const LSTMT *>(value);
      return CreateLSTM(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_MatMul: {
      auto ptr = reinterpret_cast<const MatMulT *>(value);
      return CreateMatMul(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_NonMaxSuppressionV2: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV2T *>(value);
      return CreateNonMaxSuppressionV2(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<const NormalizeT *>(value);
      return CreateNormalize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_PackParam: {
      auto ptr = reinterpret_cast<const PackParamT *>(value);
      return CreatePackParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<const PermuteT *>(value);
      return CreatePermute(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Plugin: {
      auto ptr = reinterpret_cast<const PluginT *>(value);
      return CreatePlugin(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const PoolT *>(value);
      return CreatePool(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<const PReluT *>(value);
      return CreatePRelu(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_PriorBox: {
      auto ptr = reinterpret_cast<const PriorBoxT *>(value);
      return CreatePriorBox(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Proposal: {
      auto ptr = reinterpret_cast<const ProposalT *>(value);
      return CreateProposal(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedAvgPool: {
      auto ptr = reinterpret_cast<const QuantizedAvgPoolT *>(value);
      return CreateQuantizedAvgPool(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedBiasAdd: {
      auto ptr = reinterpret_cast<const QuantizedBiasAddT *>(value);
      return CreateQuantizedBiasAdd(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedConcat: {
      auto ptr = reinterpret_cast<const QuantizedConcatT *>(value);
      return CreateQuantizedConcat(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedLogistic: {
      auto ptr = reinterpret_cast<const QuantizedLogisticT *>(value);
      return CreateQuantizedLogistic(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedMatMul: {
      auto ptr = reinterpret_cast<const QuantizedMatMulT *>(value);
      return CreateQuantizedMatMul(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedMaxPool: {
      auto ptr = reinterpret_cast<const QuantizedMaxPoolT *>(value);
      return CreateQuantizedMaxPool(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedRelu: {
      auto ptr = reinterpret_cast<const QuantizedReluT *>(value);
      return CreateQuantizedRelu(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedRelu6: {
      auto ptr = reinterpret_cast<const QuantizedRelu6T *>(value);
      return CreateQuantizedRelu6(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedReshape: {
      auto ptr = reinterpret_cast<const QuantizedReshapeT *>(value);
      return CreateQuantizedReshape(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedSoftmax: {
      auto ptr = reinterpret_cast<const QuantizedSoftmaxT *>(value);
      return CreateQuantizedSoftmax(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizeMaxMin: {
      auto ptr = reinterpret_cast<const QuantizeMaxMinT *>(value);
      return CreateQuantizeMaxMin(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizeV2: {
      auto ptr = reinterpret_cast<const QuantizeV2T *>(value);
      return CreateQuantizeV2(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Range: {
      auto ptr = reinterpret_cast<const RangeT *>(value);
      return CreateRange(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Rank: {
      auto ptr = reinterpret_cast<const RankT *>(value);
      return CreateRank(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ReduceJoin: {
      auto ptr = reinterpret_cast<const ReduceJoinT *>(value);
      return CreateReduceJoin(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ReductionParam: {
      auto ptr = reinterpret_cast<const ReductionParamT *>(value);
      return CreateReductionParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<const ReluT *>(value);
      return CreateRelu(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<const Relu6T *>(value);
      return CreateRelu6(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_RequantizationRange: {
      auto ptr = reinterpret_cast<const RequantizationRangeT *>(value);
      return CreateRequantizationRange(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Requantize: {
      auto ptr = reinterpret_cast<const RequantizeT *>(value);
      return CreateRequantize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<const ReshapeT *>(value);
      return CreateReshape(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Resize: {
      auto ptr = reinterpret_cast<const ResizeT *>(value);
      return CreateResize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_RoiParameters: {
      auto ptr = reinterpret_cast<const RoiParametersT *>(value);
      return CreateRoiParameters(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Scale: {
      auto ptr = reinterpret_cast<const ScaleT *>(value);
      return CreateScale(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Selu: {
      auto ptr = reinterpret_cast<const SeluT *>(value);
      return CreateSelu(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Size: {
      auto ptr = reinterpret_cast<const SizeT *>(value);
      return CreateSize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<const SliceT *>(value);
      return CreateSlice(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_SliceTf: {
      auto ptr = reinterpret_cast<const SliceTfT *>(value);
      return CreateSliceTf(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_SpaceBatch: {
      auto ptr = reinterpret_cast<const SpaceBatchT *>(value);
      return CreateSpaceBatch(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_SqueezeParam: {
      auto ptr = reinterpret_cast<const SqueezeParamT *>(value);
      return CreateSqueezeParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_StridedSliceParam: {
      auto ptr = reinterpret_cast<const StridedSliceParamT *>(value);
      return CreateStridedSliceParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_TensorConvertInfo: {
      auto ptr = reinterpret_cast<const TensorConvertInfoT *>(value);
      return CreateTensorConvertInfo(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_TfQuantizedConv2D: {
      auto ptr = reinterpret_cast<const TfQuantizedConv2DT *>(value);
      return CreateTfQuantizedConv2D(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_TopKV2: {
      auto ptr = reinterpret_cast<const TopKV2T *>(value);
      return CreateTopKV2(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Transpose: {
      auto ptr = reinterpret_cast<const TransposeT *>(value);
      return CreateTranspose(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_UnaryOp: {
      auto ptr = reinterpret_cast<const UnaryOpT *>(value);
      return CreateUnaryOp(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_MomentsParam: {
      auto ptr = reinterpret_cast<const MomentsParamT *>(value);
      return CreateMomentsParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_RNNParam: {
      auto ptr = reinterpret_cast<const RNNParamT *>(value);
      return CreateRNNParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_BatchMatMulParam: {
      auto ptr = reinterpret_cast<const BatchMatMulParamT *>(value);
      return CreateBatchMatMulParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedFloatParam: {
      auto ptr = reinterpret_cast<const QuantizedFloatParamT *>(value);
      return CreateQuantizedFloatParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_DepthSpaceParam: {
      auto ptr = reinterpret_cast<const DepthSpaceParamT *>(value);
      return CreateDepthSpaceParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_EltwiseInt8: {
      auto ptr = reinterpret_cast<const EltwiseInt8T *>(value);
      return CreateEltwiseInt8(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ReverseSequenceParam: {
      auto ptr = reinterpret_cast<const ReverseSequenceParamT *>(value);
      return CreateReverseSequenceParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<const ExtraT *>(value);
      return CreateExtra(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Pool3D: {
      auto ptr = reinterpret_cast<const Pool3DT *>(value);
      return CreatePool3D(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Convolution3D: {
      auto ptr = reinterpret_cast<const Convolution3DT *>(value);
      return CreateConvolution3D(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<const ELUT *>(value);
      return CreateELU(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_DetectionPostProcessParam: {
      auto ptr = reinterpret_cast<const DetectionPostProcessParamT *>(value);
      return CreateDetectionPostProcessParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_OneHotParam: {
      auto ptr = reinterpret_cast<const OneHotParamT *>(value);
      return CreateOneHotParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_PadParam: {
      auto ptr = reinterpret_cast<const PadParamT *>(value);
      return CreatePadParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_WhileParam: {
      auto ptr = reinterpret_cast<const WhileParamT *>(value);
      return CreateWhileParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_IfParam: {
      auto ptr = reinterpret_cast<const IfParamT *>(value);
      return CreateIfParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_RandomUniform: {
      auto ptr = reinterpret_cast<const RandomUniformT *>(value);
      return CreateRandomUniform(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<const LayerNormT *>(value);
      return CreateLayerNorm(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_TensorArray: {
      auto ptr = reinterpret_cast<const TensorArrayT *>(value);
      return CreateTensorArray(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LSTMBlockCell: {
      auto ptr = reinterpret_cast<const LSTMBlockCellT *>(value);
      return CreateLSTMBlockCell(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_GridSample: {
      auto ptr = reinterpret_cast<const GridSampleT *>(value);
      return CreateGridSample(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LoopParam: {
      auto ptr = reinterpret_cast<const LoopParamT *>(value);
      return CreateLoopParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ImageProcessParam: {
      auto ptr = reinterpret_cast<const ImageProcessParamT *>(value);
      return CreateImageProcessParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_CumSum: {
      auto ptr = reinterpret_cast<const CumSumT *>(value);
      return CreateCumSum(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_GroupNorm: {
      auto ptr = reinterpret_cast<const GroupNormT *>(value);
      return CreateGroupNorm(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_FmhaV2Param: {
      auto ptr = reinterpret_cast<const FmhaV2ParamT *>(value);
      return CreateFmhaV2Param(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_FmhcaParam: {
      auto ptr = reinterpret_cast<const FmhcaParamT *>(value);
      return CreateFmhcaParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_AttentionParam: {
      auto ptr = reinterpret_cast<const AttentionParamT *>(value);
      return CreateAttentionParam(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OpParameterUnion::OpParameterUnion(const OpParameterUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case OpParameter_QuantizedAdd: {
      FLATBUFFERS_ASSERT(false);  // QuantizedAddT not copyable.
      break;
    }
    case OpParameter_ArgMax: {
      value = new ArgMaxT(*reinterpret_cast<ArgMaxT *>(u.value));
      break;
    }
    case OpParameter_AsString: {
      value = new AsStringT(*reinterpret_cast<AsStringT *>(u.value));
      break;
    }
    case OpParameter_Axis: {
      value = new AxisT(*reinterpret_cast<AxisT *>(u.value));
      break;
    }
    case OpParameter_BatchNorm: {
      value = new BatchNormT(*reinterpret_cast<BatchNormT *>(u.value));
      break;
    }
    case OpParameter_BinaryOp: {
      value = new BinaryOpT(*reinterpret_cast<BinaryOpT *>(u.value));
      break;
    }
    case OpParameter_Blob: {
      value = new BlobT(*reinterpret_cast<BlobT *>(u.value));
      break;
    }
    case OpParameter_CastParam: {
      value = new CastParamT(*reinterpret_cast<CastParamT *>(u.value));
      break;
    }
    case OpParameter_Convolution2D: {
      FLATBUFFERS_ASSERT(false);  // Convolution2DT not copyable.
      break;
    }
    case OpParameter_Crop: {
      value = new CropT(*reinterpret_cast<CropT *>(u.value));
      break;
    }
    case OpParameter_CropAndResize: {
      value = new CropAndResizeT(*reinterpret_cast<CropAndResizeT *>(u.value));
      break;
    }
    case OpParameter_Dequantize: {
      FLATBUFFERS_ASSERT(false);  // DequantizeT not copyable.
      break;
    }
    case OpParameter_DetectionOutput: {
      value = new DetectionOutputT(*reinterpret_cast<DetectionOutputT *>(u.value));
      break;
    }
    case OpParameter_Eltwise: {
      value = new EltwiseT(*reinterpret_cast<EltwiseT *>(u.value));
      break;
    }
    case OpParameter_ExpandDims: {
      value = new ExpandDimsT(*reinterpret_cast<ExpandDimsT *>(u.value));
      break;
    }
    case OpParameter_Fill: {
      value = new FillT(*reinterpret_cast<FillT *>(u.value));
      break;
    }
    case OpParameter_Flatten: {
      value = new FlattenT(*reinterpret_cast<FlattenT *>(u.value));
      break;
    }
    case OpParameter_Gather: {
      value = new GatherT(*reinterpret_cast<GatherT *>(u.value));
      break;
    }
    case OpParameter_GatherV2: {
      value = new GatherV2T(*reinterpret_cast<GatherV2T *>(u.value));
      break;
    }
    case OpParameter_InnerProduct: {
      FLATBUFFERS_ASSERT(false);  // InnerProductT not copyable.
      break;
    }
    case OpParameter_Input: {
      value = new InputT(*reinterpret_cast<InputT *>(u.value));
      break;
    }
    case OpParameter_Interp: {
      value = new InterpT(*reinterpret_cast<InterpT *>(u.value));
      break;
    }
    case OpParameter_LRN: {
      value = new LRNT(*reinterpret_cast<LRNT *>(u.value));
      break;
    }
    case OpParameter_LSTM: {
      FLATBUFFERS_ASSERT(false);  // LSTMT not copyable.
      break;
    }
    case OpParameter_MatMul: {
      value = new MatMulT(*reinterpret_cast<MatMulT *>(u.value));
      break;
    }
    case OpParameter_NonMaxSuppressionV2: {
      value = new NonMaxSuppressionV2T(*reinterpret_cast<NonMaxSuppressionV2T *>(u.value));
      break;
    }
    case OpParameter_Normalize: {
      value = new NormalizeT(*reinterpret_cast<NormalizeT *>(u.value));
      break;
    }
    case OpParameter_PackParam: {
      value = new PackParamT(*reinterpret_cast<PackParamT *>(u.value));
      break;
    }
    case OpParameter_Permute: {
      value = new PermuteT(*reinterpret_cast<PermuteT *>(u.value));
      break;
    }
    case OpParameter_Plugin: {
      FLATBUFFERS_ASSERT(false);  // PluginT not copyable.
      break;
    }
    case OpParameter_Pool: {
      value = new PoolT(*reinterpret_cast<PoolT *>(u.value));
      break;
    }
    case OpParameter_PRelu: {
      value = new PReluT(*reinterpret_cast<PReluT *>(u.value));
      break;
    }
    case OpParameter_PriorBox: {
      value = new PriorBoxT(*reinterpret_cast<PriorBoxT *>(u.value));
      break;
    }
    case OpParameter_Proposal: {
      FLATBUFFERS_ASSERT(false);  // ProposalT not copyable.
      break;
    }
    case OpParameter_QuantizedAvgPool: {
      value = new QuantizedAvgPoolT(*reinterpret_cast<QuantizedAvgPoolT *>(u.value));
      break;
    }
    case OpParameter_QuantizedBiasAdd: {
      value = new QuantizedBiasAddT(*reinterpret_cast<QuantizedBiasAddT *>(u.value));
      break;
    }
    case OpParameter_QuantizedConcat: {
      FLATBUFFERS_ASSERT(false);  // QuantizedConcatT not copyable.
      break;
    }
    case OpParameter_QuantizedLogistic: {
      FLATBUFFERS_ASSERT(false);  // QuantizedLogisticT not copyable.
      break;
    }
    case OpParameter_QuantizedMatMul: {
      value = new QuantizedMatMulT(*reinterpret_cast<QuantizedMatMulT *>(u.value));
      break;
    }
    case OpParameter_QuantizedMaxPool: {
      value = new QuantizedMaxPoolT(*reinterpret_cast<QuantizedMaxPoolT *>(u.value));
      break;
    }
    case OpParameter_QuantizedRelu: {
      value = new QuantizedReluT(*reinterpret_cast<QuantizedReluT *>(u.value));
      break;
    }
    case OpParameter_QuantizedRelu6: {
      value = new QuantizedRelu6T(*reinterpret_cast<QuantizedRelu6T *>(u.value));
      break;
    }
    case OpParameter_QuantizedReshape: {
      value = new QuantizedReshapeT(*reinterpret_cast<QuantizedReshapeT *>(u.value));
      break;
    }
    case OpParameter_QuantizedSoftmax: {
      value = new QuantizedSoftmaxT(*reinterpret_cast<QuantizedSoftmaxT *>(u.value));
      break;
    }
    case OpParameter_QuantizeMaxMin: {
      value = new QuantizeMaxMinT(*reinterpret_cast<QuantizeMaxMinT *>(u.value));
      break;
    }
    case OpParameter_QuantizeV2: {
      value = new QuantizeV2T(*reinterpret_cast<QuantizeV2T *>(u.value));
      break;
    }
    case OpParameter_Range: {
      value = new RangeT(*reinterpret_cast<RangeT *>(u.value));
      break;
    }
    case OpParameter_Rank: {
      value = new RankT(*reinterpret_cast<RankT *>(u.value));
      break;
    }
    case OpParameter_ReduceJoin: {
      value = new ReduceJoinT(*reinterpret_cast<ReduceJoinT *>(u.value));
      break;
    }
    case OpParameter_ReductionParam: {
      value = new ReductionParamT(*reinterpret_cast<ReductionParamT *>(u.value));
      break;
    }
    case OpParameter_Relu: {
      value = new ReluT(*reinterpret_cast<ReluT *>(u.value));
      break;
    }
    case OpParameter_Relu6: {
      value = new Relu6T(*reinterpret_cast<Relu6T *>(u.value));
      break;
    }
    case OpParameter_RequantizationRange: {
      value = new RequantizationRangeT(*reinterpret_cast<RequantizationRangeT *>(u.value));
      break;
    }
    case OpParameter_Requantize: {
      value = new RequantizeT(*reinterpret_cast<RequantizeT *>(u.value));
      break;
    }
    case OpParameter_Reshape: {
      value = new ReshapeT(*reinterpret_cast<ReshapeT *>(u.value));
      break;
    }
    case OpParameter_Resize: {
      value = new ResizeT(*reinterpret_cast<ResizeT *>(u.value));
      break;
    }
    case OpParameter_RoiParameters: {
      value = new RoiParametersT(*reinterpret_cast<RoiParametersT *>(u.value));
      break;
    }
    case OpParameter_Scale: {
      value = new ScaleT(*reinterpret_cast<ScaleT *>(u.value));
      break;
    }
    case OpParameter_Selu: {
      value = new SeluT(*reinterpret_cast<SeluT *>(u.value));
      break;
    }
    case OpParameter_Size: {
      value = new SizeT(*reinterpret_cast<SizeT *>(u.value));
      break;
    }
    case OpParameter_Slice: {
      value = new SliceT(*reinterpret_cast<SliceT *>(u.value));
      break;
    }
    case OpParameter_SliceTf: {
      value = new SliceTfT(*reinterpret_cast<SliceTfT *>(u.value));
      break;
    }
    case OpParameter_SpaceBatch: {
      FLATBUFFERS_ASSERT(false);  // SpaceBatchT not copyable.
      break;
    }
    case OpParameter_SqueezeParam: {
      value = new SqueezeParamT(*reinterpret_cast<SqueezeParamT *>(u.value));
      break;
    }
    case OpParameter_StridedSliceParam: {
      value = new StridedSliceParamT(*reinterpret_cast<StridedSliceParamT *>(u.value));
      break;
    }
    case OpParameter_TensorConvertInfo: {
      value = new TensorConvertInfoT(*reinterpret_cast<TensorConvertInfoT *>(u.value));
      break;
    }
    case OpParameter_TfQuantizedConv2D: {
      FLATBUFFERS_ASSERT(false);  // TfQuantizedConv2DT not copyable.
      break;
    }
    case OpParameter_TopKV2: {
      value = new TopKV2T(*reinterpret_cast<TopKV2T *>(u.value));
      break;
    }
    case OpParameter_Transpose: {
      value = new TransposeT(*reinterpret_cast<TransposeT *>(u.value));
      break;
    }
    case OpParameter_UnaryOp: {
      value = new UnaryOpT(*reinterpret_cast<UnaryOpT *>(u.value));
      break;
    }
    case OpParameter_MomentsParam: {
      value = new MomentsParamT(*reinterpret_cast<MomentsParamT *>(u.value));
      break;
    }
    case OpParameter_RNNParam: {
      FLATBUFFERS_ASSERT(false);  // RNNParamT not copyable.
      break;
    }
    case OpParameter_BatchMatMulParam: {
      value = new BatchMatMulParamT(*reinterpret_cast<BatchMatMulParamT *>(u.value));
      break;
    }
    case OpParameter_QuantizedFloatParam: {
      value = new QuantizedFloatParamT(*reinterpret_cast<QuantizedFloatParamT *>(u.value));
      break;
    }
    case OpParameter_DepthSpaceParam: {
      value = new DepthSpaceParamT(*reinterpret_cast<DepthSpaceParamT *>(u.value));
      break;
    }
    case OpParameter_EltwiseInt8: {
      FLATBUFFERS_ASSERT(false);  // EltwiseInt8T not copyable.
      break;
    }
    case OpParameter_ReverseSequenceParam: {
      value = new ReverseSequenceParamT(*reinterpret_cast<ReverseSequenceParamT *>(u.value));
      break;
    }
    case OpParameter_Extra: {
      FLATBUFFERS_ASSERT(false);  // ExtraT not copyable.
      break;
    }
    case OpParameter_Pool3D: {
      value = new Pool3DT(*reinterpret_cast<Pool3DT *>(u.value));
      break;
    }
    case OpParameter_Convolution3D: {
      FLATBUFFERS_ASSERT(false);  // Convolution3DT not copyable.
      break;
    }
    case OpParameter_ELU: {
      value = new ELUT(*reinterpret_cast<ELUT *>(u.value));
      break;
    }
    case OpParameter_DetectionPostProcessParam: {
      value = new DetectionPostProcessParamT(*reinterpret_cast<DetectionPostProcessParamT *>(u.value));
      break;
    }
    case OpParameter_OneHotParam: {
      value = new OneHotParamT(*reinterpret_cast<OneHotParamT *>(u.value));
      break;
    }
    case OpParameter_PadParam: {
      value = new PadParamT(*reinterpret_cast<PadParamT *>(u.value));
      break;
    }
    case OpParameter_WhileParam: {
      FLATBUFFERS_ASSERT(false);  // WhileParamT not copyable.
      break;
    }
    case OpParameter_IfParam: {
      FLATBUFFERS_ASSERT(false);  // IfParamT not copyable.
      break;
    }
    case OpParameter_RandomUniform: {
      value = new RandomUniformT(*reinterpret_cast<RandomUniformT *>(u.value));
      break;
    }
    case OpParameter_LayerNorm: {
      value = new LayerNormT(*reinterpret_cast<LayerNormT *>(u.value));
      break;
    }
    case OpParameter_TensorArray: {
      value = new TensorArrayT(*reinterpret_cast<TensorArrayT *>(u.value));
      break;
    }
    case OpParameter_LSTMBlockCell: {
      value = new LSTMBlockCellT(*reinterpret_cast<LSTMBlockCellT *>(u.value));
      break;
    }
    case OpParameter_GridSample: {
      value = new GridSampleT(*reinterpret_cast<GridSampleT *>(u.value));
      break;
    }
    case OpParameter_LoopParam: {
      FLATBUFFERS_ASSERT(false);  // LoopParamT not copyable.
      break;
    }
    case OpParameter_ImageProcessParam: {
      value = new ImageProcessParamT(*reinterpret_cast<ImageProcessParamT *>(u.value));
      break;
    }
    case OpParameter_CumSum: {
      value = new CumSumT(*reinterpret_cast<CumSumT *>(u.value));
      break;
    }
    case OpParameter_GroupNorm: {
      value = new GroupNormT(*reinterpret_cast<GroupNormT *>(u.value));
      break;
    }
    case OpParameter_FmhaV2Param: {
      value = new FmhaV2ParamT(*reinterpret_cast<FmhaV2ParamT *>(u.value));
      break;
    }
    case OpParameter_FmhcaParam: {
      value = new FmhcaParamT(*reinterpret_cast<FmhcaParamT *>(u.value));
      break;
    }
    case OpParameter_AttentionParam: {
      value = new AttentionParamT(*reinterpret_cast<AttentionParamT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OpParameterUnion::Reset() {
  switch (type) {
    case OpParameter_QuantizedAdd: {
      auto ptr = reinterpret_cast<QuantizedAddT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<ArgMaxT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_AsString: {
      auto ptr = reinterpret_cast<AsStringT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Axis: {
      auto ptr = reinterpret_cast<AxisT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<BatchNormT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_BinaryOp: {
      auto ptr = reinterpret_cast<BinaryOpT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<BlobT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_CastParam: {
      auto ptr = reinterpret_cast<CastParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Convolution2D: {
      auto ptr = reinterpret_cast<Convolution2DT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Crop: {
      auto ptr = reinterpret_cast<CropT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_CropAndResize: {
      auto ptr = reinterpret_cast<CropAndResizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Dequantize: {
      auto ptr = reinterpret_cast<DequantizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_DetectionOutput: {
      auto ptr = reinterpret_cast<DetectionOutputT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<EltwiseT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<ExpandDimsT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Fill: {
      auto ptr = reinterpret_cast<FillT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<FlattenT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<GatherT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_GatherV2: {
      auto ptr = reinterpret_cast<GatherV2T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_InnerProduct: {
      auto ptr = reinterpret_cast<InnerProductT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<InputT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Interp: {
      auto ptr = reinterpret_cast<InterpT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<LRNT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LSTM: {
      auto ptr = reinterpret_cast<LSTMT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_MatMul: {
      auto ptr = reinterpret_cast<MatMulT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_NonMaxSuppressionV2: {
      auto ptr = reinterpret_cast<NonMaxSuppressionV2T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<NormalizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_PackParam: {
      auto ptr = reinterpret_cast<PackParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<PermuteT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Plugin: {
      auto ptr = reinterpret_cast<PluginT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<PoolT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<PReluT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_PriorBox: {
      auto ptr = reinterpret_cast<PriorBoxT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Proposal: {
      auto ptr = reinterpret_cast<ProposalT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedAvgPool: {
      auto ptr = reinterpret_cast<QuantizedAvgPoolT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedBiasAdd: {
      auto ptr = reinterpret_cast<QuantizedBiasAddT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedConcat: {
      auto ptr = reinterpret_cast<QuantizedConcatT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedLogistic: {
      auto ptr = reinterpret_cast<QuantizedLogisticT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedMatMul: {
      auto ptr = reinterpret_cast<QuantizedMatMulT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedMaxPool: {
      auto ptr = reinterpret_cast<QuantizedMaxPoolT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedRelu: {
      auto ptr = reinterpret_cast<QuantizedReluT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedRelu6: {
      auto ptr = reinterpret_cast<QuantizedRelu6T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedReshape: {
      auto ptr = reinterpret_cast<QuantizedReshapeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedSoftmax: {
      auto ptr = reinterpret_cast<QuantizedSoftmaxT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizeMaxMin: {
      auto ptr = reinterpret_cast<QuantizeMaxMinT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizeV2: {
      auto ptr = reinterpret_cast<QuantizeV2T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Range: {
      auto ptr = reinterpret_cast<RangeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Rank: {
      auto ptr = reinterpret_cast<RankT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ReduceJoin: {
      auto ptr = reinterpret_cast<ReduceJoinT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ReductionParam: {
      auto ptr = reinterpret_cast<ReductionParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<ReluT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<Relu6T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_RequantizationRange: {
      auto ptr = reinterpret_cast<RequantizationRangeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Requantize: {
      auto ptr = reinterpret_cast<RequantizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<ReshapeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Resize: {
      auto ptr = reinterpret_cast<ResizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_RoiParameters: {
      auto ptr = reinterpret_cast<RoiParametersT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Scale: {
      auto ptr = reinterpret_cast<ScaleT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Selu: {
      auto ptr = reinterpret_cast<SeluT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Size: {
      auto ptr = reinterpret_cast<SizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<SliceT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_SliceTf: {
      auto ptr = reinterpret_cast<SliceTfT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_SpaceBatch: {
      auto ptr = reinterpret_cast<SpaceBatchT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_SqueezeParam: {
      auto ptr = reinterpret_cast<SqueezeParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_StridedSliceParam: {
      auto ptr = reinterpret_cast<StridedSliceParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_TensorConvertInfo: {
      auto ptr = reinterpret_cast<TensorConvertInfoT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_TfQuantizedConv2D: {
      auto ptr = reinterpret_cast<TfQuantizedConv2DT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_TopKV2: {
      auto ptr = reinterpret_cast<TopKV2T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Transpose: {
      auto ptr = reinterpret_cast<TransposeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_UnaryOp: {
      auto ptr = reinterpret_cast<UnaryOpT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_MomentsParam: {
      auto ptr = reinterpret_cast<MomentsParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_RNNParam: {
      auto ptr = reinterpret_cast<RNNParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_BatchMatMulParam: {
      auto ptr = reinterpret_cast<BatchMatMulParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedFloatParam: {
      auto ptr = reinterpret_cast<QuantizedFloatParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_DepthSpaceParam: {
      auto ptr = reinterpret_cast<DepthSpaceParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_EltwiseInt8: {
      auto ptr = reinterpret_cast<EltwiseInt8T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ReverseSequenceParam: {
      auto ptr = reinterpret_cast<ReverseSequenceParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<ExtraT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Pool3D: {
      auto ptr = reinterpret_cast<Pool3DT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Convolution3D: {
      auto ptr = reinterpret_cast<Convolution3DT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<ELUT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_DetectionPostProcessParam: {
      auto ptr = reinterpret_cast<DetectionPostProcessParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_OneHotParam: {
      auto ptr = reinterpret_cast<OneHotParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_PadParam: {
      auto ptr = reinterpret_cast<PadParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_WhileParam: {
      auto ptr = reinterpret_cast<WhileParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_IfParam: {
      auto ptr = reinterpret_cast<IfParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_RandomUniform: {
      auto ptr = reinterpret_cast<RandomUniformT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<LayerNormT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_TensorArray: {
      auto ptr = reinterpret_cast<TensorArrayT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LSTMBlockCell: {
      auto ptr = reinterpret_cast<LSTMBlockCellT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_GridSample: {
      auto ptr = reinterpret_cast<GridSampleT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LoopParam: {
      auto ptr = reinterpret_cast<LoopParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ImageProcessParam: {
      auto ptr = reinterpret_cast<ImageProcessParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_CumSum: {
      auto ptr = reinterpret_cast<CumSumT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_GroupNorm: {
      auto ptr = reinterpret_cast<GroupNormT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_FmhaV2Param: {
      auto ptr = reinterpret_cast<FmhaV2ParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_FmhcaParam: {
      auto ptr = reinterpret_cast<FmhcaParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_AttentionParam: {
      auto ptr = reinterpret_cast<AttentionParamT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = OpParameter_NONE;
}

inline const flatbuffers::TypeTable *OpTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    OpTypeTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 299, 300, 301, 302, 303, 304, 512, 513, 514, 515, 516, 517, 518, 600, 601, 603, 604 };
  static const char * const names[] = {
    "AbsVal",
    "QuantizedAdd",
    "ArgMax",
    "AsString",
    "InstanceNorm",
    "BatchToSpaceND",
    "Copy",
    "BinaryOp",
    "Bnll",
    "Cast",
    "Concat",
    "Const",
    "Convolution",
    "ConvolutionDepthwise",
    "Crop",
    "CropAndResize",
    "ImageProcess",
    "Deconvolution",
    "DeconvolutionDepthwise",
    "Dequantize",
    "DetectionOutput",
    "Dropout",
    "Eltwise",
    "ELU",
    "Unique",
    "Exp",
    "ExpandDims",
    "Fill",
    "Flatten",
    "Im2Col",
    "Gather",
    "GatherV2",
    "Im2Seq",
    "InnerProduct",
    "Input",
    "Interp",
    "Log",
    "LRN",
    "LSTM",
    "MatMul",
    "MVN",
    "NonMaxSuppression",
    "NonMaxSuppressionV2",
    "Normalize",
    "Pack",
    "Padding",
    "Permute",
    "Pooling",
    "Power",
    "PReLU",
    "PriorBox",
    "Proposal",
    "QuantizedAvgPool",
    "QuantizedBiasAdd",
    "QuantizedConcat",
    "QuantizedDepthwiseConv2D",
    "QuantizedLogistic",
    "RasterAndInterpolate",
    "QuantizedMaxPool",
    "Texture",
    "RasterDiff",
    "QuantizedReshape",
    "QuantizedSoftmax",
    "QuantizeMaxMin",
    "QuantizeV2",
    "Range",
    "Rank",
    "ReduceJoin",
    "Reduction",
    "ReLU",
    "ReLU6",
    "RequantizationRange",
    "Requantize",
    "Reshape",
    "Resize",
    "RNN",
    "ROIPooling",
    "Scale",
    "Selu",
    "Seq2Out",
    "Shape",
    "Sigmoid",
    "Size",
    "Slice",
    "SliceTf",
    "Softmax",
    "SpaceToBatchND",
    "SpatialProduct",
    "Col2Im",
    "Segment",
    "Squeeze",
    "StridedSlice",
    "StringJoin",
    "StringSplit",
    "StringToNumber",
    "TanH",
    "TfQuantizedConv2D",
    "Threshold",
    "Tile",
    "TopKV2",
    "Transpose",
    "UnaryOp",
    "Unpack",
    "Where",
    "Moments",
    "RNNSequenceGRU",
    "BatchMatMul",
    "Unsqueeze",
    "CosineSimilarity",
    "DepthToSpace",
    "SpaceToDepth",
    "ReverseSequence",
    "Pooling3D",
    "Convolution3D",
    "MatrixBandPart",
    "GatherND",
    "DetectionPostProcess",
    "UnravelIndex",
    "ScatterNd",
    "OneHot",
    "BroadcastTo",
    "Dilation2D",
    "Interp3D",
    "Raster",
    "ConvertTensor",
    "ArgMin",
    "LinSpace",
    "RandomUniform",
    "TensorArray",
    "TensorArraySize",
    "TensorArrayRead",
    "TensorArrayWrite",
    "TensorArrayGather",
    "TensorArrayScatter",
    "TensorArraySplit",
    "TensorArrayConcat",
    "LSTMBlockCell",
    "Reverse",
    "ROIAlign",
    "RandomNormal",
    "TensorArrayInsert",
    "TensorArrayErase",
    "EyeLike",
    "CumSum",
    "Det",
    "CumProd",
    "ScatterElements",
    "GatherElements",
    "Svd",
    "Histogram",
    "DynamicQuant",
    "Plugin",
    "Select",
    "ZerosLike",
    "Broastcast",
    "SetDiff1D",
    "ReluGrad",
    "Identity",
    "PoolGrad",
    "SoftmaxGrad",
    "Conv2DBackPropFilter",
    "TrainableParam",
    "BatchNorm",
    "ConvTranspose3D",
    "ZeroGrad",
    "Attention",
    "FmhaV2",
    "Fmhca",
    "SeqLen2Spatial",
    "SplitGeLU",
    "GroupNorm",
    "Extra",
    "ConvInt8",
    "Int8ToFloat",
    "DepthwiseConvInt8",
    "PoolInt8",
    "FloatToInt8",
    "EltwiseInt8",
    "While",
    "If",
    "LayerNorm",
    "GridSample"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 182, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpParameterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 },
    { flatbuffers::ET_SEQUENCE, 0, 29 },
    { flatbuffers::ET_SEQUENCE, 0, 30 },
    { flatbuffers::ET_SEQUENCE, 0, 31 },
    { flatbuffers::ET_SEQUENCE, 0, 32 },
    { flatbuffers::ET_SEQUENCE, 0, 33 },
    { flatbuffers::ET_SEQUENCE, 0, 34 },
    { flatbuffers::ET_SEQUENCE, 0, 35 },
    { flatbuffers::ET_SEQUENCE, 0, 36 },
    { flatbuffers::ET_SEQUENCE, 0, 37 },
    { flatbuffers::ET_SEQUENCE, 0, 38 },
    { flatbuffers::ET_SEQUENCE, 0, 39 },
    { flatbuffers::ET_SEQUENCE, 0, 40 },
    { flatbuffers::ET_SEQUENCE, 0, 41 },
    { flatbuffers::ET_SEQUENCE, 0, 42 },
    { flatbuffers::ET_SEQUENCE, 0, 43 },
    { flatbuffers::ET_SEQUENCE, 0, 44 },
    { flatbuffers::ET_SEQUENCE, 0, 45 },
    { flatbuffers::ET_SEQUENCE, 0, 46 },
    { flatbuffers::ET_SEQUENCE, 0, 47 },
    { flatbuffers::ET_SEQUENCE, 0, 48 },
    { flatbuffers::ET_SEQUENCE, 0, 49 },
    { flatbuffers::ET_SEQUENCE, 0, 50 },
    { flatbuffers::ET_SEQUENCE, 0, 51 },
    { flatbuffers::ET_SEQUENCE, 0, 52 },
    { flatbuffers::ET_SEQUENCE, 0, 53 },
    { flatbuffers::ET_SEQUENCE, 0, 54 },
    { flatbuffers::ET_SEQUENCE, 0, 55 },
    { flatbuffers::ET_SEQUENCE, 0, 56 },
    { flatbuffers::ET_SEQUENCE, 0, 57 },
    { flatbuffers::ET_SEQUENCE, 0, 58 },
    { flatbuffers::ET_SEQUENCE, 0, 59 },
    { flatbuffers::ET_SEQUENCE, 0, 60 },
    { flatbuffers::ET_SEQUENCE, 0, 61 },
    { flatbuffers::ET_SEQUENCE, 0, 62 },
    { flatbuffers::ET_SEQUENCE, 0, 63 },
    { flatbuffers::ET_SEQUENCE, 0, 64 },
    { flatbuffers::ET_SEQUENCE, 0, 65 },
    { flatbuffers::ET_SEQUENCE, 0, 66 },
    { flatbuffers::ET_SEQUENCE, 0, 67 },
    { flatbuffers::ET_SEQUENCE, 0, 68 },
    { flatbuffers::ET_SEQUENCE, 0, 69 },
    { flatbuffers::ET_SEQUENCE, 0, 70 },
    { flatbuffers::ET_SEQUENCE, 0, 71 },
    { flatbuffers::ET_SEQUENCE, 0, 72 },
    { flatbuffers::ET_SEQUENCE, 0, 73 },
    { flatbuffers::ET_SEQUENCE, 0, 74 },
    { flatbuffers::ET_SEQUENCE, 0, 75 },
    { flatbuffers::ET_SEQUENCE, 0, 76 },
    { flatbuffers::ET_SEQUENCE, 0, 77 },
    { flatbuffers::ET_SEQUENCE, 0, 78 },
    { flatbuffers::ET_SEQUENCE, 0, 79 },
    { flatbuffers::ET_SEQUENCE, 0, 80 },
    { flatbuffers::ET_SEQUENCE, 0, 81 },
    { flatbuffers::ET_SEQUENCE, 0, 82 },
    { flatbuffers::ET_SEQUENCE, 0, 83 },
    { flatbuffers::ET_SEQUENCE, 0, 84 },
    { flatbuffers::ET_SEQUENCE, 0, 85 },
    { flatbuffers::ET_SEQUENCE, 0, 86 },
    { flatbuffers::ET_SEQUENCE, 0, 87 },
    { flatbuffers::ET_SEQUENCE, 0, 88 },
    { flatbuffers::ET_SEQUENCE, 0, 89 },
    { flatbuffers::ET_SEQUENCE, 0, 90 },
    { flatbuffers::ET_SEQUENCE, 0, 91 },
    { flatbuffers::ET_SEQUENCE, 0, 92 },
    { flatbuffers::ET_SEQUENCE, 0, 93 },
    { flatbuffers::ET_SEQUENCE, 0, 94 },
    { flatbuffers::ET_SEQUENCE, 0, 95 },
    { flatbuffers::ET_SEQUENCE, 0, 96 },
    { flatbuffers::ET_SEQUENCE, 0, 97 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    QuantizedAddTypeTable,
    ArgMaxTypeTable,
    AsStringTypeTable,
    AxisTypeTable,
    BatchNormTypeTable,
    BinaryOpTypeTable,
    BlobTypeTable,
    CastParamTypeTable,
    Convolution2DTypeTable,
    CropTypeTable,
    CropAndResizeTypeTable,
    DequantizeTypeTable,
    DetectionOutputTypeTable,
    EltwiseTypeTable,
    ExpandDimsTypeTable,
    FillTypeTable,
    FlattenTypeTable,
    GatherTypeTable,
    GatherV2TypeTable,
    InnerProductTypeTable,
    InputTypeTable,
    InterpTypeTable,
    LRNTypeTable,
    LSTMTypeTable,
    MatMulTypeTable,
    NonMaxSuppressionV2TypeTable,
    NormalizeTypeTable,
    PackParamTypeTable,
    PermuteTypeTable,
    PluginTypeTable,
    PoolTypeTable,
    PReluTypeTable,
    PriorBoxTypeTable,
    ProposalTypeTable,
    QuantizedAvgPoolTypeTable,
    QuantizedBiasAddTypeTable,
    QuantizedConcatTypeTable,
    QuantizedLogisticTypeTable,
    QuantizedMatMulTypeTable,
    QuantizedMaxPoolTypeTable,
    QuantizedReluTypeTable,
    QuantizedRelu6TypeTable,
    QuantizedReshapeTypeTable,
    QuantizedSoftmaxTypeTable,
    QuantizeMaxMinTypeTable,
    QuantizeV2TypeTable,
    RangeTypeTable,
    RankTypeTable,
    ReduceJoinTypeTable,
    ReductionParamTypeTable,
    ReluTypeTable,
    Relu6TypeTable,
    RequantizationRangeTypeTable,
    RequantizeTypeTable,
    ReshapeTypeTable,
    ResizeTypeTable,
    RoiParametersTypeTable,
    ScaleTypeTable,
    SeluTypeTable,
    SizeTypeTable,
    SliceTypeTable,
    SliceTfTypeTable,
    SpaceBatchTypeTable,
    SqueezeParamTypeTable,
    StridedSliceParamTypeTable,
    TensorConvertInfoTypeTable,
    TfQuantizedConv2DTypeTable,
    TopKV2TypeTable,
    TransposeTypeTable,
    UnaryOpTypeTable,
    MomentsParamTypeTable,
    RNNParamTypeTable,
    BatchMatMulParamTypeTable,
    QuantizedFloatParamTypeTable,
    DepthSpaceParamTypeTable,
    EltwiseInt8TypeTable,
    ReverseSequenceParamTypeTable,
    ExtraTypeTable,
    Pool3DTypeTable,
    Convolution3DTypeTable,
    ELUTypeTable,
    DetectionPostProcessParamTypeTable,
    OneHotParamTypeTable,
    PadParamTypeTable,
    WhileParamTypeTable,
    IfParamTypeTable,
    RandomUniformTypeTable,
    LayerNormTypeTable,
    TensorArrayTypeTable,
    LSTMBlockCellTypeTable,
    GridSampleTypeTable,
    LoopParamTypeTable,
    ImageProcessParamTypeTable,
    CumSumTypeTable,
    GroupNormTypeTable,
    FmhaV2ParamTypeTable,
    FmhcaParamTypeTable,
    AttentionParamTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "QuantizedAdd",
    "ArgMax",
    "AsString",
    "Axis",
    "BatchNorm",
    "BinaryOp",
    "Blob",
    "CastParam",
    "Convolution2D",
    "Crop",
    "CropAndResize",
    "Dequantize",
    "DetectionOutput",
    "Eltwise",
    "ExpandDims",
    "Fill",
    "Flatten",
    "Gather",
    "GatherV2",
    "InnerProduct",
    "Input",
    "Interp",
    "LRN",
    "LSTM",
    "MatMul",
    "NonMaxSuppressionV2",
    "Normalize",
    "PackParam",
    "Permute",
    "Plugin",
    "Pool",
    "PRelu",
    "PriorBox",
    "Proposal",
    "QuantizedAvgPool",
    "QuantizedBiasAdd",
    "QuantizedConcat",
    "QuantizedLogistic",
    "QuantizedMatMul",
    "QuantizedMaxPool",
    "QuantizedRelu",
    "QuantizedRelu6",
    "QuantizedReshape",
    "QuantizedSoftmax",
    "QuantizeMaxMin",
    "QuantizeV2",
    "Range",
    "Rank",
    "ReduceJoin",
    "ReductionParam",
    "Relu",
    "Relu6",
    "RequantizationRange",
    "Requantize",
    "Reshape",
    "Resize",
    "RoiParameters",
    "Scale",
    "Selu",
    "Size",
    "Slice",
    "SliceTf",
    "SpaceBatch",
    "SqueezeParam",
    "StridedSliceParam",
    "TensorConvertInfo",
    "TfQuantizedConv2D",
    "TopKV2",
    "Transpose",
    "UnaryOp",
    "MomentsParam",
    "RNNParam",
    "BatchMatMulParam",
    "QuantizedFloatParam",
    "DepthSpaceParam",
    "EltwiseInt8",
    "ReverseSequenceParam",
    "Extra",
    "Pool3D",
    "Convolution3D",
    "ELU",
    "DetectionPostProcessParam",
    "OneHotParam",
    "PadParam",
    "WhileParam",
    "IfParam",
    "RandomUniform",
    "LayerNorm",
    "TensorArray",
    "LSTMBlockCell",
    "GridSample",
    "LoopParam",
    "ImageProcessParam",
    "CumSum",
    "GroupNorm",
    "FmhaV2Param",
    "FmhcaParam",
    "AttentionParam"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 99, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ForwardTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ForwardTypeTypeTable
  };
  static const char * const names[] = {
    "CPU",
    "METAL",
    "OPENCL",
    "OPENGLES",
    "VULKAN"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UsageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    UsageTypeTable
  };
  static const char * const names[] = {
    "INFERENCE",
    "TRAIN",
    "INFERENCE_STATIC"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PluginTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AttributeTypeTable
  };
  static const char * const names[] = {
    "type",
    "attr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExtraTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AttributeTypeTable
  };
  static const char * const names[] = {
    "type",
    "engine",
    "info",
    "attr",
    "vector"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StringVecTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AttentionParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "kv_cache"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FmhaV2ParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "heads"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FmhcaParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "heads"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WhileParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StringVecTypeTable
  };
  static const char * const names[] = {
    "cond_graph",
    "body_graph",
    "aliases_inputs",
    "aliases_outputs",
    "aliases_updates"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IfParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StringVecTypeTable
  };
  static const char * const names[] = {
    "then_graph",
    "else_graph",
    "aliases_inputs",
    "aliases_outputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RegionCommandTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    OpTypeTable,
    ViewTypeTable
  };
  static const char * const names[] = {
    "op",
    "steps",
    "size",
    "indexes",
    "view",
    "fuse",
    "iterIndexes"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LoopParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorDescribeTypeTable,
    RegionCommandTypeTable
  };
  static const char * const names[] = {
    "tensorNumber",
    "outputIndexes",
    "inputIndexes",
    "extraTensorInfos",
    "parallel",
    "loopNumber",
    "commands",
    "initCommand"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, 1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    OpParameterTypeTable,
    OpTypeTypeTable,
    MNN_DATA_FORMATTypeTable
  };
  static const char * const names[] = {
    "inputIndexes",
    "main_type",
    "main",
    "name",
    "outputIndexes",
    "type",
    "defaultDimentionFormat",
    "externalPath"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ViewTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "offset",
    "stride"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RegionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ViewTypeTable
  };
  static const char * const names[] = {
    "src",
    "dst",
    "size",
    "origin"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorDescribeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlobTypeTable,
    RegionTypeTable,
    TensorQuantInfoTypeTable
  };
  static const char * const names[] = {
    "blob",
    "index",
    "name",
    "regions",
    "quantInfo"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubGraphProtoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    OpTypeTable,
    TensorDescribeTypeTable
  };
  static const char * const names[] = {
    "name",
    "inputs",
    "outputs",
    "tensors",
    "nodes",
    "extraTensorDescribe"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorQuantInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "scale",
    "zero",
    "min",
    "max",
    "type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NetTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 3 },
    { flatbuffers::ET_CHAR, 0, 4 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 1, 6 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorDescribeTypeTable,
    ExtraInfoTypeTable,
    OpTypeTable,
    ForwardTypeTypeTable,
    NetSourceTypeTable,
    UsageTypeTable,
    SubGraphProtoTypeTable
  };
  static const char * const names[] = {
    "bizCode",
    "extraTensorDescribe",
    "extraInfo",
    "oplists",
    "outputName",
    "preferForwardType",
    "sourceType",
    "tensorName",
    "tensorNumber",
    "usage",
    "subgraphs",
    "mnn_uuid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 12, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const MNN::Net *GetNet(const void *buf) {
  return flatbuffers::GetRoot<MNN::Net>(buf);
}

inline const MNN::Net *GetSizePrefixedNet(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MNN::Net>(buf);
}

inline bool VerifyNetBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MNN::Net>(nullptr);
}

inline bool VerifySizePrefixedNetBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MNN::Net>(nullptr);
}

inline void FinishNetBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MNN::Net> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNetBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MNN::Net> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<NetT> UnPackNet(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NetT>(GetNet(buf)->UnPack(res));
}

}  // namespace MNN

#endif  // FLATBUFFERS_GENERATED_MNN_MNN_H_
