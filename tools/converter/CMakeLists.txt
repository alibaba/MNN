IF(MNN_BUILD_CONVERTER)
  set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS_ORIGIN})
  set(CMAKE_C_FLAGS ${CMAKE_C_FLAGS_ORIGIN})
  SET( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/../../)
  option(TF_CONVERT_ORIGIN "Fall Back to Origin Model Converter" OFF)
  option(TFMODEL_OPTIMIZE "Enable tensorflow model optimizer" OFF)
  IF(MNN_PORTABLE_BUILD)
    SET(Protobuf_USE_STATIC_LIBS ON)
  ENDIF()
  IF(MSVC OR WIN32)
    set(Protobuf_SRC_ROOT_FOLDER $ENV{Protobuf_SRC_ROOT_FOLDER})
  endif()
  find_package(Protobuf REQUIRED)
  if (${CMAKE_VERSION} VERSION_LESS "3.6.0")
      set(Protobuf_LIBRARIES ${PROTOBUF_LIBRARIES})
      set(Protobuf_INCLUDE_DIRS ${PROTOBUF_INCLUDE_DIRS})
  endif()
  include_directories(${CMAKE_CURRENT_LIST_DIR}/include/)
  include_directories(${CMAKE_CURRENT_LIST_DIR}/source/tflite/schema/)
  include_directories(${Protobuf_INCLUDE_DIRS})
  SET(MNN_CONVERTER_BACKENDS_TARGETS "")
  SET(MNN_CONVERTER_BACKENDS_OBJECTS "")
  include_directories(${CMAKE_CURRENT_LIST_DIR}/include)
  include_directories(${CMAKE_CURRENT_LIST_DIR}/source/tflite/schema)
  include_directories(${CMAKE_CURRENT_BINARY_DIR})
  include(${CMAKE_CURRENT_LIST_DIR}/source/tensorflow/CMakeLists.txt)
  include(${CMAKE_CURRENT_LIST_DIR}/source/onnx/CMakeLists.txt)
  include(${CMAKE_CURRENT_LIST_DIR}/source/caffe/CMakeLists.txt)
  include(${CMAKE_CURRENT_LIST_DIR}/source/MNN/CMakeLists.txt)
  include(${CMAKE_CURRENT_LIST_DIR}/source/optimizer/CMakeLists.txt)
  include(${CMAKE_CURRENT_LIST_DIR}/source/tflite/CMakeLists.txt)

  file(GLOB COMMON_SRC ${CMAKE_CURRENT_LIST_DIR}/source/common/*.cpp)
  add_executable(MNNDump2Json ${CMAKE_CURRENT_LIST_DIR}/source/MNNDump2Json.cpp)
  add_executable(MNNConvert
    ${CMAKE_CURRENT_LIST_DIR}/source/MNNConverter.cpp
    ${CMAKE_CURRENT_LIST_DIR}/source/cli.cpp
    ${CMAKE_CURRENT_LIST_DIR}/source/config.cpp
  )
  IF(MNN_BUILD_SHARED_LIBS)
    add_library(MNNConvertDeps SHARED ${COMMON_SRC} ${MNN_CONVERTER_BACKENDS_OBJECTS} ${CMAKE_CURRENT_LIST_DIR}/../../3rd_party/flatbuffers/src/util.cpp)
    add_dependencies(MNNConvertDeps MNN)
  ELSE()
      add_library(MNNConvertDeps STATIC ${COMMON_SRC} ${MNN_CONVERTER_BACKENDS_OBJECTS} ${CMAKE_CURRENT_LIST_DIR}/../../3rd_party/flatbuffers/src/util.cpp)
  ENDIF()
  
  
  IF(NOT MNN_BUILD_SHARED_LIBS)
    target_link_libraries(MNNConvertDeps PUBLIC ${Protobuf_LIBRARIES})
    if(APPLE)
# Mac default zlib only have .dylib, but we need .a
# So you should run `brew install zlib` (include .a)
# Due to cmake find_package(zlib) try to detect .dylib even if set ZLIB_ROOT explicitly, so we need pkg-config
# We need `export PKG_CONFIG_PATH=/usr/local/Cellar/zlib/{version}/lib/pkgconfig:$PKG_CONFIG_PATH`
# Now we can omit zlib.a dependency by `pkg-config --libs zlib`
        find_package(PkgConfig REQUIRED)
        pkg_check_modules(ZLIB REQUIRED IMPORTED_TARGET zlib)
        target_link_libraries(MNNConvert -Wl,-all_load MNNConvertDeps ${MNN_DEPS} ${ZLIB_LDFLAGS} -Wl,-noall_load)
    elseif (CMAKE_CXX_COMPILER_ID MATCHES "GNU" OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
        # See also /path/to/MNN/CMakeLists.txt:481 when you are confused with -lpthread here.
        target_link_libraries(MNNConvert -Wl,--whole-archive MNNConvertDeps ${MNN_DEPS} -lpthread -Wl,--no-whole-archive)
    elseif (MSVC OR WIN32)
        target_link_libraries(MNNConvert MNNConvertDeps)
        target_link_options(MNNConvert PRIVATE /WHOLEARCHIVE:$<TARGET_FILE:MNNConvertDeps>)
        foreach (DEPEND ${MNN_DEPS})
            target_link_libraries(MNNConvert ${DEPEND})
            target_link_options(MNNConvert PRIVATE /WHOLEARCHIVE:$<TARGET_FILE:${DEPEND}>)
        endforeach ()
    ELSE()
        target_link_libraries(MNNConvert MNNConvertDeps)
    endif()
  ELSE()
    target_link_libraries(MNNConvertDeps PUBLIC ${MNN_DEPS} ${Protobuf_LIBRARIES})
    add_executable(TestConvertResult ${CMAKE_CURRENT_LIST_DIR}/source/TestConvertResult.cpp)
    target_link_libraries(TestConvertResult MNNConvertDeps)
    target_link_libraries(MNNConvert MNNConvertDeps)
  ENDIF()
ENDIF()
