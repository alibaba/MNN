// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
#define FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_

#include "flatbuffers/flatbuffers.h"

namespace tflite {

struct CustomQuantization;
struct CustomQuantizationT;

struct BlockwiseQuantization;
struct BlockwiseQuantizationT;

struct QuantizationParameters;
struct QuantizationParametersT;

struct Int32Vector;
struct Int32VectorT;

struct Uint16Vector;
struct Uint16VectorT;

struct Uint8Vector;
struct Uint8VectorT;

struct DimensionMetadata;
struct DimensionMetadataT;

struct SparsityParameters;
struct SparsityParametersT;

struct VariantSubType;
struct VariantSubTypeT;

struct Tensor;
struct TensorT;

struct StablehloGatherOptions;
struct StablehloGatherOptionsT;

struct StablehloTransposeOptions;
struct StablehloTransposeOptionsT;

struct StablehloDotGeneralOptions;
struct StablehloDotGeneralOptionsT;

struct StablehloReduceWindowOptions;
struct StablehloReduceWindowOptionsT;

struct StablehloWhileOptions;
struct StablehloWhileOptionsT;

struct StablehloSortOptions;
struct StablehloSortOptionsT;

struct StablehloConcatenateOptions;
struct StablehloConcatenateOptionsT;

struct StablehloBroadcastInDimOptions;
struct StablehloBroadcastInDimOptionsT;

struct StablehloCompareOptions;
struct StablehloCompareOptionsT;

struct StablehloDynamicSliceOptions;
struct StablehloDynamicSliceOptionsT;

struct StablehloPadOptions;
struct StablehloPadOptionsT;

struct StablehloIotaOptions;
struct StablehloIotaOptionsT;

struct StablehloCustomCallOptions;
struct StablehloCustomCallOptionsT;

struct StablehloReduceOptions;
struct StablehloReduceOptionsT;

struct StablehloSliceOptions;
struct StablehloSliceOptionsT;

struct StablehloConvolutionOptions;
struct StablehloConvolutionOptionsT;

struct StablehloScatterOptions;
struct StablehloScatterOptionsT;

struct StablehloCaseOptions;
struct StablehloCaseOptionsT;

struct StablehloRngBitGeneratorOptions;
struct StablehloRngBitGeneratorOptionsT;

struct Conv2DOptions;
struct Conv2DOptionsT;

struct Conv3DOptions;
struct Conv3DOptionsT;

struct Pool2DOptions;
struct Pool2DOptionsT;

struct DepthwiseConv2DOptions;
struct DepthwiseConv2DOptionsT;

struct ConcatEmbeddingsOptions;
struct ConcatEmbeddingsOptionsT;

struct LSHProjectionOptions;
struct LSHProjectionOptionsT;

struct SVDFOptions;
struct SVDFOptionsT;

struct RNNOptions;
struct RNNOptionsT;

struct SequenceRNNOptions;
struct SequenceRNNOptionsT;

struct BidirectionalSequenceRNNOptions;
struct BidirectionalSequenceRNNOptionsT;

struct FullyConnectedOptions;
struct FullyConnectedOptionsT;

struct SoftmaxOptions;
struct SoftmaxOptionsT;

struct ConcatenationOptions;
struct ConcatenationOptionsT;

struct AddOptions;
struct AddOptionsT;

struct MulOptions;
struct MulOptionsT;

struct L2NormOptions;
struct L2NormOptionsT;

struct LocalResponseNormalizationOptions;
struct LocalResponseNormalizationOptionsT;

struct LSTMOptions;
struct LSTMOptionsT;

struct UnidirectionalSequenceLSTMOptions;
struct UnidirectionalSequenceLSTMOptionsT;

struct BidirectionalSequenceLSTMOptions;
struct BidirectionalSequenceLSTMOptionsT;

struct ResizeBilinearOptions;
struct ResizeBilinearOptionsT;

struct ResizeNearestNeighborOptions;
struct ResizeNearestNeighborOptionsT;

struct CallOptions;
struct CallOptionsT;

struct PadOptions;
struct PadOptionsT;

struct PadV2Options;
struct PadV2OptionsT;

struct ReshapeOptions;
struct ReshapeOptionsT;

struct SpaceToBatchNDOptions;
struct SpaceToBatchNDOptionsT;

struct BatchToSpaceNDOptions;
struct BatchToSpaceNDOptionsT;

struct SkipGramOptions;
struct SkipGramOptionsT;

struct SpaceToDepthOptions;
struct SpaceToDepthOptionsT;

struct DepthToSpaceOptions;
struct DepthToSpaceOptionsT;

struct SubOptions;
struct SubOptionsT;

struct DivOptions;
struct DivOptionsT;

struct TopKV2Options;
struct TopKV2OptionsT;

struct EmbeddingLookupSparseOptions;
struct EmbeddingLookupSparseOptionsT;

struct GatherOptions;
struct GatherOptionsT;

struct TransposeOptions;
struct TransposeOptionsT;

struct ExpOptions;
struct ExpOptionsT;

struct CosOptions;
struct CosOptionsT;

struct ReducerOptions;
struct ReducerOptionsT;

struct SqueezeOptions;
struct SqueezeOptionsT;

struct SplitOptions;
struct SplitOptionsT;

struct SplitVOptions;
struct SplitVOptionsT;

struct StridedSliceOptions;
struct StridedSliceOptionsT;

struct LogSoftmaxOptions;
struct LogSoftmaxOptionsT;

struct CastOptions;
struct CastOptionsT;

struct DequantizeOptions;
struct DequantizeOptionsT;

struct MaximumMinimumOptions;
struct MaximumMinimumOptionsT;

struct TileOptions;
struct TileOptionsT;

struct ArgMaxOptions;
struct ArgMaxOptionsT;

struct ArgMinOptions;
struct ArgMinOptionsT;

struct GreaterOptions;
struct GreaterOptionsT;

struct GreaterEqualOptions;
struct GreaterEqualOptionsT;

struct LessOptions;
struct LessOptionsT;

struct LessEqualOptions;
struct LessEqualOptionsT;

struct NegOptions;
struct NegOptionsT;

struct SelectOptions;
struct SelectOptionsT;

struct SliceOptions;
struct SliceOptionsT;

struct TransposeConvOptions;
struct TransposeConvOptionsT;

struct ExpandDimsOptions;
struct ExpandDimsOptionsT;

struct SparseToDenseOptions;
struct SparseToDenseOptionsT;

struct EqualOptions;
struct EqualOptionsT;

struct NotEqualOptions;
struct NotEqualOptionsT;

struct ShapeOptions;
struct ShapeOptionsT;

struct RankOptions;
struct RankOptionsT;

struct PowOptions;
struct PowOptionsT;

struct FakeQuantOptions;
struct FakeQuantOptionsT;

struct PackOptions;
struct PackOptionsT;

struct LogicalOrOptions;
struct LogicalOrOptionsT;

struct OneHotOptions;
struct OneHotOptionsT;

struct AbsOptions;
struct AbsOptionsT;

struct HardSwishOptions;
struct HardSwishOptionsT;

struct LogicalAndOptions;
struct LogicalAndOptionsT;

struct LogicalNotOptions;
struct LogicalNotOptionsT;

struct UnpackOptions;
struct UnpackOptionsT;

struct FloorDivOptions;
struct FloorDivOptionsT;

struct SquareOptions;
struct SquareOptionsT;

struct ZerosLikeOptions;
struct ZerosLikeOptionsT;

struct FillOptions;
struct FillOptionsT;

struct FloorModOptions;
struct FloorModOptionsT;

struct RangeOptions;
struct RangeOptionsT;

struct LeakyReluOptions;
struct LeakyReluOptionsT;

struct SquaredDifferenceOptions;
struct SquaredDifferenceOptionsT;

struct MirrorPadOptions;
struct MirrorPadOptionsT;

struct UniqueOptions;
struct UniqueOptionsT;

struct ReverseV2Options;
struct ReverseV2OptionsT;

struct AddNOptions;
struct AddNOptionsT;

struct GatherNdOptions;
struct GatherNdOptionsT;

struct WhereOptions;
struct WhereOptionsT;

struct ReverseSequenceOptions;
struct ReverseSequenceOptionsT;

struct MatrixDiagOptions;
struct MatrixDiagOptionsT;

struct QuantizeOptions;
struct QuantizeOptionsT;

struct MatrixSetDiagOptions;
struct MatrixSetDiagOptionsT;

struct IfOptions;
struct IfOptionsT;

struct CallOnceOptions;
struct CallOnceOptionsT;

struct WhileOptions;
struct WhileOptionsT;

struct NonMaxSuppressionV4Options;
struct NonMaxSuppressionV4OptionsT;

struct NonMaxSuppressionV5Options;
struct NonMaxSuppressionV5OptionsT;

struct ScatterNdOptions;
struct ScatterNdOptionsT;

struct SelectV2Options;
struct SelectV2OptionsT;

struct DensifyOptions;
struct DensifyOptionsT;

struct SegmentSumOptions;
struct SegmentSumOptionsT;

struct BatchMatMulOptions;
struct BatchMatMulOptionsT;

struct CumsumOptions;
struct CumsumOptionsT;

struct BroadcastToOptions;
struct BroadcastToOptionsT;

struct Rfft2dOptions;
struct Rfft2dOptionsT;

struct HashtableOptions;
struct HashtableOptionsT;

struct HashtableFindOptions;
struct HashtableFindOptionsT;

struct HashtableImportOptions;
struct HashtableImportOptionsT;

struct HashtableSizeOptions;
struct HashtableSizeOptionsT;

struct VarHandleOptions;
struct VarHandleOptionsT;

struct ReadVariableOptions;
struct ReadVariableOptionsT;

struct AssignVariableOptions;
struct AssignVariableOptionsT;

struct RandomOptions;
struct RandomOptionsT;

struct BucketizeOptions;
struct BucketizeOptionsT;

struct GeluOptions;
struct GeluOptionsT;

struct DynamicUpdateSliceOptions;
struct DynamicUpdateSliceOptionsT;

struct UnsortedSegmentProdOptions;
struct UnsortedSegmentProdOptionsT;

struct UnsortedSegmentMaxOptions;
struct UnsortedSegmentMaxOptionsT;

struct UnsortedSegmentSumOptions;
struct UnsortedSegmentSumOptionsT;

struct ATan2Options;
struct ATan2OptionsT;

struct UnsortedSegmentMinOptions;
struct UnsortedSegmentMinOptionsT;

struct SignOptions;
struct SignOptionsT;

struct BitcastOptions;
struct BitcastOptionsT;

struct BitwiseXorOptions;
struct BitwiseXorOptionsT;

struct RightShiftOptions;
struct RightShiftOptionsT;

struct DilateOptions;
struct DilateOptionsT;

struct ReduceWindowOptions;
struct ReduceWindowOptionsT;

struct OperatorCode;
struct OperatorCodeT;

struct StableHLOCompositeOptions;
struct StableHLOCompositeOptionsT;

struct StablehloShiftLeftOptions;
struct StablehloShiftLeftOptionsT;

struct Operator;
struct OperatorT;

struct SubGraph;
struct SubGraphT;

struct Buffer;
struct BufferT;

struct Metadata;
struct MetadataT;

struct TensorMap;
struct TensorMapT;

struct SignatureDef;
struct SignatureDefT;

struct Model;
struct ModelT;

inline const flatbuffers::TypeTable *CustomQuantizationTypeTable();

inline const flatbuffers::TypeTable *BlockwiseQuantizationTypeTable();

inline const flatbuffers::TypeTable *QuantizationParametersTypeTable();

inline const flatbuffers::TypeTable *Int32VectorTypeTable();

inline const flatbuffers::TypeTable *Uint16VectorTypeTable();

inline const flatbuffers::TypeTable *Uint8VectorTypeTable();

inline const flatbuffers::TypeTable *DimensionMetadataTypeTable();

inline const flatbuffers::TypeTable *SparsityParametersTypeTable();

inline const flatbuffers::TypeTable *VariantSubTypeTypeTable();

inline const flatbuffers::TypeTable *TensorTypeTable();

inline const flatbuffers::TypeTable *StablehloGatherOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloTransposeOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloDotGeneralOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloReduceWindowOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloWhileOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloSortOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloConcatenateOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloBroadcastInDimOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloCompareOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloDynamicSliceOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloPadOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloIotaOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloCustomCallOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloReduceOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloSliceOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloConvolutionOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloScatterOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloCaseOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloRngBitGeneratorOptionsTypeTable();

inline const flatbuffers::TypeTable *Conv2DOptionsTypeTable();

inline const flatbuffers::TypeTable *Conv3DOptionsTypeTable();

inline const flatbuffers::TypeTable *Pool2DOptionsTypeTable();

inline const flatbuffers::TypeTable *DepthwiseConv2DOptionsTypeTable();

inline const flatbuffers::TypeTable *ConcatEmbeddingsOptionsTypeTable();

inline const flatbuffers::TypeTable *LSHProjectionOptionsTypeTable();

inline const flatbuffers::TypeTable *SVDFOptionsTypeTable();

inline const flatbuffers::TypeTable *RNNOptionsTypeTable();

inline const flatbuffers::TypeTable *SequenceRNNOptionsTypeTable();

inline const flatbuffers::TypeTable *BidirectionalSequenceRNNOptionsTypeTable();

inline const flatbuffers::TypeTable *FullyConnectedOptionsTypeTable();

inline const flatbuffers::TypeTable *SoftmaxOptionsTypeTable();

inline const flatbuffers::TypeTable *ConcatenationOptionsTypeTable();

inline const flatbuffers::TypeTable *AddOptionsTypeTable();

inline const flatbuffers::TypeTable *MulOptionsTypeTable();

inline const flatbuffers::TypeTable *L2NormOptionsTypeTable();

inline const flatbuffers::TypeTable *LocalResponseNormalizationOptionsTypeTable();

inline const flatbuffers::TypeTable *LSTMOptionsTypeTable();

inline const flatbuffers::TypeTable *UnidirectionalSequenceLSTMOptionsTypeTable();

inline const flatbuffers::TypeTable *BidirectionalSequenceLSTMOptionsTypeTable();

inline const flatbuffers::TypeTable *ResizeBilinearOptionsTypeTable();

inline const flatbuffers::TypeTable *ResizeNearestNeighborOptionsTypeTable();

inline const flatbuffers::TypeTable *CallOptionsTypeTable();

inline const flatbuffers::TypeTable *PadOptionsTypeTable();

inline const flatbuffers::TypeTable *PadV2OptionsTypeTable();

inline const flatbuffers::TypeTable *ReshapeOptionsTypeTable();

inline const flatbuffers::TypeTable *SpaceToBatchNDOptionsTypeTable();

inline const flatbuffers::TypeTable *BatchToSpaceNDOptionsTypeTable();

inline const flatbuffers::TypeTable *SkipGramOptionsTypeTable();

inline const flatbuffers::TypeTable *SpaceToDepthOptionsTypeTable();

inline const flatbuffers::TypeTable *DepthToSpaceOptionsTypeTable();

inline const flatbuffers::TypeTable *SubOptionsTypeTable();

inline const flatbuffers::TypeTable *DivOptionsTypeTable();

inline const flatbuffers::TypeTable *TopKV2OptionsTypeTable();

inline const flatbuffers::TypeTable *EmbeddingLookupSparseOptionsTypeTable();

inline const flatbuffers::TypeTable *GatherOptionsTypeTable();

inline const flatbuffers::TypeTable *TransposeOptionsTypeTable();

inline const flatbuffers::TypeTable *ExpOptionsTypeTable();

inline const flatbuffers::TypeTable *CosOptionsTypeTable();

inline const flatbuffers::TypeTable *ReducerOptionsTypeTable();

inline const flatbuffers::TypeTable *SqueezeOptionsTypeTable();

inline const flatbuffers::TypeTable *SplitOptionsTypeTable();

inline const flatbuffers::TypeTable *SplitVOptionsTypeTable();

inline const flatbuffers::TypeTable *StridedSliceOptionsTypeTable();

inline const flatbuffers::TypeTable *LogSoftmaxOptionsTypeTable();

inline const flatbuffers::TypeTable *CastOptionsTypeTable();

inline const flatbuffers::TypeTable *DequantizeOptionsTypeTable();

inline const flatbuffers::TypeTable *MaximumMinimumOptionsTypeTable();

inline const flatbuffers::TypeTable *TileOptionsTypeTable();

inline const flatbuffers::TypeTable *ArgMaxOptionsTypeTable();

inline const flatbuffers::TypeTable *ArgMinOptionsTypeTable();

inline const flatbuffers::TypeTable *GreaterOptionsTypeTable();

inline const flatbuffers::TypeTable *GreaterEqualOptionsTypeTable();

inline const flatbuffers::TypeTable *LessOptionsTypeTable();

inline const flatbuffers::TypeTable *LessEqualOptionsTypeTable();

inline const flatbuffers::TypeTable *NegOptionsTypeTable();

inline const flatbuffers::TypeTable *SelectOptionsTypeTable();

inline const flatbuffers::TypeTable *SliceOptionsTypeTable();

inline const flatbuffers::TypeTable *TransposeConvOptionsTypeTable();

inline const flatbuffers::TypeTable *ExpandDimsOptionsTypeTable();

inline const flatbuffers::TypeTable *SparseToDenseOptionsTypeTable();

inline const flatbuffers::TypeTable *EqualOptionsTypeTable();

inline const flatbuffers::TypeTable *NotEqualOptionsTypeTable();

inline const flatbuffers::TypeTable *ShapeOptionsTypeTable();

inline const flatbuffers::TypeTable *RankOptionsTypeTable();

inline const flatbuffers::TypeTable *PowOptionsTypeTable();

inline const flatbuffers::TypeTable *FakeQuantOptionsTypeTable();

inline const flatbuffers::TypeTable *PackOptionsTypeTable();

inline const flatbuffers::TypeTable *LogicalOrOptionsTypeTable();

inline const flatbuffers::TypeTable *OneHotOptionsTypeTable();

inline const flatbuffers::TypeTable *AbsOptionsTypeTable();

inline const flatbuffers::TypeTable *HardSwishOptionsTypeTable();

inline const flatbuffers::TypeTable *LogicalAndOptionsTypeTable();

inline const flatbuffers::TypeTable *LogicalNotOptionsTypeTable();

inline const flatbuffers::TypeTable *UnpackOptionsTypeTable();

inline const flatbuffers::TypeTable *FloorDivOptionsTypeTable();

inline const flatbuffers::TypeTable *SquareOptionsTypeTable();

inline const flatbuffers::TypeTable *ZerosLikeOptionsTypeTable();

inline const flatbuffers::TypeTable *FillOptionsTypeTable();

inline const flatbuffers::TypeTable *FloorModOptionsTypeTable();

inline const flatbuffers::TypeTable *RangeOptionsTypeTable();

inline const flatbuffers::TypeTable *LeakyReluOptionsTypeTable();

inline const flatbuffers::TypeTable *SquaredDifferenceOptionsTypeTable();

inline const flatbuffers::TypeTable *MirrorPadOptionsTypeTable();

inline const flatbuffers::TypeTable *UniqueOptionsTypeTable();

inline const flatbuffers::TypeTable *ReverseV2OptionsTypeTable();

inline const flatbuffers::TypeTable *AddNOptionsTypeTable();

inline const flatbuffers::TypeTable *GatherNdOptionsTypeTable();

inline const flatbuffers::TypeTable *WhereOptionsTypeTable();

inline const flatbuffers::TypeTable *ReverseSequenceOptionsTypeTable();

inline const flatbuffers::TypeTable *MatrixDiagOptionsTypeTable();

inline const flatbuffers::TypeTable *QuantizeOptionsTypeTable();

inline const flatbuffers::TypeTable *MatrixSetDiagOptionsTypeTable();

inline const flatbuffers::TypeTable *IfOptionsTypeTable();

inline const flatbuffers::TypeTable *CallOnceOptionsTypeTable();

inline const flatbuffers::TypeTable *WhileOptionsTypeTable();

inline const flatbuffers::TypeTable *NonMaxSuppressionV4OptionsTypeTable();

inline const flatbuffers::TypeTable *NonMaxSuppressionV5OptionsTypeTable();

inline const flatbuffers::TypeTable *ScatterNdOptionsTypeTable();

inline const flatbuffers::TypeTable *SelectV2OptionsTypeTable();

inline const flatbuffers::TypeTable *DensifyOptionsTypeTable();

inline const flatbuffers::TypeTable *SegmentSumOptionsTypeTable();

inline const flatbuffers::TypeTable *BatchMatMulOptionsTypeTable();

inline const flatbuffers::TypeTable *CumsumOptionsTypeTable();

inline const flatbuffers::TypeTable *BroadcastToOptionsTypeTable();

inline const flatbuffers::TypeTable *Rfft2dOptionsTypeTable();

inline const flatbuffers::TypeTable *HashtableOptionsTypeTable();

inline const flatbuffers::TypeTable *HashtableFindOptionsTypeTable();

inline const flatbuffers::TypeTable *HashtableImportOptionsTypeTable();

inline const flatbuffers::TypeTable *HashtableSizeOptionsTypeTable();

inline const flatbuffers::TypeTable *VarHandleOptionsTypeTable();

inline const flatbuffers::TypeTable *ReadVariableOptionsTypeTable();

inline const flatbuffers::TypeTable *AssignVariableOptionsTypeTable();

inline const flatbuffers::TypeTable *RandomOptionsTypeTable();

inline const flatbuffers::TypeTable *BucketizeOptionsTypeTable();

inline const flatbuffers::TypeTable *GeluOptionsTypeTable();

inline const flatbuffers::TypeTable *DynamicUpdateSliceOptionsTypeTable();

inline const flatbuffers::TypeTable *UnsortedSegmentProdOptionsTypeTable();

inline const flatbuffers::TypeTable *UnsortedSegmentMaxOptionsTypeTable();

inline const flatbuffers::TypeTable *UnsortedSegmentSumOptionsTypeTable();

inline const flatbuffers::TypeTable *ATan2OptionsTypeTable();

inline const flatbuffers::TypeTable *UnsortedSegmentMinOptionsTypeTable();

inline const flatbuffers::TypeTable *SignOptionsTypeTable();

inline const flatbuffers::TypeTable *BitcastOptionsTypeTable();

inline const flatbuffers::TypeTable *BitwiseXorOptionsTypeTable();

inline const flatbuffers::TypeTable *RightShiftOptionsTypeTable();

inline const flatbuffers::TypeTable *DilateOptionsTypeTable();

inline const flatbuffers::TypeTable *ReduceWindowOptionsTypeTable();

inline const flatbuffers::TypeTable *OperatorCodeTypeTable();

inline const flatbuffers::TypeTable *StableHLOCompositeOptionsTypeTable();

inline const flatbuffers::TypeTable *StablehloShiftLeftOptionsTypeTable();

inline const flatbuffers::TypeTable *OperatorTypeTable();

inline const flatbuffers::TypeTable *SubGraphTypeTable();

inline const flatbuffers::TypeTable *BufferTypeTable();

inline const flatbuffers::TypeTable *MetadataTypeTable();

inline const flatbuffers::TypeTable *TensorMapTypeTable();

inline const flatbuffers::TypeTable *SignatureDefTypeTable();

inline const flatbuffers::TypeTable *ModelTypeTable();

enum TensorType {
  TensorType_FLOAT32 = 0,
  TensorType_FLOAT16 = 1,
  TensorType_INT32 = 2,
  TensorType_UINT8 = 3,
  TensorType_INT64 = 4,
  TensorType_STRING = 5,
  TensorType_BOOL = 6,
  TensorType_INT16 = 7,
  TensorType_COMPLEX64 = 8,
  TensorType_INT8 = 9,
  TensorType_FLOAT64 = 10,
  TensorType_COMPLEX128 = 11,
  TensorType_UINT64 = 12,
  TensorType_RESOURCE = 13,
  TensorType_VARIANT = 14,
  TensorType_UINT32 = 15,
  TensorType_UINT16 = 16,
  TensorType_INT4 = 17,
  TensorType_BFLOAT16 = 18,
  TensorType_MIN = TensorType_FLOAT32,
  TensorType_MAX = TensorType_BFLOAT16
};

inline const TensorType (&EnumValuesTensorType())[19] {
  static const TensorType values[] = {
    TensorType_FLOAT32,
    TensorType_FLOAT16,
    TensorType_INT32,
    TensorType_UINT8,
    TensorType_INT64,
    TensorType_STRING,
    TensorType_BOOL,
    TensorType_INT16,
    TensorType_COMPLEX64,
    TensorType_INT8,
    TensorType_FLOAT64,
    TensorType_COMPLEX128,
    TensorType_UINT64,
    TensorType_RESOURCE,
    TensorType_VARIANT,
    TensorType_UINT32,
    TensorType_UINT16,
    TensorType_INT4,
    TensorType_BFLOAT16
  };
  return values;
}

inline const char * const *EnumNamesTensorType() {
  static const char * const names[] = {
    "FLOAT32",
    "FLOAT16",
    "INT32",
    "UINT8",
    "INT64",
    "STRING",
    "BOOL",
    "INT16",
    "COMPLEX64",
    "INT8",
    "FLOAT64",
    "COMPLEX128",
    "UINT64",
    "RESOURCE",
    "VARIANT",
    "UINT32",
    "UINT16",
    "INT4",
    "BFLOAT16",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorType(TensorType e) {
  if (e < TensorType_FLOAT32 || e > TensorType_BFLOAT16) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesTensorType()[index];
}

enum QuantizationDetails {
  QuantizationDetails_NONE = 0,
  QuantizationDetails_CustomQuantization = 1,
  QuantizationDetails_BlockwiseQuantization = 2,
  QuantizationDetails_MIN = QuantizationDetails_NONE,
  QuantizationDetails_MAX = QuantizationDetails_BlockwiseQuantization
};

inline const QuantizationDetails (&EnumValuesQuantizationDetails())[3] {
  static const QuantizationDetails values[] = {
    QuantizationDetails_NONE,
    QuantizationDetails_CustomQuantization,
    QuantizationDetails_BlockwiseQuantization
  };
  return values;
}

inline const char * const *EnumNamesQuantizationDetails() {
  static const char * const names[] = {
    "NONE",
    "CustomQuantization",
    "BlockwiseQuantization",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizationDetails(QuantizationDetails e) {
  if (e < QuantizationDetails_NONE || e > QuantizationDetails_BlockwiseQuantization) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesQuantizationDetails()[index];
}

template<typename T> struct QuantizationDetailsTraits {
  static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template<> struct QuantizationDetailsTraits<CustomQuantization> {
  static const QuantizationDetails enum_value = QuantizationDetails_CustomQuantization;
};

template<> struct QuantizationDetailsTraits<BlockwiseQuantization> {
  static const QuantizationDetails enum_value = QuantizationDetails_BlockwiseQuantization;
};

struct QuantizationDetailsUnion {
  QuantizationDetails type;
  void *value;

  QuantizationDetailsUnion() : type(QuantizationDetails_NONE), value(nullptr) {}
  QuantizationDetailsUnion(QuantizationDetailsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(QuantizationDetails_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  QuantizationDetailsUnion(const QuantizationDetailsUnion &) FLATBUFFERS_NOEXCEPT;
  QuantizationDetailsUnion &operator=(const QuantizationDetailsUnion &u) FLATBUFFERS_NOEXCEPT
    { QuantizationDetailsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  QuantizationDetailsUnion &operator=(QuantizationDetailsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~QuantizationDetailsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = QuantizationDetailsTraits<typename T::TableType>::enum_value;
    if (type != QuantizationDetails_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, QuantizationDetails type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  CustomQuantizationT *AsCustomQuantization() {
    return type == QuantizationDetails_CustomQuantization ?
      reinterpret_cast<CustomQuantizationT *>(value) : nullptr;
  }
  const CustomQuantizationT *AsCustomQuantization() const {
    return type == QuantizationDetails_CustomQuantization ?
      reinterpret_cast<const CustomQuantizationT *>(value) : nullptr;
  }
  BlockwiseQuantizationT *AsBlockwiseQuantization() {
    return type == QuantizationDetails_BlockwiseQuantization ?
      reinterpret_cast<BlockwiseQuantizationT *>(value) : nullptr;
  }
  const BlockwiseQuantizationT *AsBlockwiseQuantization() const {
    return type == QuantizationDetails_BlockwiseQuantization ?
      reinterpret_cast<const BlockwiseQuantizationT *>(value) : nullptr;
  }
};

bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type);
bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum DimensionType {
  DimensionType_DENSE = 0,
  DimensionType_SPARSE_CSR = 1,
  DimensionType_MIN = DimensionType_DENSE,
  DimensionType_MAX = DimensionType_SPARSE_CSR
};

inline const DimensionType (&EnumValuesDimensionType())[2] {
  static const DimensionType values[] = {
    DimensionType_DENSE,
    DimensionType_SPARSE_CSR
  };
  return values;
}

inline const char * const *EnumNamesDimensionType() {
  static const char * const names[] = {
    "DENSE",
    "SPARSE_CSR",
    nullptr
  };
  return names;
}

inline const char *EnumNameDimensionType(DimensionType e) {
  if (e < DimensionType_DENSE || e > DimensionType_SPARSE_CSR) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesDimensionType()[index];
}

enum SparseIndexVector {
  SparseIndexVector_NONE = 0,
  SparseIndexVector_Int32Vector = 1,
  SparseIndexVector_Uint16Vector = 2,
  SparseIndexVector_Uint8Vector = 3,
  SparseIndexVector_MIN = SparseIndexVector_NONE,
  SparseIndexVector_MAX = SparseIndexVector_Uint8Vector
};

inline const SparseIndexVector (&EnumValuesSparseIndexVector())[4] {
  static const SparseIndexVector values[] = {
    SparseIndexVector_NONE,
    SparseIndexVector_Int32Vector,
    SparseIndexVector_Uint16Vector,
    SparseIndexVector_Uint8Vector
  };
  return values;
}

inline const char * const *EnumNamesSparseIndexVector() {
  static const char * const names[] = {
    "NONE",
    "Int32Vector",
    "Uint16Vector",
    "Uint8Vector",
    nullptr
  };
  return names;
}

inline const char *EnumNameSparseIndexVector(SparseIndexVector e) {
  if (e < SparseIndexVector_NONE || e > SparseIndexVector_Uint8Vector) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesSparseIndexVector()[index];
}

template<typename T> struct SparseIndexVectorTraits {
  static const SparseIndexVector enum_value = SparseIndexVector_NONE;
};

template<> struct SparseIndexVectorTraits<Int32Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Int32Vector;
};

template<> struct SparseIndexVectorTraits<Uint16Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint16Vector;
};

template<> struct SparseIndexVectorTraits<Uint8Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint8Vector;
};

struct SparseIndexVectorUnion {
  SparseIndexVector type;
  void *value;

  SparseIndexVectorUnion() : type(SparseIndexVector_NONE), value(nullptr) {}
  SparseIndexVectorUnion(SparseIndexVectorUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(SparseIndexVector_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  SparseIndexVectorUnion(const SparseIndexVectorUnion &) FLATBUFFERS_NOEXCEPT;
  SparseIndexVectorUnion &operator=(const SparseIndexVectorUnion &u) FLATBUFFERS_NOEXCEPT
    { SparseIndexVectorUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  SparseIndexVectorUnion &operator=(SparseIndexVectorUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~SparseIndexVectorUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = SparseIndexVectorTraits<typename T::TableType>::enum_value;
    if (type != SparseIndexVector_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, SparseIndexVector type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Int32VectorT *AsInt32Vector() {
    return type == SparseIndexVector_Int32Vector ?
      reinterpret_cast<Int32VectorT *>(value) : nullptr;
  }
  const Int32VectorT *AsInt32Vector() const {
    return type == SparseIndexVector_Int32Vector ?
      reinterpret_cast<const Int32VectorT *>(value) : nullptr;
  }
  Uint16VectorT *AsUint16Vector() {
    return type == SparseIndexVector_Uint16Vector ?
      reinterpret_cast<Uint16VectorT *>(value) : nullptr;
  }
  const Uint16VectorT *AsUint16Vector() const {
    return type == SparseIndexVector_Uint16Vector ?
      reinterpret_cast<const Uint16VectorT *>(value) : nullptr;
  }
  Uint8VectorT *AsUint8Vector() {
    return type == SparseIndexVector_Uint8Vector ?
      reinterpret_cast<Uint8VectorT *>(value) : nullptr;
  }
  const Uint8VectorT *AsUint8Vector() const {
    return type == SparseIndexVector_Uint8Vector ?
      reinterpret_cast<const Uint8VectorT *>(value) : nullptr;
  }
};

bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type);
bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BuiltinOperator {
  BuiltinOperator_ADD = 0,
  BuiltinOperator_AVERAGE_POOL_2D = 1,
  BuiltinOperator_CONCATENATION = 2,
  BuiltinOperator_CONV_2D = 3,
  BuiltinOperator_DEPTHWISE_CONV_2D = 4,
  BuiltinOperator_DEPTH_TO_SPACE = 5,
  BuiltinOperator_DEQUANTIZE = 6,
  BuiltinOperator_EMBEDDING_LOOKUP = 7,
  BuiltinOperator_FLOOR = 8,
  BuiltinOperator_FULLY_CONNECTED = 9,
  BuiltinOperator_HASHTABLE_LOOKUP = 10,
  BuiltinOperator_L2_NORMALIZATION = 11,
  BuiltinOperator_L2_POOL_2D = 12,
  BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
  BuiltinOperator_LOGISTIC = 14,
  BuiltinOperator_LSH_PROJECTION = 15,
  BuiltinOperator_LSTM = 16,
  BuiltinOperator_MAX_POOL_2D = 17,
  BuiltinOperator_MUL = 18,
  BuiltinOperator_RELU = 19,
  BuiltinOperator_RELU_N1_TO_1 = 20,
  BuiltinOperator_RELU6 = 21,
  BuiltinOperator_RESHAPE = 22,
  BuiltinOperator_RESIZE_BILINEAR = 23,
  BuiltinOperator_RNN = 24,
  BuiltinOperator_SOFTMAX = 25,
  BuiltinOperator_SPACE_TO_DEPTH = 26,
  BuiltinOperator_SVDF = 27,
  BuiltinOperator_TANH = 28,
  BuiltinOperator_CONCAT_EMBEDDINGS = 29,
  BuiltinOperator_SKIP_GRAM = 30,
  BuiltinOperator_CALL = 31,
  BuiltinOperator_CUSTOM = 32,
  BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
  BuiltinOperator_PAD = 34,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  BuiltinOperator_GATHER = 36,
  BuiltinOperator_BATCH_TO_SPACE_ND = 37,
  BuiltinOperator_SPACE_TO_BATCH_ND = 38,
  BuiltinOperator_TRANSPOSE = 39,
  BuiltinOperator_MEAN = 40,
  BuiltinOperator_SUB = 41,
  BuiltinOperator_DIV = 42,
  BuiltinOperator_SQUEEZE = 43,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  BuiltinOperator_STRIDED_SLICE = 45,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
  BuiltinOperator_EXP = 47,
  BuiltinOperator_TOPK_V2 = 48,
  BuiltinOperator_SPLIT = 49,
  BuiltinOperator_LOG_SOFTMAX = 50,
  BuiltinOperator_DELEGATE = 51,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  BuiltinOperator_CAST = 53,
  BuiltinOperator_PRELU = 54,
  BuiltinOperator_MAXIMUM = 55,
  BuiltinOperator_ARG_MAX = 56,
  BuiltinOperator_MINIMUM = 57,
  BuiltinOperator_LESS = 58,
  BuiltinOperator_NEG = 59,
  BuiltinOperator_PADV2 = 60,
  BuiltinOperator_GREATER = 61,
  BuiltinOperator_GREATER_EQUAL = 62,
  BuiltinOperator_LESS_EQUAL = 63,
  BuiltinOperator_SELECT = 64,
  BuiltinOperator_SLICE = 65,
  BuiltinOperator_SIN = 66,
  BuiltinOperator_TRANSPOSE_CONV = 67,
  BuiltinOperator_SPARSE_TO_DENSE = 68,
  BuiltinOperator_TILE = 69,
  BuiltinOperator_EXPAND_DIMS = 70,
  BuiltinOperator_EQUAL = 71,
  BuiltinOperator_NOT_EQUAL = 72,
  BuiltinOperator_LOG = 73,
  BuiltinOperator_SUM = 74,
  BuiltinOperator_SQRT = 75,
  BuiltinOperator_RSQRT = 76,
  BuiltinOperator_SHAPE = 77,
  BuiltinOperator_POW = 78,
  BuiltinOperator_ARG_MIN = 79,
  BuiltinOperator_FAKE_QUANT = 80,
  BuiltinOperator_REDUCE_PROD = 81,
  BuiltinOperator_REDUCE_MAX = 82,
  BuiltinOperator_PACK = 83,
  BuiltinOperator_LOGICAL_OR = 84,
  BuiltinOperator_ONE_HOT = 85,
  BuiltinOperator_LOGICAL_AND = 86,
  BuiltinOperator_LOGICAL_NOT = 87,
  BuiltinOperator_UNPACK = 88,
  BuiltinOperator_REDUCE_MIN = 89,
  BuiltinOperator_FLOOR_DIV = 90,
  BuiltinOperator_REDUCE_ANY = 91,
  BuiltinOperator_SQUARE = 92,
  BuiltinOperator_ZEROS_LIKE = 93,
  BuiltinOperator_FILL = 94,
  BuiltinOperator_FLOOR_MOD = 95,
  BuiltinOperator_RANGE = 96,
  BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
  BuiltinOperator_LEAKY_RELU = 98,
  BuiltinOperator_SQUARED_DIFFERENCE = 99,
  BuiltinOperator_MIRROR_PAD = 100,
  BuiltinOperator_ABS = 101,
  BuiltinOperator_SPLIT_V = 102,
  BuiltinOperator_UNIQUE = 103,
  BuiltinOperator_CEIL = 104,
  BuiltinOperator_REVERSE_V2 = 105,
  BuiltinOperator_ADD_N = 106,
  BuiltinOperator_GATHER_ND = 107,
  BuiltinOperator_COS = 108,
  BuiltinOperator_WHERE = 109,
  BuiltinOperator_RANK = 110,
  BuiltinOperator_ELU = 111,
  BuiltinOperator_REVERSE_SEQUENCE = 112,
  BuiltinOperator_MATRIX_DIAG = 113,
  BuiltinOperator_QUANTIZE = 114,
  BuiltinOperator_MATRIX_SET_DIAG = 115,
  BuiltinOperator_ROUND = 116,
  BuiltinOperator_HARD_SWISH = 117,
  BuiltinOperator_IF = 118,
  BuiltinOperator_WHILE = 119,
  BuiltinOperator_NON_MAX_SUPPRESSION_V4 = 120,
  BuiltinOperator_NON_MAX_SUPPRESSION_V5 = 121,
  BuiltinOperator_SCATTER_ND = 122,
  BuiltinOperator_SELECT_V2 = 123,
  BuiltinOperator_DENSIFY = 124,
  BuiltinOperator_SEGMENT_SUM = 125,
  BuiltinOperator_BATCH_MATMUL = 126,
  BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
  BuiltinOperator_CUMSUM = 128,
  BuiltinOperator_CALL_ONCE = 129,
  BuiltinOperator_BROADCAST_TO = 130,
  BuiltinOperator_RFFT2D = 131,
  BuiltinOperator_CONV_3D = 132,
  BuiltinOperator_IMAG = 133,
  BuiltinOperator_REAL = 134,
  BuiltinOperator_COMPLEX_ABS = 135,
  BuiltinOperator_HASHTABLE = 136,
  BuiltinOperator_HASHTABLE_FIND = 137,
  BuiltinOperator_HASHTABLE_IMPORT = 138,
  BuiltinOperator_HASHTABLE_SIZE = 139,
  BuiltinOperator_REDUCE_ALL = 140,
  BuiltinOperator_CONV_3D_TRANSPOSE = 141,
  BuiltinOperator_VAR_HANDLE = 142,
  BuiltinOperator_READ_VARIABLE = 143,
  BuiltinOperator_ASSIGN_VARIABLE = 144,
  BuiltinOperator_BROADCAST_ARGS = 145,
  BuiltinOperator_RANDOM_STANDARD_NORMAL = 146,
  BuiltinOperator_BUCKETIZE = 147,
  BuiltinOperator_RANDOM_UNIFORM = 148,
  BuiltinOperator_MULTINOMIAL = 149,
  BuiltinOperator_GELU = 150,
  BuiltinOperator_DYNAMIC_UPDATE_SLICE = 151,
  BuiltinOperator_RELU_0_TO_1 = 152,
  BuiltinOperator_UNSORTED_SEGMENT_PROD = 153,
  BuiltinOperator_UNSORTED_SEGMENT_MAX = 154,
  BuiltinOperator_UNSORTED_SEGMENT_SUM = 155,
  BuiltinOperator_ATAN2 = 156,
  BuiltinOperator_UNSORTED_SEGMENT_MIN = 157,
  BuiltinOperator_SIGN = 158,
  BuiltinOperator_BITCAST = 159,
  BuiltinOperator_BITWISE_XOR = 160,
  BuiltinOperator_RIGHT_SHIFT = 161,
  BuiltinOperator_STABLEHLO_LOGISTIC = 162,
  BuiltinOperator_STABLEHLO_ADD = 163,
  BuiltinOperator_STABLEHLO_DIVIDE = 164,
  BuiltinOperator_STABLEHLO_MULTIPLY = 165,
  BuiltinOperator_STABLEHLO_MAXIMUM = 166,
  BuiltinOperator_STABLEHLO_RESHAPE = 167,
  BuiltinOperator_STABLEHLO_CLAMP = 168,
  BuiltinOperator_STABLEHLO_CONCATENATE = 169,
  BuiltinOperator_STABLEHLO_BROADCAST_IN_DIM = 170,
  BuiltinOperator_STABLEHLO_CONVOLUTION = 171,
  BuiltinOperator_STABLEHLO_SLICE = 172,
  BuiltinOperator_STABLEHLO_CUSTOM_CALL = 173,
  BuiltinOperator_STABLEHLO_REDUCE = 174,
  BuiltinOperator_STABLEHLO_ABS = 175,
  BuiltinOperator_STABLEHLO_AND = 176,
  BuiltinOperator_STABLEHLO_COSINE = 177,
  BuiltinOperator_STABLEHLO_EXPONENTIAL = 178,
  BuiltinOperator_STABLEHLO_FLOOR = 179,
  BuiltinOperator_STABLEHLO_LOG = 180,
  BuiltinOperator_STABLEHLO_MINIMUM = 181,
  BuiltinOperator_STABLEHLO_NEGATE = 182,
  BuiltinOperator_STABLEHLO_OR = 183,
  BuiltinOperator_STABLEHLO_POWER = 184,
  BuiltinOperator_STABLEHLO_REMAINDER = 185,
  BuiltinOperator_STABLEHLO_RSQRT = 186,
  BuiltinOperator_STABLEHLO_SELECT = 187,
  BuiltinOperator_STABLEHLO_SUBTRACT = 188,
  BuiltinOperator_STABLEHLO_TANH = 189,
  BuiltinOperator_STABLEHLO_SCATTER = 190,
  BuiltinOperator_STABLEHLO_COMPARE = 191,
  BuiltinOperator_STABLEHLO_CONVERT = 192,
  BuiltinOperator_STABLEHLO_DYNAMIC_SLICE = 193,
  BuiltinOperator_STABLEHLO_DYNAMIC_UPDATE_SLICE = 194,
  BuiltinOperator_STABLEHLO_PAD = 195,
  BuiltinOperator_STABLEHLO_IOTA = 196,
  BuiltinOperator_STABLEHLO_DOT_GENERAL = 197,
  BuiltinOperator_STABLEHLO_REDUCE_WINDOW = 198,
  BuiltinOperator_STABLEHLO_SORT = 199,
  BuiltinOperator_STABLEHLO_WHILE = 200,
  BuiltinOperator_STABLEHLO_GATHER = 201,
  BuiltinOperator_STABLEHLO_TRANSPOSE = 202,
  BuiltinOperator_DILATE = 203,
  BuiltinOperator_STABLEHLO_RNG_BIT_GENERATOR = 204,
  BuiltinOperator_REDUCE_WINDOW = 205,
  BuiltinOperator_STABLEHLO_COMPOSITE = 206,
  BuiltinOperator_STABLEHLO_SHIFT_LEFT = 207,
  BuiltinOperator_STABLEHLO_CBRT = 208,
  BuiltinOperator_STABLEHLO_CASE = 209,
  BuiltinOperator_MIN = BuiltinOperator_ADD,
  BuiltinOperator_MAX = BuiltinOperator_STABLEHLO_CASE
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[210] {
  static const BuiltinOperator values[] = {
    BuiltinOperator_ADD,
    BuiltinOperator_AVERAGE_POOL_2D,
    BuiltinOperator_CONCATENATION,
    BuiltinOperator_CONV_2D,
    BuiltinOperator_DEPTHWISE_CONV_2D,
    BuiltinOperator_DEPTH_TO_SPACE,
    BuiltinOperator_DEQUANTIZE,
    BuiltinOperator_EMBEDDING_LOOKUP,
    BuiltinOperator_FLOOR,
    BuiltinOperator_FULLY_CONNECTED,
    BuiltinOperator_HASHTABLE_LOOKUP,
    BuiltinOperator_L2_NORMALIZATION,
    BuiltinOperator_L2_POOL_2D,
    BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
    BuiltinOperator_LOGISTIC,
    BuiltinOperator_LSH_PROJECTION,
    BuiltinOperator_LSTM,
    BuiltinOperator_MAX_POOL_2D,
    BuiltinOperator_MUL,
    BuiltinOperator_RELU,
    BuiltinOperator_RELU_N1_TO_1,
    BuiltinOperator_RELU6,
    BuiltinOperator_RESHAPE,
    BuiltinOperator_RESIZE_BILINEAR,
    BuiltinOperator_RNN,
    BuiltinOperator_SOFTMAX,
    BuiltinOperator_SPACE_TO_DEPTH,
    BuiltinOperator_SVDF,
    BuiltinOperator_TANH,
    BuiltinOperator_CONCAT_EMBEDDINGS,
    BuiltinOperator_SKIP_GRAM,
    BuiltinOperator_CALL,
    BuiltinOperator_CUSTOM,
    BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
    BuiltinOperator_PAD,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_GATHER,
    BuiltinOperator_BATCH_TO_SPACE_ND,
    BuiltinOperator_SPACE_TO_BATCH_ND,
    BuiltinOperator_TRANSPOSE,
    BuiltinOperator_MEAN,
    BuiltinOperator_SUB,
    BuiltinOperator_DIV,
    BuiltinOperator_SQUEEZE,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_STRIDED_SLICE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_EXP,
    BuiltinOperator_TOPK_V2,
    BuiltinOperator_SPLIT,
    BuiltinOperator_LOG_SOFTMAX,
    BuiltinOperator_DELEGATE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_CAST,
    BuiltinOperator_PRELU,
    BuiltinOperator_MAXIMUM,
    BuiltinOperator_ARG_MAX,
    BuiltinOperator_MINIMUM,
    BuiltinOperator_LESS,
    BuiltinOperator_NEG,
    BuiltinOperator_PADV2,
    BuiltinOperator_GREATER,
    BuiltinOperator_GREATER_EQUAL,
    BuiltinOperator_LESS_EQUAL,
    BuiltinOperator_SELECT,
    BuiltinOperator_SLICE,
    BuiltinOperator_SIN,
    BuiltinOperator_TRANSPOSE_CONV,
    BuiltinOperator_SPARSE_TO_DENSE,
    BuiltinOperator_TILE,
    BuiltinOperator_EXPAND_DIMS,
    BuiltinOperator_EQUAL,
    BuiltinOperator_NOT_EQUAL,
    BuiltinOperator_LOG,
    BuiltinOperator_SUM,
    BuiltinOperator_SQRT,
    BuiltinOperator_RSQRT,
    BuiltinOperator_SHAPE,
    BuiltinOperator_POW,
    BuiltinOperator_ARG_MIN,
    BuiltinOperator_FAKE_QUANT,
    BuiltinOperator_REDUCE_PROD,
    BuiltinOperator_REDUCE_MAX,
    BuiltinOperator_PACK,
    BuiltinOperator_LOGICAL_OR,
    BuiltinOperator_ONE_HOT,
    BuiltinOperator_LOGICAL_AND,
    BuiltinOperator_LOGICAL_NOT,
    BuiltinOperator_UNPACK,
    BuiltinOperator_REDUCE_MIN,
    BuiltinOperator_FLOOR_DIV,
    BuiltinOperator_REDUCE_ANY,
    BuiltinOperator_SQUARE,
    BuiltinOperator_ZEROS_LIKE,
    BuiltinOperator_FILL,
    BuiltinOperator_FLOOR_MOD,
    BuiltinOperator_RANGE,
    BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
    BuiltinOperator_LEAKY_RELU,
    BuiltinOperator_SQUARED_DIFFERENCE,
    BuiltinOperator_MIRROR_PAD,
    BuiltinOperator_ABS,
    BuiltinOperator_SPLIT_V,
    BuiltinOperator_UNIQUE,
    BuiltinOperator_CEIL,
    BuiltinOperator_REVERSE_V2,
    BuiltinOperator_ADD_N,
    BuiltinOperator_GATHER_ND,
    BuiltinOperator_COS,
    BuiltinOperator_WHERE,
    BuiltinOperator_RANK,
    BuiltinOperator_ELU,
    BuiltinOperator_REVERSE_SEQUENCE,
    BuiltinOperator_MATRIX_DIAG,
    BuiltinOperator_QUANTIZE,
    BuiltinOperator_MATRIX_SET_DIAG,
    BuiltinOperator_ROUND,
    BuiltinOperator_HARD_SWISH,
    BuiltinOperator_IF,
    BuiltinOperator_WHILE,
    BuiltinOperator_NON_MAX_SUPPRESSION_V4,
    BuiltinOperator_NON_MAX_SUPPRESSION_V5,
    BuiltinOperator_SCATTER_ND,
    BuiltinOperator_SELECT_V2,
    BuiltinOperator_DENSIFY,
    BuiltinOperator_SEGMENT_SUM,
    BuiltinOperator_BATCH_MATMUL,
    BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES,
    BuiltinOperator_CUMSUM,
    BuiltinOperator_CALL_ONCE,
    BuiltinOperator_BROADCAST_TO,
    BuiltinOperator_RFFT2D,
    BuiltinOperator_CONV_3D,
    BuiltinOperator_IMAG,
    BuiltinOperator_REAL,
    BuiltinOperator_COMPLEX_ABS,
    BuiltinOperator_HASHTABLE,
    BuiltinOperator_HASHTABLE_FIND,
    BuiltinOperator_HASHTABLE_IMPORT,
    BuiltinOperator_HASHTABLE_SIZE,
    BuiltinOperator_REDUCE_ALL,
    BuiltinOperator_CONV_3D_TRANSPOSE,
    BuiltinOperator_VAR_HANDLE,
    BuiltinOperator_READ_VARIABLE,
    BuiltinOperator_ASSIGN_VARIABLE,
    BuiltinOperator_BROADCAST_ARGS,
    BuiltinOperator_RANDOM_STANDARD_NORMAL,
    BuiltinOperator_BUCKETIZE,
    BuiltinOperator_RANDOM_UNIFORM,
    BuiltinOperator_MULTINOMIAL,
    BuiltinOperator_GELU,
    BuiltinOperator_DYNAMIC_UPDATE_SLICE,
    BuiltinOperator_RELU_0_TO_1,
    BuiltinOperator_UNSORTED_SEGMENT_PROD,
    BuiltinOperator_UNSORTED_SEGMENT_MAX,
    BuiltinOperator_UNSORTED_SEGMENT_SUM,
    BuiltinOperator_ATAN2,
    BuiltinOperator_UNSORTED_SEGMENT_MIN,
    BuiltinOperator_SIGN,
    BuiltinOperator_BITCAST,
    BuiltinOperator_BITWISE_XOR,
    BuiltinOperator_RIGHT_SHIFT,
    BuiltinOperator_STABLEHLO_LOGISTIC,
    BuiltinOperator_STABLEHLO_ADD,
    BuiltinOperator_STABLEHLO_DIVIDE,
    BuiltinOperator_STABLEHLO_MULTIPLY,
    BuiltinOperator_STABLEHLO_MAXIMUM,
    BuiltinOperator_STABLEHLO_RESHAPE,
    BuiltinOperator_STABLEHLO_CLAMP,
    BuiltinOperator_STABLEHLO_CONCATENATE,
    BuiltinOperator_STABLEHLO_BROADCAST_IN_DIM,
    BuiltinOperator_STABLEHLO_CONVOLUTION,
    BuiltinOperator_STABLEHLO_SLICE,
    BuiltinOperator_STABLEHLO_CUSTOM_CALL,
    BuiltinOperator_STABLEHLO_REDUCE,
    BuiltinOperator_STABLEHLO_ABS,
    BuiltinOperator_STABLEHLO_AND,
    BuiltinOperator_STABLEHLO_COSINE,
    BuiltinOperator_STABLEHLO_EXPONENTIAL,
    BuiltinOperator_STABLEHLO_FLOOR,
    BuiltinOperator_STABLEHLO_LOG,
    BuiltinOperator_STABLEHLO_MINIMUM,
    BuiltinOperator_STABLEHLO_NEGATE,
    BuiltinOperator_STABLEHLO_OR,
    BuiltinOperator_STABLEHLO_POWER,
    BuiltinOperator_STABLEHLO_REMAINDER,
    BuiltinOperator_STABLEHLO_RSQRT,
    BuiltinOperator_STABLEHLO_SELECT,
    BuiltinOperator_STABLEHLO_SUBTRACT,
    BuiltinOperator_STABLEHLO_TANH,
    BuiltinOperator_STABLEHLO_SCATTER,
    BuiltinOperator_STABLEHLO_COMPARE,
    BuiltinOperator_STABLEHLO_CONVERT,
    BuiltinOperator_STABLEHLO_DYNAMIC_SLICE,
    BuiltinOperator_STABLEHLO_DYNAMIC_UPDATE_SLICE,
    BuiltinOperator_STABLEHLO_PAD,
    BuiltinOperator_STABLEHLO_IOTA,
    BuiltinOperator_STABLEHLO_DOT_GENERAL,
    BuiltinOperator_STABLEHLO_REDUCE_WINDOW,
    BuiltinOperator_STABLEHLO_SORT,
    BuiltinOperator_STABLEHLO_WHILE,
    BuiltinOperator_STABLEHLO_GATHER,
    BuiltinOperator_STABLEHLO_TRANSPOSE,
    BuiltinOperator_DILATE,
    BuiltinOperator_STABLEHLO_RNG_BIT_GENERATOR,
    BuiltinOperator_REDUCE_WINDOW,
    BuiltinOperator_STABLEHLO_COMPOSITE,
    BuiltinOperator_STABLEHLO_SHIFT_LEFT,
    BuiltinOperator_STABLEHLO_CBRT,
    BuiltinOperator_STABLEHLO_CASE
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOperator() {
  static const char * const names[] = {
    "ADD",
    "AVERAGE_POOL_2D",
    "CONCATENATION",
    "CONV_2D",
    "DEPTHWISE_CONV_2D",
    "DEPTH_TO_SPACE",
    "DEQUANTIZE",
    "EMBEDDING_LOOKUP",
    "FLOOR",
    "FULLY_CONNECTED",
    "HASHTABLE_LOOKUP",
    "L2_NORMALIZATION",
    "L2_POOL_2D",
    "LOCAL_RESPONSE_NORMALIZATION",
    "LOGISTIC",
    "LSH_PROJECTION",
    "LSTM",
    "MAX_POOL_2D",
    "MUL",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "RESHAPE",
    "RESIZE_BILINEAR",
    "RNN",
    "SOFTMAX",
    "SPACE_TO_DEPTH",
    "SVDF",
    "TANH",
    "CONCAT_EMBEDDINGS",
    "SKIP_GRAM",
    "CALL",
    "CUSTOM",
    "EMBEDDING_LOOKUP_SPARSE",
    "PAD",
    "UNIDIRECTIONAL_SEQUENCE_RNN",
    "GATHER",
    "BATCH_TO_SPACE_ND",
    "SPACE_TO_BATCH_ND",
    "TRANSPOSE",
    "MEAN",
    "SUB",
    "DIV",
    "SQUEEZE",
    "UNIDIRECTIONAL_SEQUENCE_LSTM",
    "STRIDED_SLICE",
    "BIDIRECTIONAL_SEQUENCE_RNN",
    "EXP",
    "TOPK_V2",
    "SPLIT",
    "LOG_SOFTMAX",
    "DELEGATE",
    "BIDIRECTIONAL_SEQUENCE_LSTM",
    "CAST",
    "PRELU",
    "MAXIMUM",
    "ARG_MAX",
    "MINIMUM",
    "LESS",
    "NEG",
    "PADV2",
    "GREATER",
    "GREATER_EQUAL",
    "LESS_EQUAL",
    "SELECT",
    "SLICE",
    "SIN",
    "TRANSPOSE_CONV",
    "SPARSE_TO_DENSE",
    "TILE",
    "EXPAND_DIMS",
    "EQUAL",
    "NOT_EQUAL",
    "LOG",
    "SUM",
    "SQRT",
    "RSQRT",
    "SHAPE",
    "POW",
    "ARG_MIN",
    "FAKE_QUANT",
    "REDUCE_PROD",
    "REDUCE_MAX",
    "PACK",
    "LOGICAL_OR",
    "ONE_HOT",
    "LOGICAL_AND",
    "LOGICAL_NOT",
    "UNPACK",
    "REDUCE_MIN",
    "FLOOR_DIV",
    "REDUCE_ANY",
    "SQUARE",
    "ZEROS_LIKE",
    "FILL",
    "FLOOR_MOD",
    "RANGE",
    "RESIZE_NEAREST_NEIGHBOR",
    "LEAKY_RELU",
    "SQUARED_DIFFERENCE",
    "MIRROR_PAD",
    "ABS",
    "SPLIT_V",
    "UNIQUE",
    "CEIL",
    "REVERSE_V2",
    "ADD_N",
    "GATHER_ND",
    "COS",
    "WHERE",
    "RANK",
    "ELU",
    "REVERSE_SEQUENCE",
    "MATRIX_DIAG",
    "QUANTIZE",
    "MATRIX_SET_DIAG",
    "ROUND",
    "HARD_SWISH",
    "IF",
    "WHILE",
    "NON_MAX_SUPPRESSION_V4",
    "NON_MAX_SUPPRESSION_V5",
    "SCATTER_ND",
    "SELECT_V2",
    "DENSIFY",
    "SEGMENT_SUM",
    "BATCH_MATMUL",
    "PLACEHOLDER_FOR_GREATER_OP_CODES",
    "CUMSUM",
    "CALL_ONCE",
    "BROADCAST_TO",
    "RFFT2D",
    "CONV_3D",
    "IMAG",
    "REAL",
    "COMPLEX_ABS",
    "HASHTABLE",
    "HASHTABLE_FIND",
    "HASHTABLE_IMPORT",
    "HASHTABLE_SIZE",
    "REDUCE_ALL",
    "CONV_3D_TRANSPOSE",
    "VAR_HANDLE",
    "READ_VARIABLE",
    "ASSIGN_VARIABLE",
    "BROADCAST_ARGS",
    "RANDOM_STANDARD_NORMAL",
    "BUCKETIZE",
    "RANDOM_UNIFORM",
    "MULTINOMIAL",
    "GELU",
    "DYNAMIC_UPDATE_SLICE",
    "RELU_0_TO_1",
    "UNSORTED_SEGMENT_PROD",
    "UNSORTED_SEGMENT_MAX",
    "UNSORTED_SEGMENT_SUM",
    "ATAN2",
    "UNSORTED_SEGMENT_MIN",
    "SIGN",
    "BITCAST",
    "BITWISE_XOR",
    "RIGHT_SHIFT",
    "STABLEHLO_LOGISTIC",
    "STABLEHLO_ADD",
    "STABLEHLO_DIVIDE",
    "STABLEHLO_MULTIPLY",
    "STABLEHLO_MAXIMUM",
    "STABLEHLO_RESHAPE",
    "STABLEHLO_CLAMP",
    "STABLEHLO_CONCATENATE",
    "STABLEHLO_BROADCAST_IN_DIM",
    "STABLEHLO_CONVOLUTION",
    "STABLEHLO_SLICE",
    "STABLEHLO_CUSTOM_CALL",
    "STABLEHLO_REDUCE",
    "STABLEHLO_ABS",
    "STABLEHLO_AND",
    "STABLEHLO_COSINE",
    "STABLEHLO_EXPONENTIAL",
    "STABLEHLO_FLOOR",
    "STABLEHLO_LOG",
    "STABLEHLO_MINIMUM",
    "STABLEHLO_NEGATE",
    "STABLEHLO_OR",
    "STABLEHLO_POWER",
    "STABLEHLO_REMAINDER",
    "STABLEHLO_RSQRT",
    "STABLEHLO_SELECT",
    "STABLEHLO_SUBTRACT",
    "STABLEHLO_TANH",
    "STABLEHLO_SCATTER",
    "STABLEHLO_COMPARE",
    "STABLEHLO_CONVERT",
    "STABLEHLO_DYNAMIC_SLICE",
    "STABLEHLO_DYNAMIC_UPDATE_SLICE",
    "STABLEHLO_PAD",
    "STABLEHLO_IOTA",
    "STABLEHLO_DOT_GENERAL",
    "STABLEHLO_REDUCE_WINDOW",
    "STABLEHLO_SORT",
    "STABLEHLO_WHILE",
    "STABLEHLO_GATHER",
    "STABLEHLO_TRANSPOSE",
    "DILATE",
    "STABLEHLO_RNG_BIT_GENERATOR",
    "REDUCE_WINDOW",
    "STABLEHLO_COMPOSITE",
    "STABLEHLO_SHIFT_LEFT",
    "STABLEHLO_CBRT",
    "STABLEHLO_CASE",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOperator(BuiltinOperator e) {
  if (e < BuiltinOperator_ADD || e > BuiltinOperator_STABLEHLO_CASE) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesBuiltinOperator()[index];
}

enum BuiltinOptions {
  BuiltinOptions_NONE = 0,
  BuiltinOptions_Conv2DOptions = 1,
  BuiltinOptions_DepthwiseConv2DOptions = 2,
  BuiltinOptions_ConcatEmbeddingsOptions = 3,
  BuiltinOptions_LSHProjectionOptions = 4,
  BuiltinOptions_Pool2DOptions = 5,
  BuiltinOptions_SVDFOptions = 6,
  BuiltinOptions_RNNOptions = 7,
  BuiltinOptions_FullyConnectedOptions = 8,
  BuiltinOptions_SoftmaxOptions = 9,
  BuiltinOptions_ConcatenationOptions = 10,
  BuiltinOptions_AddOptions = 11,
  BuiltinOptions_L2NormOptions = 12,
  BuiltinOptions_LocalResponseNormalizationOptions = 13,
  BuiltinOptions_LSTMOptions = 14,
  BuiltinOptions_ResizeBilinearOptions = 15,
  BuiltinOptions_CallOptions = 16,
  BuiltinOptions_ReshapeOptions = 17,
  BuiltinOptions_SkipGramOptions = 18,
  BuiltinOptions_SpaceToDepthOptions = 19,
  BuiltinOptions_EmbeddingLookupSparseOptions = 20,
  BuiltinOptions_MulOptions = 21,
  BuiltinOptions_PadOptions = 22,
  BuiltinOptions_GatherOptions = 23,
  BuiltinOptions_BatchToSpaceNDOptions = 24,
  BuiltinOptions_SpaceToBatchNDOptions = 25,
  BuiltinOptions_TransposeOptions = 26,
  BuiltinOptions_ReducerOptions = 27,
  BuiltinOptions_SubOptions = 28,
  BuiltinOptions_DivOptions = 29,
  BuiltinOptions_SqueezeOptions = 30,
  BuiltinOptions_SequenceRNNOptions = 31,
  BuiltinOptions_StridedSliceOptions = 32,
  BuiltinOptions_ExpOptions = 33,
  BuiltinOptions_TopKV2Options = 34,
  BuiltinOptions_SplitOptions = 35,
  BuiltinOptions_LogSoftmaxOptions = 36,
  BuiltinOptions_CastOptions = 37,
  BuiltinOptions_DequantizeOptions = 38,
  BuiltinOptions_MaximumMinimumOptions = 39,
  BuiltinOptions_ArgMaxOptions = 40,
  BuiltinOptions_LessOptions = 41,
  BuiltinOptions_NegOptions = 42,
  BuiltinOptions_PadV2Options = 43,
  BuiltinOptions_GreaterOptions = 44,
  BuiltinOptions_GreaterEqualOptions = 45,
  BuiltinOptions_LessEqualOptions = 46,
  BuiltinOptions_SelectOptions = 47,
  BuiltinOptions_SliceOptions = 48,
  BuiltinOptions_TransposeConvOptions = 49,
  BuiltinOptions_SparseToDenseOptions = 50,
  BuiltinOptions_TileOptions = 51,
  BuiltinOptions_ExpandDimsOptions = 52,
  BuiltinOptions_EqualOptions = 53,
  BuiltinOptions_NotEqualOptions = 54,
  BuiltinOptions_ShapeOptions = 55,
  BuiltinOptions_PowOptions = 56,
  BuiltinOptions_ArgMinOptions = 57,
  BuiltinOptions_FakeQuantOptions = 58,
  BuiltinOptions_PackOptions = 59,
  BuiltinOptions_LogicalOrOptions = 60,
  BuiltinOptions_OneHotOptions = 61,
  BuiltinOptions_LogicalAndOptions = 62,
  BuiltinOptions_LogicalNotOptions = 63,
  BuiltinOptions_UnpackOptions = 64,
  BuiltinOptions_FloorDivOptions = 65,
  BuiltinOptions_SquareOptions = 66,
  BuiltinOptions_ZerosLikeOptions = 67,
  BuiltinOptions_FillOptions = 68,
  BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
  BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
  BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
  BuiltinOptions_FloorModOptions = 72,
  BuiltinOptions_RangeOptions = 73,
  BuiltinOptions_ResizeNearestNeighborOptions = 74,
  BuiltinOptions_LeakyReluOptions = 75,
  BuiltinOptions_SquaredDifferenceOptions = 76,
  BuiltinOptions_MirrorPadOptions = 77,
  BuiltinOptions_AbsOptions = 78,
  BuiltinOptions_SplitVOptions = 79,
  BuiltinOptions_UniqueOptions = 80,
  BuiltinOptions_ReverseV2Options = 81,
  BuiltinOptions_AddNOptions = 82,
  BuiltinOptions_GatherNdOptions = 83,
  BuiltinOptions_CosOptions = 84,
  BuiltinOptions_WhereOptions = 85,
  BuiltinOptions_RankOptions = 86,
  BuiltinOptions_ReverseSequenceOptions = 87,
  BuiltinOptions_MatrixDiagOptions = 88,
  BuiltinOptions_QuantizeOptions = 89,
  BuiltinOptions_MatrixSetDiagOptions = 90,
  BuiltinOptions_HardSwishOptions = 91,
  BuiltinOptions_IfOptions = 92,
  BuiltinOptions_WhileOptions = 93,
  BuiltinOptions_DepthToSpaceOptions = 94,
  BuiltinOptions_NonMaxSuppressionV4Options = 95,
  BuiltinOptions_NonMaxSuppressionV5Options = 96,
  BuiltinOptions_ScatterNdOptions = 97,
  BuiltinOptions_SelectV2Options = 98,
  BuiltinOptions_DensifyOptions = 99,
  BuiltinOptions_SegmentSumOptions = 100,
  BuiltinOptions_BatchMatMulOptions = 101,
  BuiltinOptions_CumsumOptions = 102,
  BuiltinOptions_CallOnceOptions = 103,
  BuiltinOptions_BroadcastToOptions = 104,
  BuiltinOptions_Rfft2dOptions = 105,
  BuiltinOptions_Conv3DOptions = 106,
  BuiltinOptions_HashtableOptions = 107,
  BuiltinOptions_HashtableFindOptions = 108,
  BuiltinOptions_HashtableImportOptions = 109,
  BuiltinOptions_HashtableSizeOptions = 110,
  BuiltinOptions_VarHandleOptions = 111,
  BuiltinOptions_ReadVariableOptions = 112,
  BuiltinOptions_AssignVariableOptions = 113,
  BuiltinOptions_RandomOptions = 114,
  BuiltinOptions_BucketizeOptions = 115,
  BuiltinOptions_GeluOptions = 116,
  BuiltinOptions_DynamicUpdateSliceOptions = 117,
  BuiltinOptions_UnsortedSegmentProdOptions = 118,
  BuiltinOptions_UnsortedSegmentMaxOptions = 119,
  BuiltinOptions_UnsortedSegmentMinOptions = 120,
  BuiltinOptions_UnsortedSegmentSumOptions = 121,
  BuiltinOptions_ATan2Options = 122,
  BuiltinOptions_SignOptions = 123,
  BuiltinOptions_BitcastOptions = 124,
  BuiltinOptions_BitwiseXorOptions = 125,
  BuiltinOptions_RightShiftOptions = 126,
  BuiltinOptions_MIN = BuiltinOptions_NONE,
  BuiltinOptions_MAX = BuiltinOptions_RightShiftOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[127] {
  static const BuiltinOptions values[] = {
    BuiltinOptions_NONE,
    BuiltinOptions_Conv2DOptions,
    BuiltinOptions_DepthwiseConv2DOptions,
    BuiltinOptions_ConcatEmbeddingsOptions,
    BuiltinOptions_LSHProjectionOptions,
    BuiltinOptions_Pool2DOptions,
    BuiltinOptions_SVDFOptions,
    BuiltinOptions_RNNOptions,
    BuiltinOptions_FullyConnectedOptions,
    BuiltinOptions_SoftmaxOptions,
    BuiltinOptions_ConcatenationOptions,
    BuiltinOptions_AddOptions,
    BuiltinOptions_L2NormOptions,
    BuiltinOptions_LocalResponseNormalizationOptions,
    BuiltinOptions_LSTMOptions,
    BuiltinOptions_ResizeBilinearOptions,
    BuiltinOptions_CallOptions,
    BuiltinOptions_ReshapeOptions,
    BuiltinOptions_SkipGramOptions,
    BuiltinOptions_SpaceToDepthOptions,
    BuiltinOptions_EmbeddingLookupSparseOptions,
    BuiltinOptions_MulOptions,
    BuiltinOptions_PadOptions,
    BuiltinOptions_GatherOptions,
    BuiltinOptions_BatchToSpaceNDOptions,
    BuiltinOptions_SpaceToBatchNDOptions,
    BuiltinOptions_TransposeOptions,
    BuiltinOptions_ReducerOptions,
    BuiltinOptions_SubOptions,
    BuiltinOptions_DivOptions,
    BuiltinOptions_SqueezeOptions,
    BuiltinOptions_SequenceRNNOptions,
    BuiltinOptions_StridedSliceOptions,
    BuiltinOptions_ExpOptions,
    BuiltinOptions_TopKV2Options,
    BuiltinOptions_SplitOptions,
    BuiltinOptions_LogSoftmaxOptions,
    BuiltinOptions_CastOptions,
    BuiltinOptions_DequantizeOptions,
    BuiltinOptions_MaximumMinimumOptions,
    BuiltinOptions_ArgMaxOptions,
    BuiltinOptions_LessOptions,
    BuiltinOptions_NegOptions,
    BuiltinOptions_PadV2Options,
    BuiltinOptions_GreaterOptions,
    BuiltinOptions_GreaterEqualOptions,
    BuiltinOptions_LessEqualOptions,
    BuiltinOptions_SelectOptions,
    BuiltinOptions_SliceOptions,
    BuiltinOptions_TransposeConvOptions,
    BuiltinOptions_SparseToDenseOptions,
    BuiltinOptions_TileOptions,
    BuiltinOptions_ExpandDimsOptions,
    BuiltinOptions_EqualOptions,
    BuiltinOptions_NotEqualOptions,
    BuiltinOptions_ShapeOptions,
    BuiltinOptions_PowOptions,
    BuiltinOptions_ArgMinOptions,
    BuiltinOptions_FakeQuantOptions,
    BuiltinOptions_PackOptions,
    BuiltinOptions_LogicalOrOptions,
    BuiltinOptions_OneHotOptions,
    BuiltinOptions_LogicalAndOptions,
    BuiltinOptions_LogicalNotOptions,
    BuiltinOptions_UnpackOptions,
    BuiltinOptions_FloorDivOptions,
    BuiltinOptions_SquareOptions,
    BuiltinOptions_ZerosLikeOptions,
    BuiltinOptions_FillOptions,
    BuiltinOptions_BidirectionalSequenceLSTMOptions,
    BuiltinOptions_BidirectionalSequenceRNNOptions,
    BuiltinOptions_UnidirectionalSequenceLSTMOptions,
    BuiltinOptions_FloorModOptions,
    BuiltinOptions_RangeOptions,
    BuiltinOptions_ResizeNearestNeighborOptions,
    BuiltinOptions_LeakyReluOptions,
    BuiltinOptions_SquaredDifferenceOptions,
    BuiltinOptions_MirrorPadOptions,
    BuiltinOptions_AbsOptions,
    BuiltinOptions_SplitVOptions,
    BuiltinOptions_UniqueOptions,
    BuiltinOptions_ReverseV2Options,
    BuiltinOptions_AddNOptions,
    BuiltinOptions_GatherNdOptions,
    BuiltinOptions_CosOptions,
    BuiltinOptions_WhereOptions,
    BuiltinOptions_RankOptions,
    BuiltinOptions_ReverseSequenceOptions,
    BuiltinOptions_MatrixDiagOptions,
    BuiltinOptions_QuantizeOptions,
    BuiltinOptions_MatrixSetDiagOptions,
    BuiltinOptions_HardSwishOptions,
    BuiltinOptions_IfOptions,
    BuiltinOptions_WhileOptions,
    BuiltinOptions_DepthToSpaceOptions,
    BuiltinOptions_NonMaxSuppressionV4Options,
    BuiltinOptions_NonMaxSuppressionV5Options,
    BuiltinOptions_ScatterNdOptions,
    BuiltinOptions_SelectV2Options,
    BuiltinOptions_DensifyOptions,
    BuiltinOptions_SegmentSumOptions,
    BuiltinOptions_BatchMatMulOptions,
    BuiltinOptions_CumsumOptions,
    BuiltinOptions_CallOnceOptions,
    BuiltinOptions_BroadcastToOptions,
    BuiltinOptions_Rfft2dOptions,
    BuiltinOptions_Conv3DOptions,
    BuiltinOptions_HashtableOptions,
    BuiltinOptions_HashtableFindOptions,
    BuiltinOptions_HashtableImportOptions,
    BuiltinOptions_HashtableSizeOptions,
    BuiltinOptions_VarHandleOptions,
    BuiltinOptions_ReadVariableOptions,
    BuiltinOptions_AssignVariableOptions,
    BuiltinOptions_RandomOptions,
    BuiltinOptions_BucketizeOptions,
    BuiltinOptions_GeluOptions,
    BuiltinOptions_DynamicUpdateSliceOptions,
    BuiltinOptions_UnsortedSegmentProdOptions,
    BuiltinOptions_UnsortedSegmentMaxOptions,
    BuiltinOptions_UnsortedSegmentMinOptions,
    BuiltinOptions_UnsortedSegmentSumOptions,
    BuiltinOptions_ATan2Options,
    BuiltinOptions_SignOptions,
    BuiltinOptions_BitcastOptions,
    BuiltinOptions_BitwiseXorOptions,
    BuiltinOptions_RightShiftOptions
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOptions() {
  static const char * const names[] = {
    "NONE",
    "Conv2DOptions",
    "DepthwiseConv2DOptions",
    "ConcatEmbeddingsOptions",
    "LSHProjectionOptions",
    "Pool2DOptions",
    "SVDFOptions",
    "RNNOptions",
    "FullyConnectedOptions",
    "SoftmaxOptions",
    "ConcatenationOptions",
    "AddOptions",
    "L2NormOptions",
    "LocalResponseNormalizationOptions",
    "LSTMOptions",
    "ResizeBilinearOptions",
    "CallOptions",
    "ReshapeOptions",
    "SkipGramOptions",
    "SpaceToDepthOptions",
    "EmbeddingLookupSparseOptions",
    "MulOptions",
    "PadOptions",
    "GatherOptions",
    "BatchToSpaceNDOptions",
    "SpaceToBatchNDOptions",
    "TransposeOptions",
    "ReducerOptions",
    "SubOptions",
    "DivOptions",
    "SqueezeOptions",
    "SequenceRNNOptions",
    "StridedSliceOptions",
    "ExpOptions",
    "TopKV2Options",
    "SplitOptions",
    "LogSoftmaxOptions",
    "CastOptions",
    "DequantizeOptions",
    "MaximumMinimumOptions",
    "ArgMaxOptions",
    "LessOptions",
    "NegOptions",
    "PadV2Options",
    "GreaterOptions",
    "GreaterEqualOptions",
    "LessEqualOptions",
    "SelectOptions",
    "SliceOptions",
    "TransposeConvOptions",
    "SparseToDenseOptions",
    "TileOptions",
    "ExpandDimsOptions",
    "EqualOptions",
    "NotEqualOptions",
    "ShapeOptions",
    "PowOptions",
    "ArgMinOptions",
    "FakeQuantOptions",
    "PackOptions",
    "LogicalOrOptions",
    "OneHotOptions",
    "LogicalAndOptions",
    "LogicalNotOptions",
    "UnpackOptions",
    "FloorDivOptions",
    "SquareOptions",
    "ZerosLikeOptions",
    "FillOptions",
    "BidirectionalSequenceLSTMOptions",
    "BidirectionalSequenceRNNOptions",
    "UnidirectionalSequenceLSTMOptions",
    "FloorModOptions",
    "RangeOptions",
    "ResizeNearestNeighborOptions",
    "LeakyReluOptions",
    "SquaredDifferenceOptions",
    "MirrorPadOptions",
    "AbsOptions",
    "SplitVOptions",
    "UniqueOptions",
    "ReverseV2Options",
    "AddNOptions",
    "GatherNdOptions",
    "CosOptions",
    "WhereOptions",
    "RankOptions",
    "ReverseSequenceOptions",
    "MatrixDiagOptions",
    "QuantizeOptions",
    "MatrixSetDiagOptions",
    "HardSwishOptions",
    "IfOptions",
    "WhileOptions",
    "DepthToSpaceOptions",
    "NonMaxSuppressionV4Options",
    "NonMaxSuppressionV5Options",
    "ScatterNdOptions",
    "SelectV2Options",
    "DensifyOptions",
    "SegmentSumOptions",
    "BatchMatMulOptions",
    "CumsumOptions",
    "CallOnceOptions",
    "BroadcastToOptions",
    "Rfft2dOptions",
    "Conv3DOptions",
    "HashtableOptions",
    "HashtableFindOptions",
    "HashtableImportOptions",
    "HashtableSizeOptions",
    "VarHandleOptions",
    "ReadVariableOptions",
    "AssignVariableOptions",
    "RandomOptions",
    "BucketizeOptions",
    "GeluOptions",
    "DynamicUpdateSliceOptions",
    "UnsortedSegmentProdOptions",
    "UnsortedSegmentMaxOptions",
    "UnsortedSegmentMinOptions",
    "UnsortedSegmentSumOptions",
    "ATan2Options",
    "SignOptions",
    "BitcastOptions",
    "BitwiseXorOptions",
    "RightShiftOptions",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOptions(BuiltinOptions e) {
  if (e < BuiltinOptions_NONE || e > BuiltinOptions_RightShiftOptions) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesBuiltinOptions()[index];
}

template<typename T> struct BuiltinOptionsTraits {
  static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template<> struct BuiltinOptionsTraits<Conv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template<> struct BuiltinOptionsTraits<DepthwiseConv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template<> struct BuiltinOptionsTraits<ConcatEmbeddingsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template<> struct BuiltinOptionsTraits<LSHProjectionOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template<> struct BuiltinOptionsTraits<Pool2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template<> struct BuiltinOptionsTraits<SVDFOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template<> struct BuiltinOptionsTraits<RNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template<> struct BuiltinOptionsTraits<FullyConnectedOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template<> struct BuiltinOptionsTraits<SoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<ConcatenationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template<> struct BuiltinOptionsTraits<AddOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template<> struct BuiltinOptionsTraits<L2NormOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template<> struct BuiltinOptionsTraits<LocalResponseNormalizationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template<> struct BuiltinOptionsTraits<LSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template<> struct BuiltinOptionsTraits<ResizeBilinearOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template<> struct BuiltinOptionsTraits<CallOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template<> struct BuiltinOptionsTraits<ReshapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template<> struct BuiltinOptionsTraits<SkipGramOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template<> struct BuiltinOptionsTraits<SpaceToDepthOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template<> struct BuiltinOptionsTraits<EmbeddingLookupSparseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template<> struct BuiltinOptionsTraits<MulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template<> struct BuiltinOptionsTraits<PadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template<> struct BuiltinOptionsTraits<GatherOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template<> struct BuiltinOptionsTraits<BatchToSpaceNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template<> struct BuiltinOptionsTraits<SpaceToBatchNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template<> struct BuiltinOptionsTraits<TransposeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template<> struct BuiltinOptionsTraits<ReducerOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template<> struct BuiltinOptionsTraits<SubOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template<> struct BuiltinOptionsTraits<DivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template<> struct BuiltinOptionsTraits<SqueezeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template<> struct BuiltinOptionsTraits<SequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<StridedSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template<> struct BuiltinOptionsTraits<ExpOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template<> struct BuiltinOptionsTraits<TopKV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template<> struct BuiltinOptionsTraits<SplitOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template<> struct BuiltinOptionsTraits<LogSoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<CastOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template<> struct BuiltinOptionsTraits<DequantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template<> struct BuiltinOptionsTraits<MaximumMinimumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template<> struct BuiltinOptionsTraits<ArgMaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template<> struct BuiltinOptionsTraits<LessOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template<> struct BuiltinOptionsTraits<NegOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template<> struct BuiltinOptionsTraits<PadV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template<> struct BuiltinOptionsTraits<GreaterOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template<> struct BuiltinOptionsTraits<GreaterEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template<> struct BuiltinOptionsTraits<LessEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template<> struct BuiltinOptionsTraits<SelectOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template<> struct BuiltinOptionsTraits<SliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template<> struct BuiltinOptionsTraits<TransposeConvOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template<> struct BuiltinOptionsTraits<SparseToDenseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template<> struct BuiltinOptionsTraits<TileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template<> struct BuiltinOptionsTraits<ExpandDimsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template<> struct BuiltinOptionsTraits<EqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template<> struct BuiltinOptionsTraits<NotEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template<> struct BuiltinOptionsTraits<ShapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template<> struct BuiltinOptionsTraits<PowOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template<> struct BuiltinOptionsTraits<ArgMinOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template<> struct BuiltinOptionsTraits<FakeQuantOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template<> struct BuiltinOptionsTraits<PackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template<> struct BuiltinOptionsTraits<LogicalOrOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template<> struct BuiltinOptionsTraits<OneHotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template<> struct BuiltinOptionsTraits<LogicalAndOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template<> struct BuiltinOptionsTraits<LogicalNotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template<> struct BuiltinOptionsTraits<UnpackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template<> struct BuiltinOptionsTraits<FloorDivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template<> struct BuiltinOptionsTraits<SquareOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template<> struct BuiltinOptionsTraits<ZerosLikeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template<> struct BuiltinOptionsTraits<FillOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template<> struct BuiltinOptionsTraits<BidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<BidirectionalSequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<UnidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<FloorModOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template<> struct BuiltinOptionsTraits<RangeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template<> struct BuiltinOptionsTraits<ResizeNearestNeighborOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeNearestNeighborOptions;
};

template<> struct BuiltinOptionsTraits<LeakyReluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template<> struct BuiltinOptionsTraits<SquaredDifferenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquaredDifferenceOptions;
};

template<> struct BuiltinOptionsTraits<MirrorPadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template<> struct BuiltinOptionsTraits<AbsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template<> struct BuiltinOptionsTraits<SplitVOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

template<> struct BuiltinOptionsTraits<UniqueOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UniqueOptions;
};

template<> struct BuiltinOptionsTraits<ReverseV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseV2Options;
};

template<> struct BuiltinOptionsTraits<AddNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddNOptions;
};

template<> struct BuiltinOptionsTraits<GatherNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherNdOptions;
};

template<> struct BuiltinOptionsTraits<CosOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CosOptions;
};

template<> struct BuiltinOptionsTraits<WhereOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhereOptions;
};

template<> struct BuiltinOptionsTraits<RankOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RankOptions;
};

template<> struct BuiltinOptionsTraits<ReverseSequenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseSequenceOptions;
};

template<> struct BuiltinOptionsTraits<MatrixDiagOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixDiagOptions;
};

template<> struct BuiltinOptionsTraits<QuantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_QuantizeOptions;
};

template<> struct BuiltinOptionsTraits<MatrixSetDiagOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixSetDiagOptions;
};

template<> struct BuiltinOptionsTraits<HardSwishOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HardSwishOptions;
};

template<> struct BuiltinOptionsTraits<IfOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_IfOptions;
};

template<> struct BuiltinOptionsTraits<WhileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhileOptions;
};

template<> struct BuiltinOptionsTraits<DepthToSpaceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthToSpaceOptions;
};

template<> struct BuiltinOptionsTraits<NonMaxSuppressionV4Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV4Options;
};

template<> struct BuiltinOptionsTraits<NonMaxSuppressionV5Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV5Options;
};

template<> struct BuiltinOptionsTraits<ScatterNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ScatterNdOptions;
};

template<> struct BuiltinOptionsTraits<SelectV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectV2Options;
};

template<> struct BuiltinOptionsTraits<DensifyOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DensifyOptions;
};

template<> struct BuiltinOptionsTraits<SegmentSumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SegmentSumOptions;
};

template<> struct BuiltinOptionsTraits<BatchMatMulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchMatMulOptions;
};

template<> struct BuiltinOptionsTraits<CumsumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CumsumOptions;
};

template<> struct BuiltinOptionsTraits<CallOnceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOnceOptions;
};

template<> struct BuiltinOptionsTraits<BroadcastToOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BroadcastToOptions;
};

template<> struct BuiltinOptionsTraits<Rfft2dOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Rfft2dOptions;
};

template<> struct BuiltinOptionsTraits<Conv3DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv3DOptions;
};

template<> struct BuiltinOptionsTraits<HashtableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableOptions;
};

template<> struct BuiltinOptionsTraits<HashtableFindOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableFindOptions;
};

template<> struct BuiltinOptionsTraits<HashtableImportOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableImportOptions;
};

template<> struct BuiltinOptionsTraits<HashtableSizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableSizeOptions;
};

template<> struct BuiltinOptionsTraits<VarHandleOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_VarHandleOptions;
};

template<> struct BuiltinOptionsTraits<ReadVariableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReadVariableOptions;
};

template<> struct BuiltinOptionsTraits<AssignVariableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AssignVariableOptions;
};

template<> struct BuiltinOptionsTraits<RandomOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RandomOptions;
};

template<> struct BuiltinOptionsTraits<BucketizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BucketizeOptions;
};

template<> struct BuiltinOptionsTraits<GeluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GeluOptions;
};

template<> struct BuiltinOptionsTraits<DynamicUpdateSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DynamicUpdateSliceOptions;
};

template<> struct BuiltinOptionsTraits<UnsortedSegmentProdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentProdOptions;
};

template<> struct BuiltinOptionsTraits<UnsortedSegmentMaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentMaxOptions;
};

template<> struct BuiltinOptionsTraits<UnsortedSegmentMinOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentMinOptions;
};

template<> struct BuiltinOptionsTraits<UnsortedSegmentSumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentSumOptions;
};

template<> struct BuiltinOptionsTraits<ATan2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_ATan2Options;
};

template<> struct BuiltinOptionsTraits<SignOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SignOptions;
};

template<> struct BuiltinOptionsTraits<BitcastOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BitcastOptions;
};

template<> struct BuiltinOptionsTraits<BitwiseXorOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BitwiseXorOptions;
};

template<> struct BuiltinOptionsTraits<RightShiftOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RightShiftOptions;
};

struct BuiltinOptionsUnion {
  BuiltinOptions type;
  void *value;

  BuiltinOptionsUnion() : type(BuiltinOptions_NONE), value(nullptr) {}
  BuiltinOptionsUnion(BuiltinOptionsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(BuiltinOptions_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BuiltinOptionsUnion(const BuiltinOptionsUnion &) FLATBUFFERS_NOEXCEPT;
  BuiltinOptionsUnion &operator=(const BuiltinOptionsUnion &u) FLATBUFFERS_NOEXCEPT
    { BuiltinOptionsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BuiltinOptionsUnion &operator=(BuiltinOptionsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BuiltinOptionsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = BuiltinOptionsTraits<typename T::TableType>::enum_value;
    if (type != BuiltinOptions_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, BuiltinOptions type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Conv2DOptionsT *AsConv2DOptions() {
    return type == BuiltinOptions_Conv2DOptions ?
      reinterpret_cast<Conv2DOptionsT *>(value) : nullptr;
  }
  const Conv2DOptionsT *AsConv2DOptions() const {
    return type == BuiltinOptions_Conv2DOptions ?
      reinterpret_cast<const Conv2DOptionsT *>(value) : nullptr;
  }
  DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() {
    return type == BuiltinOptions_DepthwiseConv2DOptions ?
      reinterpret_cast<DepthwiseConv2DOptionsT *>(value) : nullptr;
  }
  const DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() const {
    return type == BuiltinOptions_DepthwiseConv2DOptions ?
      reinterpret_cast<const DepthwiseConv2DOptionsT *>(value) : nullptr;
  }
  ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() {
    return type == BuiltinOptions_ConcatEmbeddingsOptions ?
      reinterpret_cast<ConcatEmbeddingsOptionsT *>(value) : nullptr;
  }
  const ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() const {
    return type == BuiltinOptions_ConcatEmbeddingsOptions ?
      reinterpret_cast<const ConcatEmbeddingsOptionsT *>(value) : nullptr;
  }
  LSHProjectionOptionsT *AsLSHProjectionOptions() {
    return type == BuiltinOptions_LSHProjectionOptions ?
      reinterpret_cast<LSHProjectionOptionsT *>(value) : nullptr;
  }
  const LSHProjectionOptionsT *AsLSHProjectionOptions() const {
    return type == BuiltinOptions_LSHProjectionOptions ?
      reinterpret_cast<const LSHProjectionOptionsT *>(value) : nullptr;
  }
  Pool2DOptionsT *AsPool2DOptions() {
    return type == BuiltinOptions_Pool2DOptions ?
      reinterpret_cast<Pool2DOptionsT *>(value) : nullptr;
  }
  const Pool2DOptionsT *AsPool2DOptions() const {
    return type == BuiltinOptions_Pool2DOptions ?
      reinterpret_cast<const Pool2DOptionsT *>(value) : nullptr;
  }
  SVDFOptionsT *AsSVDFOptions() {
    return type == BuiltinOptions_SVDFOptions ?
      reinterpret_cast<SVDFOptionsT *>(value) : nullptr;
  }
  const SVDFOptionsT *AsSVDFOptions() const {
    return type == BuiltinOptions_SVDFOptions ?
      reinterpret_cast<const SVDFOptionsT *>(value) : nullptr;
  }
  RNNOptionsT *AsRNNOptions() {
    return type == BuiltinOptions_RNNOptions ?
      reinterpret_cast<RNNOptionsT *>(value) : nullptr;
  }
  const RNNOptionsT *AsRNNOptions() const {
    return type == BuiltinOptions_RNNOptions ?
      reinterpret_cast<const RNNOptionsT *>(value) : nullptr;
  }
  FullyConnectedOptionsT *AsFullyConnectedOptions() {
    return type == BuiltinOptions_FullyConnectedOptions ?
      reinterpret_cast<FullyConnectedOptionsT *>(value) : nullptr;
  }
  const FullyConnectedOptionsT *AsFullyConnectedOptions() const {
    return type == BuiltinOptions_FullyConnectedOptions ?
      reinterpret_cast<const FullyConnectedOptionsT *>(value) : nullptr;
  }
  SoftmaxOptionsT *AsSoftmaxOptions() {
    return type == BuiltinOptions_SoftmaxOptions ?
      reinterpret_cast<SoftmaxOptionsT *>(value) : nullptr;
  }
  const SoftmaxOptionsT *AsSoftmaxOptions() const {
    return type == BuiltinOptions_SoftmaxOptions ?
      reinterpret_cast<const SoftmaxOptionsT *>(value) : nullptr;
  }
  ConcatenationOptionsT *AsConcatenationOptions() {
    return type == BuiltinOptions_ConcatenationOptions ?
      reinterpret_cast<ConcatenationOptionsT *>(value) : nullptr;
  }
  const ConcatenationOptionsT *AsConcatenationOptions() const {
    return type == BuiltinOptions_ConcatenationOptions ?
      reinterpret_cast<const ConcatenationOptionsT *>(value) : nullptr;
  }
  AddOptionsT *AsAddOptions() {
    return type == BuiltinOptions_AddOptions ?
      reinterpret_cast<AddOptionsT *>(value) : nullptr;
  }
  const AddOptionsT *AsAddOptions() const {
    return type == BuiltinOptions_AddOptions ?
      reinterpret_cast<const AddOptionsT *>(value) : nullptr;
  }
  L2NormOptionsT *AsL2NormOptions() {
    return type == BuiltinOptions_L2NormOptions ?
      reinterpret_cast<L2NormOptionsT *>(value) : nullptr;
  }
  const L2NormOptionsT *AsL2NormOptions() const {
    return type == BuiltinOptions_L2NormOptions ?
      reinterpret_cast<const L2NormOptionsT *>(value) : nullptr;
  }
  LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() {
    return type == BuiltinOptions_LocalResponseNormalizationOptions ?
      reinterpret_cast<LocalResponseNormalizationOptionsT *>(value) : nullptr;
  }
  const LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() const {
    return type == BuiltinOptions_LocalResponseNormalizationOptions ?
      reinterpret_cast<const LocalResponseNormalizationOptionsT *>(value) : nullptr;
  }
  LSTMOptionsT *AsLSTMOptions() {
    return type == BuiltinOptions_LSTMOptions ?
      reinterpret_cast<LSTMOptionsT *>(value) : nullptr;
  }
  const LSTMOptionsT *AsLSTMOptions() const {
    return type == BuiltinOptions_LSTMOptions ?
      reinterpret_cast<const LSTMOptionsT *>(value) : nullptr;
  }
  ResizeBilinearOptionsT *AsResizeBilinearOptions() {
    return type == BuiltinOptions_ResizeBilinearOptions ?
      reinterpret_cast<ResizeBilinearOptionsT *>(value) : nullptr;
  }
  const ResizeBilinearOptionsT *AsResizeBilinearOptions() const {
    return type == BuiltinOptions_ResizeBilinearOptions ?
      reinterpret_cast<const ResizeBilinearOptionsT *>(value) : nullptr;
  }
  CallOptionsT *AsCallOptions() {
    return type == BuiltinOptions_CallOptions ?
      reinterpret_cast<CallOptionsT *>(value) : nullptr;
  }
  const CallOptionsT *AsCallOptions() const {
    return type == BuiltinOptions_CallOptions ?
      reinterpret_cast<const CallOptionsT *>(value) : nullptr;
  }
  ReshapeOptionsT *AsReshapeOptions() {
    return type == BuiltinOptions_ReshapeOptions ?
      reinterpret_cast<ReshapeOptionsT *>(value) : nullptr;
  }
  const ReshapeOptionsT *AsReshapeOptions() const {
    return type == BuiltinOptions_ReshapeOptions ?
      reinterpret_cast<const ReshapeOptionsT *>(value) : nullptr;
  }
  SkipGramOptionsT *AsSkipGramOptions() {
    return type == BuiltinOptions_SkipGramOptions ?
      reinterpret_cast<SkipGramOptionsT *>(value) : nullptr;
  }
  const SkipGramOptionsT *AsSkipGramOptions() const {
    return type == BuiltinOptions_SkipGramOptions ?
      reinterpret_cast<const SkipGramOptionsT *>(value) : nullptr;
  }
  SpaceToDepthOptionsT *AsSpaceToDepthOptions() {
    return type == BuiltinOptions_SpaceToDepthOptions ?
      reinterpret_cast<SpaceToDepthOptionsT *>(value) : nullptr;
  }
  const SpaceToDepthOptionsT *AsSpaceToDepthOptions() const {
    return type == BuiltinOptions_SpaceToDepthOptions ?
      reinterpret_cast<const SpaceToDepthOptionsT *>(value) : nullptr;
  }
  EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() {
    return type == BuiltinOptions_EmbeddingLookupSparseOptions ?
      reinterpret_cast<EmbeddingLookupSparseOptionsT *>(value) : nullptr;
  }
  const EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() const {
    return type == BuiltinOptions_EmbeddingLookupSparseOptions ?
      reinterpret_cast<const EmbeddingLookupSparseOptionsT *>(value) : nullptr;
  }
  MulOptionsT *AsMulOptions() {
    return type == BuiltinOptions_MulOptions ?
      reinterpret_cast<MulOptionsT *>(value) : nullptr;
  }
  const MulOptionsT *AsMulOptions() const {
    return type == BuiltinOptions_MulOptions ?
      reinterpret_cast<const MulOptionsT *>(value) : nullptr;
  }
  PadOptionsT *AsPadOptions() {
    return type == BuiltinOptions_PadOptions ?
      reinterpret_cast<PadOptionsT *>(value) : nullptr;
  }
  const PadOptionsT *AsPadOptions() const {
    return type == BuiltinOptions_PadOptions ?
      reinterpret_cast<const PadOptionsT *>(value) : nullptr;
  }
  GatherOptionsT *AsGatherOptions() {
    return type == BuiltinOptions_GatherOptions ?
      reinterpret_cast<GatherOptionsT *>(value) : nullptr;
  }
  const GatherOptionsT *AsGatherOptions() const {
    return type == BuiltinOptions_GatherOptions ?
      reinterpret_cast<const GatherOptionsT *>(value) : nullptr;
  }
  BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() {
    return type == BuiltinOptions_BatchToSpaceNDOptions ?
      reinterpret_cast<BatchToSpaceNDOptionsT *>(value) : nullptr;
  }
  const BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() const {
    return type == BuiltinOptions_BatchToSpaceNDOptions ?
      reinterpret_cast<const BatchToSpaceNDOptionsT *>(value) : nullptr;
  }
  SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() {
    return type == BuiltinOptions_SpaceToBatchNDOptions ?
      reinterpret_cast<SpaceToBatchNDOptionsT *>(value) : nullptr;
  }
  const SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() const {
    return type == BuiltinOptions_SpaceToBatchNDOptions ?
      reinterpret_cast<const SpaceToBatchNDOptionsT *>(value) : nullptr;
  }
  TransposeOptionsT *AsTransposeOptions() {
    return type == BuiltinOptions_TransposeOptions ?
      reinterpret_cast<TransposeOptionsT *>(value) : nullptr;
  }
  const TransposeOptionsT *AsTransposeOptions() const {
    return type == BuiltinOptions_TransposeOptions ?
      reinterpret_cast<const TransposeOptionsT *>(value) : nullptr;
  }
  ReducerOptionsT *AsReducerOptions() {
    return type == BuiltinOptions_ReducerOptions ?
      reinterpret_cast<ReducerOptionsT *>(value) : nullptr;
  }
  const ReducerOptionsT *AsReducerOptions() const {
    return type == BuiltinOptions_ReducerOptions ?
      reinterpret_cast<const ReducerOptionsT *>(value) : nullptr;
  }
  SubOptionsT *AsSubOptions() {
    return type == BuiltinOptions_SubOptions ?
      reinterpret_cast<SubOptionsT *>(value) : nullptr;
  }
  const SubOptionsT *AsSubOptions() const {
    return type == BuiltinOptions_SubOptions ?
      reinterpret_cast<const SubOptionsT *>(value) : nullptr;
  }
  DivOptionsT *AsDivOptions() {
    return type == BuiltinOptions_DivOptions ?
      reinterpret_cast<DivOptionsT *>(value) : nullptr;
  }
  const DivOptionsT *AsDivOptions() const {
    return type == BuiltinOptions_DivOptions ?
      reinterpret_cast<const DivOptionsT *>(value) : nullptr;
  }
  SqueezeOptionsT *AsSqueezeOptions() {
    return type == BuiltinOptions_SqueezeOptions ?
      reinterpret_cast<SqueezeOptionsT *>(value) : nullptr;
  }
  const SqueezeOptionsT *AsSqueezeOptions() const {
    return type == BuiltinOptions_SqueezeOptions ?
      reinterpret_cast<const SqueezeOptionsT *>(value) : nullptr;
  }
  SequenceRNNOptionsT *AsSequenceRNNOptions() {
    return type == BuiltinOptions_SequenceRNNOptions ?
      reinterpret_cast<SequenceRNNOptionsT *>(value) : nullptr;
  }
  const SequenceRNNOptionsT *AsSequenceRNNOptions() const {
    return type == BuiltinOptions_SequenceRNNOptions ?
      reinterpret_cast<const SequenceRNNOptionsT *>(value) : nullptr;
  }
  StridedSliceOptionsT *AsStridedSliceOptions() {
    return type == BuiltinOptions_StridedSliceOptions ?
      reinterpret_cast<StridedSliceOptionsT *>(value) : nullptr;
  }
  const StridedSliceOptionsT *AsStridedSliceOptions() const {
    return type == BuiltinOptions_StridedSliceOptions ?
      reinterpret_cast<const StridedSliceOptionsT *>(value) : nullptr;
  }
  ExpOptionsT *AsExpOptions() {
    return type == BuiltinOptions_ExpOptions ?
      reinterpret_cast<ExpOptionsT *>(value) : nullptr;
  }
  const ExpOptionsT *AsExpOptions() const {
    return type == BuiltinOptions_ExpOptions ?
      reinterpret_cast<const ExpOptionsT *>(value) : nullptr;
  }
  TopKV2OptionsT *AsTopKV2Options() {
    return type == BuiltinOptions_TopKV2Options ?
      reinterpret_cast<TopKV2OptionsT *>(value) : nullptr;
  }
  const TopKV2OptionsT *AsTopKV2Options() const {
    return type == BuiltinOptions_TopKV2Options ?
      reinterpret_cast<const TopKV2OptionsT *>(value) : nullptr;
  }
  SplitOptionsT *AsSplitOptions() {
    return type == BuiltinOptions_SplitOptions ?
      reinterpret_cast<SplitOptionsT *>(value) : nullptr;
  }
  const SplitOptionsT *AsSplitOptions() const {
    return type == BuiltinOptions_SplitOptions ?
      reinterpret_cast<const SplitOptionsT *>(value) : nullptr;
  }
  LogSoftmaxOptionsT *AsLogSoftmaxOptions() {
    return type == BuiltinOptions_LogSoftmaxOptions ?
      reinterpret_cast<LogSoftmaxOptionsT *>(value) : nullptr;
  }
  const LogSoftmaxOptionsT *AsLogSoftmaxOptions() const {
    return type == BuiltinOptions_LogSoftmaxOptions ?
      reinterpret_cast<const LogSoftmaxOptionsT *>(value) : nullptr;
  }
  CastOptionsT *AsCastOptions() {
    return type == BuiltinOptions_CastOptions ?
      reinterpret_cast<CastOptionsT *>(value) : nullptr;
  }
  const CastOptionsT *AsCastOptions() const {
    return type == BuiltinOptions_CastOptions ?
      reinterpret_cast<const CastOptionsT *>(value) : nullptr;
  }
  DequantizeOptionsT *AsDequantizeOptions() {
    return type == BuiltinOptions_DequantizeOptions ?
      reinterpret_cast<DequantizeOptionsT *>(value) : nullptr;
  }
  const DequantizeOptionsT *AsDequantizeOptions() const {
    return type == BuiltinOptions_DequantizeOptions ?
      reinterpret_cast<const DequantizeOptionsT *>(value) : nullptr;
  }
  MaximumMinimumOptionsT *AsMaximumMinimumOptions() {
    return type == BuiltinOptions_MaximumMinimumOptions ?
      reinterpret_cast<MaximumMinimumOptionsT *>(value) : nullptr;
  }
  const MaximumMinimumOptionsT *AsMaximumMinimumOptions() const {
    return type == BuiltinOptions_MaximumMinimumOptions ?
      reinterpret_cast<const MaximumMinimumOptionsT *>(value) : nullptr;
  }
  ArgMaxOptionsT *AsArgMaxOptions() {
    return type == BuiltinOptions_ArgMaxOptions ?
      reinterpret_cast<ArgMaxOptionsT *>(value) : nullptr;
  }
  const ArgMaxOptionsT *AsArgMaxOptions() const {
    return type == BuiltinOptions_ArgMaxOptions ?
      reinterpret_cast<const ArgMaxOptionsT *>(value) : nullptr;
  }
  LessOptionsT *AsLessOptions() {
    return type == BuiltinOptions_LessOptions ?
      reinterpret_cast<LessOptionsT *>(value) : nullptr;
  }
  const LessOptionsT *AsLessOptions() const {
    return type == BuiltinOptions_LessOptions ?
      reinterpret_cast<const LessOptionsT *>(value) : nullptr;
  }
  NegOptionsT *AsNegOptions() {
    return type == BuiltinOptions_NegOptions ?
      reinterpret_cast<NegOptionsT *>(value) : nullptr;
  }
  const NegOptionsT *AsNegOptions() const {
    return type == BuiltinOptions_NegOptions ?
      reinterpret_cast<const NegOptionsT *>(value) : nullptr;
  }
  PadV2OptionsT *AsPadV2Options() {
    return type == BuiltinOptions_PadV2Options ?
      reinterpret_cast<PadV2OptionsT *>(value) : nullptr;
  }
  const PadV2OptionsT *AsPadV2Options() const {
    return type == BuiltinOptions_PadV2Options ?
      reinterpret_cast<const PadV2OptionsT *>(value) : nullptr;
  }
  GreaterOptionsT *AsGreaterOptions() {
    return type == BuiltinOptions_GreaterOptions ?
      reinterpret_cast<GreaterOptionsT *>(value) : nullptr;
  }
  const GreaterOptionsT *AsGreaterOptions() const {
    return type == BuiltinOptions_GreaterOptions ?
      reinterpret_cast<const GreaterOptionsT *>(value) : nullptr;
  }
  GreaterEqualOptionsT *AsGreaterEqualOptions() {
    return type == BuiltinOptions_GreaterEqualOptions ?
      reinterpret_cast<GreaterEqualOptionsT *>(value) : nullptr;
  }
  const GreaterEqualOptionsT *AsGreaterEqualOptions() const {
    return type == BuiltinOptions_GreaterEqualOptions ?
      reinterpret_cast<const GreaterEqualOptionsT *>(value) : nullptr;
  }
  LessEqualOptionsT *AsLessEqualOptions() {
    return type == BuiltinOptions_LessEqualOptions ?
      reinterpret_cast<LessEqualOptionsT *>(value) : nullptr;
  }
  const LessEqualOptionsT *AsLessEqualOptions() const {
    return type == BuiltinOptions_LessEqualOptions ?
      reinterpret_cast<const LessEqualOptionsT *>(value) : nullptr;
  }
  SelectOptionsT *AsSelectOptions() {
    return type == BuiltinOptions_SelectOptions ?
      reinterpret_cast<SelectOptionsT *>(value) : nullptr;
  }
  const SelectOptionsT *AsSelectOptions() const {
    return type == BuiltinOptions_SelectOptions ?
      reinterpret_cast<const SelectOptionsT *>(value) : nullptr;
  }
  SliceOptionsT *AsSliceOptions() {
    return type == BuiltinOptions_SliceOptions ?
      reinterpret_cast<SliceOptionsT *>(value) : nullptr;
  }
  const SliceOptionsT *AsSliceOptions() const {
    return type == BuiltinOptions_SliceOptions ?
      reinterpret_cast<const SliceOptionsT *>(value) : nullptr;
  }
  TransposeConvOptionsT *AsTransposeConvOptions() {
    return type == BuiltinOptions_TransposeConvOptions ?
      reinterpret_cast<TransposeConvOptionsT *>(value) : nullptr;
  }
  const TransposeConvOptionsT *AsTransposeConvOptions() const {
    return type == BuiltinOptions_TransposeConvOptions ?
      reinterpret_cast<const TransposeConvOptionsT *>(value) : nullptr;
  }
  SparseToDenseOptionsT *AsSparseToDenseOptions() {
    return type == BuiltinOptions_SparseToDenseOptions ?
      reinterpret_cast<SparseToDenseOptionsT *>(value) : nullptr;
  }
  const SparseToDenseOptionsT *AsSparseToDenseOptions() const {
    return type == BuiltinOptions_SparseToDenseOptions ?
      reinterpret_cast<const SparseToDenseOptionsT *>(value) : nullptr;
  }
  TileOptionsT *AsTileOptions() {
    return type == BuiltinOptions_TileOptions ?
      reinterpret_cast<TileOptionsT *>(value) : nullptr;
  }
  const TileOptionsT *AsTileOptions() const {
    return type == BuiltinOptions_TileOptions ?
      reinterpret_cast<const TileOptionsT *>(value) : nullptr;
  }
  ExpandDimsOptionsT *AsExpandDimsOptions() {
    return type == BuiltinOptions_ExpandDimsOptions ?
      reinterpret_cast<ExpandDimsOptionsT *>(value) : nullptr;
  }
  const ExpandDimsOptionsT *AsExpandDimsOptions() const {
    return type == BuiltinOptions_ExpandDimsOptions ?
      reinterpret_cast<const ExpandDimsOptionsT *>(value) : nullptr;
  }
  EqualOptionsT *AsEqualOptions() {
    return type == BuiltinOptions_EqualOptions ?
      reinterpret_cast<EqualOptionsT *>(value) : nullptr;
  }
  const EqualOptionsT *AsEqualOptions() const {
    return type == BuiltinOptions_EqualOptions ?
      reinterpret_cast<const EqualOptionsT *>(value) : nullptr;
  }
  NotEqualOptionsT *AsNotEqualOptions() {
    return type == BuiltinOptions_NotEqualOptions ?
      reinterpret_cast<NotEqualOptionsT *>(value) : nullptr;
  }
  const NotEqualOptionsT *AsNotEqualOptions() const {
    return type == BuiltinOptions_NotEqualOptions ?
      reinterpret_cast<const NotEqualOptionsT *>(value) : nullptr;
  }
  ShapeOptionsT *AsShapeOptions() {
    return type == BuiltinOptions_ShapeOptions ?
      reinterpret_cast<ShapeOptionsT *>(value) : nullptr;
  }
  const ShapeOptionsT *AsShapeOptions() const {
    return type == BuiltinOptions_ShapeOptions ?
      reinterpret_cast<const ShapeOptionsT *>(value) : nullptr;
  }
  PowOptionsT *AsPowOptions() {
    return type == BuiltinOptions_PowOptions ?
      reinterpret_cast<PowOptionsT *>(value) : nullptr;
  }
  const PowOptionsT *AsPowOptions() const {
    return type == BuiltinOptions_PowOptions ?
      reinterpret_cast<const PowOptionsT *>(value) : nullptr;
  }
  ArgMinOptionsT *AsArgMinOptions() {
    return type == BuiltinOptions_ArgMinOptions ?
      reinterpret_cast<ArgMinOptionsT *>(value) : nullptr;
  }
  const ArgMinOptionsT *AsArgMinOptions() const {
    return type == BuiltinOptions_ArgMinOptions ?
      reinterpret_cast<const ArgMinOptionsT *>(value) : nullptr;
  }
  FakeQuantOptionsT *AsFakeQuantOptions() {
    return type == BuiltinOptions_FakeQuantOptions ?
      reinterpret_cast<FakeQuantOptionsT *>(value) : nullptr;
  }
  const FakeQuantOptionsT *AsFakeQuantOptions() const {
    return type == BuiltinOptions_FakeQuantOptions ?
      reinterpret_cast<const FakeQuantOptionsT *>(value) : nullptr;
  }
  PackOptionsT *AsPackOptions() {
    return type == BuiltinOptions_PackOptions ?
      reinterpret_cast<PackOptionsT *>(value) : nullptr;
  }
  const PackOptionsT *AsPackOptions() const {
    return type == BuiltinOptions_PackOptions ?
      reinterpret_cast<const PackOptionsT *>(value) : nullptr;
  }
  LogicalOrOptionsT *AsLogicalOrOptions() {
    return type == BuiltinOptions_LogicalOrOptions ?
      reinterpret_cast<LogicalOrOptionsT *>(value) : nullptr;
  }
  const LogicalOrOptionsT *AsLogicalOrOptions() const {
    return type == BuiltinOptions_LogicalOrOptions ?
      reinterpret_cast<const LogicalOrOptionsT *>(value) : nullptr;
  }
  OneHotOptionsT *AsOneHotOptions() {
    return type == BuiltinOptions_OneHotOptions ?
      reinterpret_cast<OneHotOptionsT *>(value) : nullptr;
  }
  const OneHotOptionsT *AsOneHotOptions() const {
    return type == BuiltinOptions_OneHotOptions ?
      reinterpret_cast<const OneHotOptionsT *>(value) : nullptr;
  }
  LogicalAndOptionsT *AsLogicalAndOptions() {
    return type == BuiltinOptions_LogicalAndOptions ?
      reinterpret_cast<LogicalAndOptionsT *>(value) : nullptr;
  }
  const LogicalAndOptionsT *AsLogicalAndOptions() const {
    return type == BuiltinOptions_LogicalAndOptions ?
      reinterpret_cast<const LogicalAndOptionsT *>(value) : nullptr;
  }
  LogicalNotOptionsT *AsLogicalNotOptions() {
    return type == BuiltinOptions_LogicalNotOptions ?
      reinterpret_cast<LogicalNotOptionsT *>(value) : nullptr;
  }
  const LogicalNotOptionsT *AsLogicalNotOptions() const {
    return type == BuiltinOptions_LogicalNotOptions ?
      reinterpret_cast<const LogicalNotOptionsT *>(value) : nullptr;
  }
  UnpackOptionsT *AsUnpackOptions() {
    return type == BuiltinOptions_UnpackOptions ?
      reinterpret_cast<UnpackOptionsT *>(value) : nullptr;
  }
  const UnpackOptionsT *AsUnpackOptions() const {
    return type == BuiltinOptions_UnpackOptions ?
      reinterpret_cast<const UnpackOptionsT *>(value) : nullptr;
  }
  FloorDivOptionsT *AsFloorDivOptions() {
    return type == BuiltinOptions_FloorDivOptions ?
      reinterpret_cast<FloorDivOptionsT *>(value) : nullptr;
  }
  const FloorDivOptionsT *AsFloorDivOptions() const {
    return type == BuiltinOptions_FloorDivOptions ?
      reinterpret_cast<const FloorDivOptionsT *>(value) : nullptr;
  }
  SquareOptionsT *AsSquareOptions() {
    return type == BuiltinOptions_SquareOptions ?
      reinterpret_cast<SquareOptionsT *>(value) : nullptr;
  }
  const SquareOptionsT *AsSquareOptions() const {
    return type == BuiltinOptions_SquareOptions ?
      reinterpret_cast<const SquareOptionsT *>(value) : nullptr;
  }
  ZerosLikeOptionsT *AsZerosLikeOptions() {
    return type == BuiltinOptions_ZerosLikeOptions ?
      reinterpret_cast<ZerosLikeOptionsT *>(value) : nullptr;
  }
  const ZerosLikeOptionsT *AsZerosLikeOptions() const {
    return type == BuiltinOptions_ZerosLikeOptions ?
      reinterpret_cast<const ZerosLikeOptionsT *>(value) : nullptr;
  }
  FillOptionsT *AsFillOptions() {
    return type == BuiltinOptions_FillOptions ?
      reinterpret_cast<FillOptionsT *>(value) : nullptr;
  }
  const FillOptionsT *AsFillOptions() const {
    return type == BuiltinOptions_FillOptions ?
      reinterpret_cast<const FillOptionsT *>(value) : nullptr;
  }
  BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() {
    return type == BuiltinOptions_BidirectionalSequenceLSTMOptions ?
      reinterpret_cast<BidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  const BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() const {
    return type == BuiltinOptions_BidirectionalSequenceLSTMOptions ?
      reinterpret_cast<const BidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() {
    return type == BuiltinOptions_BidirectionalSequenceRNNOptions ?
      reinterpret_cast<BidirectionalSequenceRNNOptionsT *>(value) : nullptr;
  }
  const BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() const {
    return type == BuiltinOptions_BidirectionalSequenceRNNOptions ?
      reinterpret_cast<const BidirectionalSequenceRNNOptionsT *>(value) : nullptr;
  }
  UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() {
    return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions ?
      reinterpret_cast<UnidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  const UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() const {
    return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions ?
      reinterpret_cast<const UnidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  FloorModOptionsT *AsFloorModOptions() {
    return type == BuiltinOptions_FloorModOptions ?
      reinterpret_cast<FloorModOptionsT *>(value) : nullptr;
  }
  const FloorModOptionsT *AsFloorModOptions() const {
    return type == BuiltinOptions_FloorModOptions ?
      reinterpret_cast<const FloorModOptionsT *>(value) : nullptr;
  }
  RangeOptionsT *AsRangeOptions() {
    return type == BuiltinOptions_RangeOptions ?
      reinterpret_cast<RangeOptionsT *>(value) : nullptr;
  }
  const RangeOptionsT *AsRangeOptions() const {
    return type == BuiltinOptions_RangeOptions ?
      reinterpret_cast<const RangeOptionsT *>(value) : nullptr;
  }
  ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() {
    return type == BuiltinOptions_ResizeNearestNeighborOptions ?
      reinterpret_cast<ResizeNearestNeighborOptionsT *>(value) : nullptr;
  }
  const ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() const {
    return type == BuiltinOptions_ResizeNearestNeighborOptions ?
      reinterpret_cast<const ResizeNearestNeighborOptionsT *>(value) : nullptr;
  }
  LeakyReluOptionsT *AsLeakyReluOptions() {
    return type == BuiltinOptions_LeakyReluOptions ?
      reinterpret_cast<LeakyReluOptionsT *>(value) : nullptr;
  }
  const LeakyReluOptionsT *AsLeakyReluOptions() const {
    return type == BuiltinOptions_LeakyReluOptions ?
      reinterpret_cast<const LeakyReluOptionsT *>(value) : nullptr;
  }
  SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() {
    return type == BuiltinOptions_SquaredDifferenceOptions ?
      reinterpret_cast<SquaredDifferenceOptionsT *>(value) : nullptr;
  }
  const SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() const {
    return type == BuiltinOptions_SquaredDifferenceOptions ?
      reinterpret_cast<const SquaredDifferenceOptionsT *>(value) : nullptr;
  }
  MirrorPadOptionsT *AsMirrorPadOptions() {
    return type == BuiltinOptions_MirrorPadOptions ?
      reinterpret_cast<MirrorPadOptionsT *>(value) : nullptr;
  }
  const MirrorPadOptionsT *AsMirrorPadOptions() const {
    return type == BuiltinOptions_MirrorPadOptions ?
      reinterpret_cast<const MirrorPadOptionsT *>(value) : nullptr;
  }
  AbsOptionsT *AsAbsOptions() {
    return type == BuiltinOptions_AbsOptions ?
      reinterpret_cast<AbsOptionsT *>(value) : nullptr;
  }
  const AbsOptionsT *AsAbsOptions() const {
    return type == BuiltinOptions_AbsOptions ?
      reinterpret_cast<const AbsOptionsT *>(value) : nullptr;
  }
  SplitVOptionsT *AsSplitVOptions() {
    return type == BuiltinOptions_SplitVOptions ?
      reinterpret_cast<SplitVOptionsT *>(value) : nullptr;
  }
  const SplitVOptionsT *AsSplitVOptions() const {
    return type == BuiltinOptions_SplitVOptions ?
      reinterpret_cast<const SplitVOptionsT *>(value) : nullptr;
  }
  UniqueOptionsT *AsUniqueOptions() {
    return type == BuiltinOptions_UniqueOptions ?
      reinterpret_cast<UniqueOptionsT *>(value) : nullptr;
  }
  const UniqueOptionsT *AsUniqueOptions() const {
    return type == BuiltinOptions_UniqueOptions ?
      reinterpret_cast<const UniqueOptionsT *>(value) : nullptr;
  }
  ReverseV2OptionsT *AsReverseV2Options() {
    return type == BuiltinOptions_ReverseV2Options ?
      reinterpret_cast<ReverseV2OptionsT *>(value) : nullptr;
  }
  const ReverseV2OptionsT *AsReverseV2Options() const {
    return type == BuiltinOptions_ReverseV2Options ?
      reinterpret_cast<const ReverseV2OptionsT *>(value) : nullptr;
  }
  AddNOptionsT *AsAddNOptions() {
    return type == BuiltinOptions_AddNOptions ?
      reinterpret_cast<AddNOptionsT *>(value) : nullptr;
  }
  const AddNOptionsT *AsAddNOptions() const {
    return type == BuiltinOptions_AddNOptions ?
      reinterpret_cast<const AddNOptionsT *>(value) : nullptr;
  }
  GatherNdOptionsT *AsGatherNdOptions() {
    return type == BuiltinOptions_GatherNdOptions ?
      reinterpret_cast<GatherNdOptionsT *>(value) : nullptr;
  }
  const GatherNdOptionsT *AsGatherNdOptions() const {
    return type == BuiltinOptions_GatherNdOptions ?
      reinterpret_cast<const GatherNdOptionsT *>(value) : nullptr;
  }
  CosOptionsT *AsCosOptions() {
    return type == BuiltinOptions_CosOptions ?
      reinterpret_cast<CosOptionsT *>(value) : nullptr;
  }
  const CosOptionsT *AsCosOptions() const {
    return type == BuiltinOptions_CosOptions ?
      reinterpret_cast<const CosOptionsT *>(value) : nullptr;
  }
  WhereOptionsT *AsWhereOptions() {
    return type == BuiltinOptions_WhereOptions ?
      reinterpret_cast<WhereOptionsT *>(value) : nullptr;
  }
  const WhereOptionsT *AsWhereOptions() const {
    return type == BuiltinOptions_WhereOptions ?
      reinterpret_cast<const WhereOptionsT *>(value) : nullptr;
  }
  RankOptionsT *AsRankOptions() {
    return type == BuiltinOptions_RankOptions ?
      reinterpret_cast<RankOptionsT *>(value) : nullptr;
  }
  const RankOptionsT *AsRankOptions() const {
    return type == BuiltinOptions_RankOptions ?
      reinterpret_cast<const RankOptionsT *>(value) : nullptr;
  }
  ReverseSequenceOptionsT *AsReverseSequenceOptions() {
    return type == BuiltinOptions_ReverseSequenceOptions ?
      reinterpret_cast<ReverseSequenceOptionsT *>(value) : nullptr;
  }
  const ReverseSequenceOptionsT *AsReverseSequenceOptions() const {
    return type == BuiltinOptions_ReverseSequenceOptions ?
      reinterpret_cast<const ReverseSequenceOptionsT *>(value) : nullptr;
  }
  MatrixDiagOptionsT *AsMatrixDiagOptions() {
    return type == BuiltinOptions_MatrixDiagOptions ?
      reinterpret_cast<MatrixDiagOptionsT *>(value) : nullptr;
  }
  const MatrixDiagOptionsT *AsMatrixDiagOptions() const {
    return type == BuiltinOptions_MatrixDiagOptions ?
      reinterpret_cast<const MatrixDiagOptionsT *>(value) : nullptr;
  }
  QuantizeOptionsT *AsQuantizeOptions() {
    return type == BuiltinOptions_QuantizeOptions ?
      reinterpret_cast<QuantizeOptionsT *>(value) : nullptr;
  }
  const QuantizeOptionsT *AsQuantizeOptions() const {
    return type == BuiltinOptions_QuantizeOptions ?
      reinterpret_cast<const QuantizeOptionsT *>(value) : nullptr;
  }
  MatrixSetDiagOptionsT *AsMatrixSetDiagOptions() {
    return type == BuiltinOptions_MatrixSetDiagOptions ?
      reinterpret_cast<MatrixSetDiagOptionsT *>(value) : nullptr;
  }
  const MatrixSetDiagOptionsT *AsMatrixSetDiagOptions() const {
    return type == BuiltinOptions_MatrixSetDiagOptions ?
      reinterpret_cast<const MatrixSetDiagOptionsT *>(value) : nullptr;
  }
  HardSwishOptionsT *AsHardSwishOptions() {
    return type == BuiltinOptions_HardSwishOptions ?
      reinterpret_cast<HardSwishOptionsT *>(value) : nullptr;
  }
  const HardSwishOptionsT *AsHardSwishOptions() const {
    return type == BuiltinOptions_HardSwishOptions ?
      reinterpret_cast<const HardSwishOptionsT *>(value) : nullptr;
  }
  IfOptionsT *AsIfOptions() {
    return type == BuiltinOptions_IfOptions ?
      reinterpret_cast<IfOptionsT *>(value) : nullptr;
  }
  const IfOptionsT *AsIfOptions() const {
    return type == BuiltinOptions_IfOptions ?
      reinterpret_cast<const IfOptionsT *>(value) : nullptr;
  }
  WhileOptionsT *AsWhileOptions() {
    return type == BuiltinOptions_WhileOptions ?
      reinterpret_cast<WhileOptionsT *>(value) : nullptr;
  }
  const WhileOptionsT *AsWhileOptions() const {
    return type == BuiltinOptions_WhileOptions ?
      reinterpret_cast<const WhileOptionsT *>(value) : nullptr;
  }
  DepthToSpaceOptionsT *AsDepthToSpaceOptions() {
    return type == BuiltinOptions_DepthToSpaceOptions ?
      reinterpret_cast<DepthToSpaceOptionsT *>(value) : nullptr;
  }
  const DepthToSpaceOptionsT *AsDepthToSpaceOptions() const {
    return type == BuiltinOptions_DepthToSpaceOptions ?
      reinterpret_cast<const DepthToSpaceOptionsT *>(value) : nullptr;
  }
  NonMaxSuppressionV4OptionsT *AsNonMaxSuppressionV4Options() {
    return type == BuiltinOptions_NonMaxSuppressionV4Options ?
      reinterpret_cast<NonMaxSuppressionV4OptionsT *>(value) : nullptr;
  }
  const NonMaxSuppressionV4OptionsT *AsNonMaxSuppressionV4Options() const {
    return type == BuiltinOptions_NonMaxSuppressionV4Options ?
      reinterpret_cast<const NonMaxSuppressionV4OptionsT *>(value) : nullptr;
  }
  NonMaxSuppressionV5OptionsT *AsNonMaxSuppressionV5Options() {
    return type == BuiltinOptions_NonMaxSuppressionV5Options ?
      reinterpret_cast<NonMaxSuppressionV5OptionsT *>(value) : nullptr;
  }
  const NonMaxSuppressionV5OptionsT *AsNonMaxSuppressionV5Options() const {
    return type == BuiltinOptions_NonMaxSuppressionV5Options ?
      reinterpret_cast<const NonMaxSuppressionV5OptionsT *>(value) : nullptr;
  }
  ScatterNdOptionsT *AsScatterNdOptions() {
    return type == BuiltinOptions_ScatterNdOptions ?
      reinterpret_cast<ScatterNdOptionsT *>(value) : nullptr;
  }
  const ScatterNdOptionsT *AsScatterNdOptions() const {
    return type == BuiltinOptions_ScatterNdOptions ?
      reinterpret_cast<const ScatterNdOptionsT *>(value) : nullptr;
  }
  SelectV2OptionsT *AsSelectV2Options() {
    return type == BuiltinOptions_SelectV2Options ?
      reinterpret_cast<SelectV2OptionsT *>(value) : nullptr;
  }
  const SelectV2OptionsT *AsSelectV2Options() const {
    return type == BuiltinOptions_SelectV2Options ?
      reinterpret_cast<const SelectV2OptionsT *>(value) : nullptr;
  }
  DensifyOptionsT *AsDensifyOptions() {
    return type == BuiltinOptions_DensifyOptions ?
      reinterpret_cast<DensifyOptionsT *>(value) : nullptr;
  }
  const DensifyOptionsT *AsDensifyOptions() const {
    return type == BuiltinOptions_DensifyOptions ?
      reinterpret_cast<const DensifyOptionsT *>(value) : nullptr;
  }
  SegmentSumOptionsT *AsSegmentSumOptions() {
    return type == BuiltinOptions_SegmentSumOptions ?
      reinterpret_cast<SegmentSumOptionsT *>(value) : nullptr;
  }
  const SegmentSumOptionsT *AsSegmentSumOptions() const {
    return type == BuiltinOptions_SegmentSumOptions ?
      reinterpret_cast<const SegmentSumOptionsT *>(value) : nullptr;
  }
  BatchMatMulOptionsT *AsBatchMatMulOptions() {
    return type == BuiltinOptions_BatchMatMulOptions ?
      reinterpret_cast<BatchMatMulOptionsT *>(value) : nullptr;
  }
  const BatchMatMulOptionsT *AsBatchMatMulOptions() const {
    return type == BuiltinOptions_BatchMatMulOptions ?
      reinterpret_cast<const BatchMatMulOptionsT *>(value) : nullptr;
  }
  CumsumOptionsT *AsCumsumOptions() {
    return type == BuiltinOptions_CumsumOptions ?
      reinterpret_cast<CumsumOptionsT *>(value) : nullptr;
  }
  const CumsumOptionsT *AsCumsumOptions() const {
    return type == BuiltinOptions_CumsumOptions ?
      reinterpret_cast<const CumsumOptionsT *>(value) : nullptr;
  }
  CallOnceOptionsT *AsCallOnceOptions() {
    return type == BuiltinOptions_CallOnceOptions ?
      reinterpret_cast<CallOnceOptionsT *>(value) : nullptr;
  }
  const CallOnceOptionsT *AsCallOnceOptions() const {
    return type == BuiltinOptions_CallOnceOptions ?
      reinterpret_cast<const CallOnceOptionsT *>(value) : nullptr;
  }
  BroadcastToOptionsT *AsBroadcastToOptions() {
    return type == BuiltinOptions_BroadcastToOptions ?
      reinterpret_cast<BroadcastToOptionsT *>(value) : nullptr;
  }
  const BroadcastToOptionsT *AsBroadcastToOptions() const {
    return type == BuiltinOptions_BroadcastToOptions ?
      reinterpret_cast<const BroadcastToOptionsT *>(value) : nullptr;
  }
  Rfft2dOptionsT *AsRfft2dOptions() {
    return type == BuiltinOptions_Rfft2dOptions ?
      reinterpret_cast<Rfft2dOptionsT *>(value) : nullptr;
  }
  const Rfft2dOptionsT *AsRfft2dOptions() const {
    return type == BuiltinOptions_Rfft2dOptions ?
      reinterpret_cast<const Rfft2dOptionsT *>(value) : nullptr;
  }
  Conv3DOptionsT *AsConv3DOptions() {
    return type == BuiltinOptions_Conv3DOptions ?
      reinterpret_cast<Conv3DOptionsT *>(value) : nullptr;
  }
  const Conv3DOptionsT *AsConv3DOptions() const {
    return type == BuiltinOptions_Conv3DOptions ?
      reinterpret_cast<const Conv3DOptionsT *>(value) : nullptr;
  }
  HashtableOptionsT *AsHashtableOptions() {
    return type == BuiltinOptions_HashtableOptions ?
      reinterpret_cast<HashtableOptionsT *>(value) : nullptr;
  }
  const HashtableOptionsT *AsHashtableOptions() const {
    return type == BuiltinOptions_HashtableOptions ?
      reinterpret_cast<const HashtableOptionsT *>(value) : nullptr;
  }
  HashtableFindOptionsT *AsHashtableFindOptions() {
    return type == BuiltinOptions_HashtableFindOptions ?
      reinterpret_cast<HashtableFindOptionsT *>(value) : nullptr;
  }
  const HashtableFindOptionsT *AsHashtableFindOptions() const {
    return type == BuiltinOptions_HashtableFindOptions ?
      reinterpret_cast<const HashtableFindOptionsT *>(value) : nullptr;
  }
  HashtableImportOptionsT *AsHashtableImportOptions() {
    return type == BuiltinOptions_HashtableImportOptions ?
      reinterpret_cast<HashtableImportOptionsT *>(value) : nullptr;
  }
  const HashtableImportOptionsT *AsHashtableImportOptions() const {
    return type == BuiltinOptions_HashtableImportOptions ?
      reinterpret_cast<const HashtableImportOptionsT *>(value) : nullptr;
  }
  HashtableSizeOptionsT *AsHashtableSizeOptions() {
    return type == BuiltinOptions_HashtableSizeOptions ?
      reinterpret_cast<HashtableSizeOptionsT *>(value) : nullptr;
  }
  const HashtableSizeOptionsT *AsHashtableSizeOptions() const {
    return type == BuiltinOptions_HashtableSizeOptions ?
      reinterpret_cast<const HashtableSizeOptionsT *>(value) : nullptr;
  }
  VarHandleOptionsT *AsVarHandleOptions() {
    return type == BuiltinOptions_VarHandleOptions ?
      reinterpret_cast<VarHandleOptionsT *>(value) : nullptr;
  }
  const VarHandleOptionsT *AsVarHandleOptions() const {
    return type == BuiltinOptions_VarHandleOptions ?
      reinterpret_cast<const VarHandleOptionsT *>(value) : nullptr;
  }
  ReadVariableOptionsT *AsReadVariableOptions() {
    return type == BuiltinOptions_ReadVariableOptions ?
      reinterpret_cast<ReadVariableOptionsT *>(value) : nullptr;
  }
  const ReadVariableOptionsT *AsReadVariableOptions() const {
    return type == BuiltinOptions_ReadVariableOptions ?
      reinterpret_cast<const ReadVariableOptionsT *>(value) : nullptr;
  }
  AssignVariableOptionsT *AsAssignVariableOptions() {
    return type == BuiltinOptions_AssignVariableOptions ?
      reinterpret_cast<AssignVariableOptionsT *>(value) : nullptr;
  }
  const AssignVariableOptionsT *AsAssignVariableOptions() const {
    return type == BuiltinOptions_AssignVariableOptions ?
      reinterpret_cast<const AssignVariableOptionsT *>(value) : nullptr;
  }
  RandomOptionsT *AsRandomOptions() {
    return type == BuiltinOptions_RandomOptions ?
      reinterpret_cast<RandomOptionsT *>(value) : nullptr;
  }
  const RandomOptionsT *AsRandomOptions() const {
    return type == BuiltinOptions_RandomOptions ?
      reinterpret_cast<const RandomOptionsT *>(value) : nullptr;
  }
  BucketizeOptionsT *AsBucketizeOptions() {
    return type == BuiltinOptions_BucketizeOptions ?
      reinterpret_cast<BucketizeOptionsT *>(value) : nullptr;
  }
  const BucketizeOptionsT *AsBucketizeOptions() const {
    return type == BuiltinOptions_BucketizeOptions ?
      reinterpret_cast<const BucketizeOptionsT *>(value) : nullptr;
  }
  GeluOptionsT *AsGeluOptions() {
    return type == BuiltinOptions_GeluOptions ?
      reinterpret_cast<GeluOptionsT *>(value) : nullptr;
  }
  const GeluOptionsT *AsGeluOptions() const {
    return type == BuiltinOptions_GeluOptions ?
      reinterpret_cast<const GeluOptionsT *>(value) : nullptr;
  }
  DynamicUpdateSliceOptionsT *AsDynamicUpdateSliceOptions() {
    return type == BuiltinOptions_DynamicUpdateSliceOptions ?
      reinterpret_cast<DynamicUpdateSliceOptionsT *>(value) : nullptr;
  }
  const DynamicUpdateSliceOptionsT *AsDynamicUpdateSliceOptions() const {
    return type == BuiltinOptions_DynamicUpdateSliceOptions ?
      reinterpret_cast<const DynamicUpdateSliceOptionsT *>(value) : nullptr;
  }
  UnsortedSegmentProdOptionsT *AsUnsortedSegmentProdOptions() {
    return type == BuiltinOptions_UnsortedSegmentProdOptions ?
      reinterpret_cast<UnsortedSegmentProdOptionsT *>(value) : nullptr;
  }
  const UnsortedSegmentProdOptionsT *AsUnsortedSegmentProdOptions() const {
    return type == BuiltinOptions_UnsortedSegmentProdOptions ?
      reinterpret_cast<const UnsortedSegmentProdOptionsT *>(value) : nullptr;
  }
  UnsortedSegmentMaxOptionsT *AsUnsortedSegmentMaxOptions() {
    return type == BuiltinOptions_UnsortedSegmentMaxOptions ?
      reinterpret_cast<UnsortedSegmentMaxOptionsT *>(value) : nullptr;
  }
  const UnsortedSegmentMaxOptionsT *AsUnsortedSegmentMaxOptions() const {
    return type == BuiltinOptions_UnsortedSegmentMaxOptions ?
      reinterpret_cast<const UnsortedSegmentMaxOptionsT *>(value) : nullptr;
  }
  UnsortedSegmentMinOptionsT *AsUnsortedSegmentMinOptions() {
    return type == BuiltinOptions_UnsortedSegmentMinOptions ?
      reinterpret_cast<UnsortedSegmentMinOptionsT *>(value) : nullptr;
  }
  const UnsortedSegmentMinOptionsT *AsUnsortedSegmentMinOptions() const {
    return type == BuiltinOptions_UnsortedSegmentMinOptions ?
      reinterpret_cast<const UnsortedSegmentMinOptionsT *>(value) : nullptr;
  }
  UnsortedSegmentSumOptionsT *AsUnsortedSegmentSumOptions() {
    return type == BuiltinOptions_UnsortedSegmentSumOptions ?
      reinterpret_cast<UnsortedSegmentSumOptionsT *>(value) : nullptr;
  }
  const UnsortedSegmentSumOptionsT *AsUnsortedSegmentSumOptions() const {
    return type == BuiltinOptions_UnsortedSegmentSumOptions ?
      reinterpret_cast<const UnsortedSegmentSumOptionsT *>(value) : nullptr;
  }
  ATan2OptionsT *AsATan2Options() {
    return type == BuiltinOptions_ATan2Options ?
      reinterpret_cast<ATan2OptionsT *>(value) : nullptr;
  }
  const ATan2OptionsT *AsATan2Options() const {
    return type == BuiltinOptions_ATan2Options ?
      reinterpret_cast<const ATan2OptionsT *>(value) : nullptr;
  }
  SignOptionsT *AsSignOptions() {
    return type == BuiltinOptions_SignOptions ?
      reinterpret_cast<SignOptionsT *>(value) : nullptr;
  }
  const SignOptionsT *AsSignOptions() const {
    return type == BuiltinOptions_SignOptions ?
      reinterpret_cast<const SignOptionsT *>(value) : nullptr;
  }
  BitcastOptionsT *AsBitcastOptions() {
    return type == BuiltinOptions_BitcastOptions ?
      reinterpret_cast<BitcastOptionsT *>(value) : nullptr;
  }
  const BitcastOptionsT *AsBitcastOptions() const {
    return type == BuiltinOptions_BitcastOptions ?
      reinterpret_cast<const BitcastOptionsT *>(value) : nullptr;
  }
  BitwiseXorOptionsT *AsBitwiseXorOptions() {
    return type == BuiltinOptions_BitwiseXorOptions ?
      reinterpret_cast<BitwiseXorOptionsT *>(value) : nullptr;
  }
  const BitwiseXorOptionsT *AsBitwiseXorOptions() const {
    return type == BuiltinOptions_BitwiseXorOptions ?
      reinterpret_cast<const BitwiseXorOptionsT *>(value) : nullptr;
  }
  RightShiftOptionsT *AsRightShiftOptions() {
    return type == BuiltinOptions_RightShiftOptions ?
      reinterpret_cast<RightShiftOptionsT *>(value) : nullptr;
  }
  const RightShiftOptionsT *AsRightShiftOptions() const {
    return type == BuiltinOptions_RightShiftOptions ?
      reinterpret_cast<const RightShiftOptionsT *>(value) : nullptr;
  }
};

bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);
bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BuiltinOptions2 {
  BuiltinOptions2_NONE = 0,
  BuiltinOptions2_StablehloConcatenateOptions = 1,
  BuiltinOptions2_StablehloBroadcastInDimOptions = 2,
  BuiltinOptions2_StablehloSliceOptions = 3,
  BuiltinOptions2_StablehloConvolutionOptions = 4,
  BuiltinOptions2_StablehloCustomCallOptions = 5,
  BuiltinOptions2_StablehloReduceOptions = 6,
  BuiltinOptions2_StablehloScatterOptions = 7,
  BuiltinOptions2_StablehloCompareOptions = 8,
  BuiltinOptions2_StablehloDynamicSliceOptions = 9,
  BuiltinOptions2_StablehloPadOptions = 10,
  BuiltinOptions2_StablehloIotaOptions = 11,
  BuiltinOptions2_StablehloDotGeneralOptions = 12,
  BuiltinOptions2_StablehloReduceWindowOptions = 13,
  BuiltinOptions2_StablehloSortOptions = 14,
  BuiltinOptions2_StablehloWhileOptions = 15,
  BuiltinOptions2_StablehloGatherOptions = 16,
  BuiltinOptions2_StablehloTransposeOptions = 17,
  BuiltinOptions2_DilateOptions = 18,
  BuiltinOptions2_StablehloRngBitGeneratorOptions = 19,
  BuiltinOptions2_ReduceWindowOptions = 20,
  BuiltinOptions2_StableHLOCompositeOptions = 21,
  BuiltinOptions2_StablehloShiftLeftOptions = 22,
  BuiltinOptions2_StablehloCaseOptions = 23,
  BuiltinOptions2_MIN = BuiltinOptions2_NONE,
  BuiltinOptions2_MAX = BuiltinOptions2_StablehloCaseOptions
};

inline const BuiltinOptions2 (&EnumValuesBuiltinOptions2())[24] {
  static const BuiltinOptions2 values[] = {
    BuiltinOptions2_NONE,
    BuiltinOptions2_StablehloConcatenateOptions,
    BuiltinOptions2_StablehloBroadcastInDimOptions,
    BuiltinOptions2_StablehloSliceOptions,
    BuiltinOptions2_StablehloConvolutionOptions,
    BuiltinOptions2_StablehloCustomCallOptions,
    BuiltinOptions2_StablehloReduceOptions,
    BuiltinOptions2_StablehloScatterOptions,
    BuiltinOptions2_StablehloCompareOptions,
    BuiltinOptions2_StablehloDynamicSliceOptions,
    BuiltinOptions2_StablehloPadOptions,
    BuiltinOptions2_StablehloIotaOptions,
    BuiltinOptions2_StablehloDotGeneralOptions,
    BuiltinOptions2_StablehloReduceWindowOptions,
    BuiltinOptions2_StablehloSortOptions,
    BuiltinOptions2_StablehloWhileOptions,
    BuiltinOptions2_StablehloGatherOptions,
    BuiltinOptions2_StablehloTransposeOptions,
    BuiltinOptions2_DilateOptions,
    BuiltinOptions2_StablehloRngBitGeneratorOptions,
    BuiltinOptions2_ReduceWindowOptions,
    BuiltinOptions2_StableHLOCompositeOptions,
    BuiltinOptions2_StablehloShiftLeftOptions,
    BuiltinOptions2_StablehloCaseOptions
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOptions2() {
  static const char * const names[] = {
    "NONE",
    "StablehloConcatenateOptions",
    "StablehloBroadcastInDimOptions",
    "StablehloSliceOptions",
    "StablehloConvolutionOptions",
    "StablehloCustomCallOptions",
    "StablehloReduceOptions",
    "StablehloScatterOptions",
    "StablehloCompareOptions",
    "StablehloDynamicSliceOptions",
    "StablehloPadOptions",
    "StablehloIotaOptions",
    "StablehloDotGeneralOptions",
    "StablehloReduceWindowOptions",
    "StablehloSortOptions",
    "StablehloWhileOptions",
    "StablehloGatherOptions",
    "StablehloTransposeOptions",
    "DilateOptions",
    "StablehloRngBitGeneratorOptions",
    "ReduceWindowOptions",
    "StableHLOCompositeOptions",
    "StablehloShiftLeftOptions",
    "StablehloCaseOptions",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOptions2(BuiltinOptions2 e) {
  if (e < BuiltinOptions2_NONE || e > BuiltinOptions2_StablehloCaseOptions) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesBuiltinOptions2()[index];
}

template<typename T> struct BuiltinOptions2Traits {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_NONE;
};

template<> struct BuiltinOptions2Traits<StablehloConcatenateOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloConcatenateOptions;
};

template<> struct BuiltinOptions2Traits<StablehloBroadcastInDimOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloBroadcastInDimOptions;
};

template<> struct BuiltinOptions2Traits<StablehloSliceOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloSliceOptions;
};

template<> struct BuiltinOptions2Traits<StablehloConvolutionOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloConvolutionOptions;
};

template<> struct BuiltinOptions2Traits<StablehloCustomCallOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloCustomCallOptions;
};

template<> struct BuiltinOptions2Traits<StablehloReduceOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloReduceOptions;
};

template<> struct BuiltinOptions2Traits<StablehloScatterOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloScatterOptions;
};

template<> struct BuiltinOptions2Traits<StablehloCompareOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloCompareOptions;
};

template<> struct BuiltinOptions2Traits<StablehloDynamicSliceOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloDynamicSliceOptions;
};

template<> struct BuiltinOptions2Traits<StablehloPadOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloPadOptions;
};

template<> struct BuiltinOptions2Traits<StablehloIotaOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloIotaOptions;
};

template<> struct BuiltinOptions2Traits<StablehloDotGeneralOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloDotGeneralOptions;
};

template<> struct BuiltinOptions2Traits<StablehloReduceWindowOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloReduceWindowOptions;
};

template<> struct BuiltinOptions2Traits<StablehloSortOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloSortOptions;
};

template<> struct BuiltinOptions2Traits<StablehloWhileOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloWhileOptions;
};

template<> struct BuiltinOptions2Traits<StablehloGatherOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloGatherOptions;
};

template<> struct BuiltinOptions2Traits<StablehloTransposeOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloTransposeOptions;
};

template<> struct BuiltinOptions2Traits<DilateOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_DilateOptions;
};

template<> struct BuiltinOptions2Traits<StablehloRngBitGeneratorOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloRngBitGeneratorOptions;
};

template<> struct BuiltinOptions2Traits<ReduceWindowOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_ReduceWindowOptions;
};

template<> struct BuiltinOptions2Traits<StableHLOCompositeOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StableHLOCompositeOptions;
};

template<> struct BuiltinOptions2Traits<StablehloShiftLeftOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloShiftLeftOptions;
};

template<> struct BuiltinOptions2Traits<StablehloCaseOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloCaseOptions;
};

struct BuiltinOptions2Union {
  BuiltinOptions2 type;
  void *value;

  BuiltinOptions2Union() : type(BuiltinOptions2_NONE), value(nullptr) {}
  BuiltinOptions2Union(BuiltinOptions2Union&& u) FLATBUFFERS_NOEXCEPT :
    type(BuiltinOptions2_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BuiltinOptions2Union(const BuiltinOptions2Union &) FLATBUFFERS_NOEXCEPT;
  BuiltinOptions2Union &operator=(const BuiltinOptions2Union &u) FLATBUFFERS_NOEXCEPT
    { BuiltinOptions2Union t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BuiltinOptions2Union &operator=(BuiltinOptions2Union &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BuiltinOptions2Union() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = BuiltinOptions2Traits<typename T::TableType>::enum_value;
    if (type != BuiltinOptions2_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, BuiltinOptions2 type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  StablehloConcatenateOptionsT *AsStablehloConcatenateOptions() {
    return type == BuiltinOptions2_StablehloConcatenateOptions ?
      reinterpret_cast<StablehloConcatenateOptionsT *>(value) : nullptr;
  }
  const StablehloConcatenateOptionsT *AsStablehloConcatenateOptions() const {
    return type == BuiltinOptions2_StablehloConcatenateOptions ?
      reinterpret_cast<const StablehloConcatenateOptionsT *>(value) : nullptr;
  }
  StablehloBroadcastInDimOptionsT *AsStablehloBroadcastInDimOptions() {
    return type == BuiltinOptions2_StablehloBroadcastInDimOptions ?
      reinterpret_cast<StablehloBroadcastInDimOptionsT *>(value) : nullptr;
  }
  const StablehloBroadcastInDimOptionsT *AsStablehloBroadcastInDimOptions() const {
    return type == BuiltinOptions2_StablehloBroadcastInDimOptions ?
      reinterpret_cast<const StablehloBroadcastInDimOptionsT *>(value) : nullptr;
  }
  StablehloSliceOptionsT *AsStablehloSliceOptions() {
    return type == BuiltinOptions2_StablehloSliceOptions ?
      reinterpret_cast<StablehloSliceOptionsT *>(value) : nullptr;
  }
  const StablehloSliceOptionsT *AsStablehloSliceOptions() const {
    return type == BuiltinOptions2_StablehloSliceOptions ?
      reinterpret_cast<const StablehloSliceOptionsT *>(value) : nullptr;
  }
  StablehloConvolutionOptionsT *AsStablehloConvolutionOptions() {
    return type == BuiltinOptions2_StablehloConvolutionOptions ?
      reinterpret_cast<StablehloConvolutionOptionsT *>(value) : nullptr;
  }
  const StablehloConvolutionOptionsT *AsStablehloConvolutionOptions() const {
    return type == BuiltinOptions2_StablehloConvolutionOptions ?
      reinterpret_cast<const StablehloConvolutionOptionsT *>(value) : nullptr;
  }
  StablehloCustomCallOptionsT *AsStablehloCustomCallOptions() {
    return type == BuiltinOptions2_StablehloCustomCallOptions ?
      reinterpret_cast<StablehloCustomCallOptionsT *>(value) : nullptr;
  }
  const StablehloCustomCallOptionsT *AsStablehloCustomCallOptions() const {
    return type == BuiltinOptions2_StablehloCustomCallOptions ?
      reinterpret_cast<const StablehloCustomCallOptionsT *>(value) : nullptr;
  }
  StablehloReduceOptionsT *AsStablehloReduceOptions() {
    return type == BuiltinOptions2_StablehloReduceOptions ?
      reinterpret_cast<StablehloReduceOptionsT *>(value) : nullptr;
  }
  const StablehloReduceOptionsT *AsStablehloReduceOptions() const {
    return type == BuiltinOptions2_StablehloReduceOptions ?
      reinterpret_cast<const StablehloReduceOptionsT *>(value) : nullptr;
  }
  StablehloScatterOptionsT *AsStablehloScatterOptions() {
    return type == BuiltinOptions2_StablehloScatterOptions ?
      reinterpret_cast<StablehloScatterOptionsT *>(value) : nullptr;
  }
  const StablehloScatterOptionsT *AsStablehloScatterOptions() const {
    return type == BuiltinOptions2_StablehloScatterOptions ?
      reinterpret_cast<const StablehloScatterOptionsT *>(value) : nullptr;
  }
  StablehloCompareOptionsT *AsStablehloCompareOptions() {
    return type == BuiltinOptions2_StablehloCompareOptions ?
      reinterpret_cast<StablehloCompareOptionsT *>(value) : nullptr;
  }
  const StablehloCompareOptionsT *AsStablehloCompareOptions() const {
    return type == BuiltinOptions2_StablehloCompareOptions ?
      reinterpret_cast<const StablehloCompareOptionsT *>(value) : nullptr;
  }
  StablehloDynamicSliceOptionsT *AsStablehloDynamicSliceOptions() {
    return type == BuiltinOptions2_StablehloDynamicSliceOptions ?
      reinterpret_cast<StablehloDynamicSliceOptionsT *>(value) : nullptr;
  }
  const StablehloDynamicSliceOptionsT *AsStablehloDynamicSliceOptions() const {
    return type == BuiltinOptions2_StablehloDynamicSliceOptions ?
      reinterpret_cast<const StablehloDynamicSliceOptionsT *>(value) : nullptr;
  }
  StablehloPadOptionsT *AsStablehloPadOptions() {
    return type == BuiltinOptions2_StablehloPadOptions ?
      reinterpret_cast<StablehloPadOptionsT *>(value) : nullptr;
  }
  const StablehloPadOptionsT *AsStablehloPadOptions() const {
    return type == BuiltinOptions2_StablehloPadOptions ?
      reinterpret_cast<const StablehloPadOptionsT *>(value) : nullptr;
  }
  StablehloIotaOptionsT *AsStablehloIotaOptions() {
    return type == BuiltinOptions2_StablehloIotaOptions ?
      reinterpret_cast<StablehloIotaOptionsT *>(value) : nullptr;
  }
  const StablehloIotaOptionsT *AsStablehloIotaOptions() const {
    return type == BuiltinOptions2_StablehloIotaOptions ?
      reinterpret_cast<const StablehloIotaOptionsT *>(value) : nullptr;
  }
  StablehloDotGeneralOptionsT *AsStablehloDotGeneralOptions() {
    return type == BuiltinOptions2_StablehloDotGeneralOptions ?
      reinterpret_cast<StablehloDotGeneralOptionsT *>(value) : nullptr;
  }
  const StablehloDotGeneralOptionsT *AsStablehloDotGeneralOptions() const {
    return type == BuiltinOptions2_StablehloDotGeneralOptions ?
      reinterpret_cast<const StablehloDotGeneralOptionsT *>(value) : nullptr;
  }
  StablehloReduceWindowOptionsT *AsStablehloReduceWindowOptions() {
    return type == BuiltinOptions2_StablehloReduceWindowOptions ?
      reinterpret_cast<StablehloReduceWindowOptionsT *>(value) : nullptr;
  }
  const StablehloReduceWindowOptionsT *AsStablehloReduceWindowOptions() const {
    return type == BuiltinOptions2_StablehloReduceWindowOptions ?
      reinterpret_cast<const StablehloReduceWindowOptionsT *>(value) : nullptr;
  }
  StablehloSortOptionsT *AsStablehloSortOptions() {
    return type == BuiltinOptions2_StablehloSortOptions ?
      reinterpret_cast<StablehloSortOptionsT *>(value) : nullptr;
  }
  const StablehloSortOptionsT *AsStablehloSortOptions() const {
    return type == BuiltinOptions2_StablehloSortOptions ?
      reinterpret_cast<const StablehloSortOptionsT *>(value) : nullptr;
  }
  StablehloWhileOptionsT *AsStablehloWhileOptions() {
    return type == BuiltinOptions2_StablehloWhileOptions ?
      reinterpret_cast<StablehloWhileOptionsT *>(value) : nullptr;
  }
  const StablehloWhileOptionsT *AsStablehloWhileOptions() const {
    return type == BuiltinOptions2_StablehloWhileOptions ?
      reinterpret_cast<const StablehloWhileOptionsT *>(value) : nullptr;
  }
  StablehloGatherOptionsT *AsStablehloGatherOptions() {
    return type == BuiltinOptions2_StablehloGatherOptions ?
      reinterpret_cast<StablehloGatherOptionsT *>(value) : nullptr;
  }
  const StablehloGatherOptionsT *AsStablehloGatherOptions() const {
    return type == BuiltinOptions2_StablehloGatherOptions ?
      reinterpret_cast<const StablehloGatherOptionsT *>(value) : nullptr;
  }
  StablehloTransposeOptionsT *AsStablehloTransposeOptions() {
    return type == BuiltinOptions2_StablehloTransposeOptions ?
      reinterpret_cast<StablehloTransposeOptionsT *>(value) : nullptr;
  }
  const StablehloTransposeOptionsT *AsStablehloTransposeOptions() const {
    return type == BuiltinOptions2_StablehloTransposeOptions ?
      reinterpret_cast<const StablehloTransposeOptionsT *>(value) : nullptr;
  }
  DilateOptionsT *AsDilateOptions() {
    return type == BuiltinOptions2_DilateOptions ?
      reinterpret_cast<DilateOptionsT *>(value) : nullptr;
  }
  const DilateOptionsT *AsDilateOptions() const {
    return type == BuiltinOptions2_DilateOptions ?
      reinterpret_cast<const DilateOptionsT *>(value) : nullptr;
  }
  StablehloRngBitGeneratorOptionsT *AsStablehloRngBitGeneratorOptions() {
    return type == BuiltinOptions2_StablehloRngBitGeneratorOptions ?
      reinterpret_cast<StablehloRngBitGeneratorOptionsT *>(value) : nullptr;
  }
  const StablehloRngBitGeneratorOptionsT *AsStablehloRngBitGeneratorOptions() const {
    return type == BuiltinOptions2_StablehloRngBitGeneratorOptions ?
      reinterpret_cast<const StablehloRngBitGeneratorOptionsT *>(value) : nullptr;
  }
  ReduceWindowOptionsT *AsReduceWindowOptions() {
    return type == BuiltinOptions2_ReduceWindowOptions ?
      reinterpret_cast<ReduceWindowOptionsT *>(value) : nullptr;
  }
  const ReduceWindowOptionsT *AsReduceWindowOptions() const {
    return type == BuiltinOptions2_ReduceWindowOptions ?
      reinterpret_cast<const ReduceWindowOptionsT *>(value) : nullptr;
  }
  StableHLOCompositeOptionsT *AsStableHLOCompositeOptions() {
    return type == BuiltinOptions2_StableHLOCompositeOptions ?
      reinterpret_cast<StableHLOCompositeOptionsT *>(value) : nullptr;
  }
  const StableHLOCompositeOptionsT *AsStableHLOCompositeOptions() const {
    return type == BuiltinOptions2_StableHLOCompositeOptions ?
      reinterpret_cast<const StableHLOCompositeOptionsT *>(value) : nullptr;
  }
  StablehloShiftLeftOptionsT *AsStablehloShiftLeftOptions() {
    return type == BuiltinOptions2_StablehloShiftLeftOptions ?
      reinterpret_cast<StablehloShiftLeftOptionsT *>(value) : nullptr;
  }
  const StablehloShiftLeftOptionsT *AsStablehloShiftLeftOptions() const {
    return type == BuiltinOptions2_StablehloShiftLeftOptions ?
      reinterpret_cast<const StablehloShiftLeftOptionsT *>(value) : nullptr;
  }
  StablehloCaseOptionsT *AsStablehloCaseOptions() {
    return type == BuiltinOptions2_StablehloCaseOptions ?
      reinterpret_cast<StablehloCaseOptionsT *>(value) : nullptr;
  }
  const StablehloCaseOptionsT *AsStablehloCaseOptions() const {
    return type == BuiltinOptions2_StablehloCaseOptions ?
      reinterpret_cast<const StablehloCaseOptionsT *>(value) : nullptr;
  }
};

bool VerifyBuiltinOptions2(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions2 type);
bool VerifyBuiltinOptions2Vector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum StablehloPrecisionConfig {
  StablehloPrecisionConfig_DEFAULT = 0,
  StablehloPrecisionConfig_HIGH = 1,
  StablehloPrecisionConfig_HIGHEST = 2,
  StablehloPrecisionConfig_MIN = StablehloPrecisionConfig_DEFAULT,
  StablehloPrecisionConfig_MAX = StablehloPrecisionConfig_HIGHEST
};

inline const StablehloPrecisionConfig (&EnumValuesStablehloPrecisionConfig())[3] {
  static const StablehloPrecisionConfig values[] = {
    StablehloPrecisionConfig_DEFAULT,
    StablehloPrecisionConfig_HIGH,
    StablehloPrecisionConfig_HIGHEST
  };
  return values;
}

inline const char * const *EnumNamesStablehloPrecisionConfig() {
  static const char * const names[] = {
    "DEFAULT",
    "HIGH",
    "HIGHEST",
    nullptr
  };
  return names;
}

inline const char *EnumNameStablehloPrecisionConfig(StablehloPrecisionConfig e) {
  if (e < StablehloPrecisionConfig_DEFAULT || e > StablehloPrecisionConfig_HIGHEST) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesStablehloPrecisionConfig()[index];
}

enum StablehloComparisonDirection {
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ = 0,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_NE = 1,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GE = 2,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GT = 3,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LE = 4,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT = 5,
  StablehloComparisonDirection_MIN = StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ,
  StablehloComparisonDirection_MAX = StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT
};

inline const StablehloComparisonDirection (&EnumValuesStablehloComparisonDirection())[6] {
  static const StablehloComparisonDirection values[] = {
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_NE,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GE,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GT,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LE,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT
  };
  return values;
}

inline const char * const *EnumNamesStablehloComparisonDirection() {
  static const char * const names[] = {
    "STABLEHLO_COMPARISON_DIRECTION_EQ",
    "STABLEHLO_COMPARISON_DIRECTION_NE",
    "STABLEHLO_COMPARISON_DIRECTION_GE",
    "STABLEHLO_COMPARISON_DIRECTION_GT",
    "STABLEHLO_COMPARISON_DIRECTION_LE",
    "STABLEHLO_COMPARISON_DIRECTION_LT",
    nullptr
  };
  return names;
}

inline const char *EnumNameStablehloComparisonDirection(StablehloComparisonDirection e) {
  if (e < StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ || e > StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesStablehloComparisonDirection()[index];
}

enum StablehloComparisonType {
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE = 0,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT = 1,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER = 2,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_SIGNED = 3,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED = 4,
  StablehloComparisonType_MIN = StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE,
  StablehloComparisonType_MAX = StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED
};

inline const StablehloComparisonType (&EnumValuesStablehloComparisonType())[5] {
  static const StablehloComparisonType values[] = {
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_SIGNED,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED
  };
  return values;
}

inline const char * const *EnumNamesStablehloComparisonType() {
  static const char * const names[] = {
    "STABLEHLO_COMPARISON_TYPE_NOTYPE",
    "STABLEHLO_COMPARISON_TYPE_FLOAT",
    "STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER",
    "STABLEHLO_COMPARISON_TYPE_SIGNED",
    "STABLEHLO_COMPARISON_TYPE_UNSIGNED",
    nullptr
  };
  return names;
}

inline const char *EnumNameStablehloComparisonType(StablehloComparisonType e) {
  if (e < StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE || e > StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesStablehloComparisonType()[index];
}

enum RngAlgorithm {
  RngAlgorithm_DEFAULT = 0,
  RngAlgorithm_PHILOX = 1,
  RngAlgorithm_THREEFRY = 2,
  RngAlgorithm_MIN = RngAlgorithm_DEFAULT,
  RngAlgorithm_MAX = RngAlgorithm_THREEFRY
};

inline const RngAlgorithm (&EnumValuesRngAlgorithm())[3] {
  static const RngAlgorithm values[] = {
    RngAlgorithm_DEFAULT,
    RngAlgorithm_PHILOX,
    RngAlgorithm_THREEFRY
  };
  return values;
}

inline const char * const *EnumNamesRngAlgorithm() {
  static const char * const names[] = {
    "DEFAULT",
    "PHILOX",
    "THREEFRY",
    nullptr
  };
  return names;
}

inline const char *EnumNameRngAlgorithm(RngAlgorithm e) {
  if (e < RngAlgorithm_DEFAULT || e > RngAlgorithm_THREEFRY) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesRngAlgorithm()[index];
}

enum Padding {
  Padding_SAME = 0,
  Padding_VALID = 1,
  Padding_MIN = Padding_SAME,
  Padding_MAX = Padding_VALID
};

inline const Padding (&EnumValuesPadding())[2] {
  static const Padding values[] = {
    Padding_SAME,
    Padding_VALID
  };
  return values;
}

inline const char * const *EnumNamesPadding() {
  static const char * const names[] = {
    "SAME",
    "VALID",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadding(Padding e) {
  if (e < Padding_SAME || e > Padding_VALID) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPadding()[index];
}

enum ActivationFunctionType {
  ActivationFunctionType_NONE = 0,
  ActivationFunctionType_RELU = 1,
  ActivationFunctionType_RELU_N1_TO_1 = 2,
  ActivationFunctionType_RELU6 = 3,
  ActivationFunctionType_TANH = 4,
  ActivationFunctionType_SIGN_BIT = 5,
  ActivationFunctionType_MIN = ActivationFunctionType_NONE,
  ActivationFunctionType_MAX = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6] {
  static const ActivationFunctionType values[] = {
    ActivationFunctionType_NONE,
    ActivationFunctionType_RELU,
    ActivationFunctionType_RELU_N1_TO_1,
    ActivationFunctionType_RELU6,
    ActivationFunctionType_TANH,
    ActivationFunctionType_SIGN_BIT
  };
  return values;
}

inline const char * const *EnumNamesActivationFunctionType() {
  static const char * const names[] = {
    "NONE",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "TANH",
    "SIGN_BIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationFunctionType(ActivationFunctionType e) {
  if (e < ActivationFunctionType_NONE || e > ActivationFunctionType_SIGN_BIT) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType {
  LSHProjectionType_UNKNOWN = 0,
  LSHProjectionType_SPARSE = 1,
  LSHProjectionType_DENSE = 2,
  LSHProjectionType_MIN = LSHProjectionType_UNKNOWN,
  LSHProjectionType_MAX = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3] {
  static const LSHProjectionType values[] = {
    LSHProjectionType_UNKNOWN,
    LSHProjectionType_SPARSE,
    LSHProjectionType_DENSE
  };
  return values;
}

inline const char * const *EnumNamesLSHProjectionType() {
  static const char * const names[] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSHProjectionType(LSHProjectionType e) {
  if (e < LSHProjectionType_UNKNOWN || e > LSHProjectionType_DENSE) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat {
  FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
  FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
  FullyConnectedOptionsWeightsFormat_MIN = FullyConnectedOptionsWeightsFormat_DEFAULT,
  FullyConnectedOptionsWeightsFormat_MAX = FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
};

inline const FullyConnectedOptionsWeightsFormat (&EnumValuesFullyConnectedOptionsWeightsFormat())[2] {
  static const FullyConnectedOptionsWeightsFormat values[] = {
    FullyConnectedOptionsWeightsFormat_DEFAULT,
    FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
  };
  return values;
}

inline const char * const *EnumNamesFullyConnectedOptionsWeightsFormat() {
  static const char * const names[] = {
    "DEFAULT",
    "SHUFFLED4x16INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e) {
  if (e < FullyConnectedOptionsWeightsFormat_DEFAULT || e > FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesFullyConnectedOptionsWeightsFormat()[index];
}

enum LSTMKernelType {
  LSTMKernelType_FULL = 0,
  LSTMKernelType_BASIC = 1,
  LSTMKernelType_MIN = LSTMKernelType_FULL,
  LSTMKernelType_MAX = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2] {
  static const LSTMKernelType values[] = {
    LSTMKernelType_FULL,
    LSTMKernelType_BASIC
  };
  return values;
}

inline const char * const *EnumNamesLSTMKernelType() {
  static const char * const names[] = {
    "FULL",
    "BASIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSTMKernelType(LSTMKernelType e) {
  if (e < LSTMKernelType_FULL || e > LSTMKernelType_BASIC) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesLSTMKernelType()[index];
}

enum CombinerType {
  CombinerType_SUM = 0,
  CombinerType_MEAN = 1,
  CombinerType_SQRTN = 2,
  CombinerType_MIN = CombinerType_SUM,
  CombinerType_MAX = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3] {
  static const CombinerType values[] = {
    CombinerType_SUM,
    CombinerType_MEAN,
    CombinerType_SQRTN
  };
  return values;
}

inline const char * const *EnumNamesCombinerType() {
  static const char * const names[] = {
    "SUM",
    "MEAN",
    "SQRTN",
    nullptr
  };
  return names;
}

inline const char *EnumNameCombinerType(CombinerType e) {
  if (e < CombinerType_SUM || e > CombinerType_SQRTN) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesCombinerType()[index];
}

enum MirrorPadMode {
  MirrorPadMode_REFLECT = 0,
  MirrorPadMode_SYMMETRIC = 1,
  MirrorPadMode_MIN = MirrorPadMode_REFLECT,
  MirrorPadMode_MAX = MirrorPadMode_SYMMETRIC
};

inline const MirrorPadMode (&EnumValuesMirrorPadMode())[2] {
  static const MirrorPadMode values[] = {
    MirrorPadMode_REFLECT,
    MirrorPadMode_SYMMETRIC
  };
  return values;
}

inline const char * const *EnumNamesMirrorPadMode() {
  static const char * const names[] = {
    "REFLECT",
    "SYMMETRIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameMirrorPadMode(MirrorPadMode e) {
  if (e < MirrorPadMode_REFLECT || e > MirrorPadMode_SYMMETRIC) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesMirrorPadMode()[index];
}

enum ReduceWindowFunction {
  ReduceWindowFunction_UNSUPPORTED = 0,
  ReduceWindowFunction_ADD = 1,
  ReduceWindowFunction_MUL = 2,
  ReduceWindowFunction_MINIMUM = 3,
  ReduceWindowFunction_MAXIMUM = 4,
  ReduceWindowFunction_ALL = 5,
  ReduceWindowFunction_ANY = 6,
  ReduceWindowFunction_MIN = ReduceWindowFunction_UNSUPPORTED,
  ReduceWindowFunction_MAX = ReduceWindowFunction_ANY
};

inline const ReduceWindowFunction (&EnumValuesReduceWindowFunction())[7] {
  static const ReduceWindowFunction values[] = {
    ReduceWindowFunction_UNSUPPORTED,
    ReduceWindowFunction_ADD,
    ReduceWindowFunction_MUL,
    ReduceWindowFunction_MINIMUM,
    ReduceWindowFunction_MAXIMUM,
    ReduceWindowFunction_ALL,
    ReduceWindowFunction_ANY
  };
  return values;
}

inline const char * const *EnumNamesReduceWindowFunction() {
  static const char * const names[] = {
    "UNSUPPORTED",
    "ADD",
    "MUL",
    "MINIMUM",
    "MAXIMUM",
    "ALL",
    "ANY",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceWindowFunction(ReduceWindowFunction e) {
  if (e < ReduceWindowFunction_UNSUPPORTED || e > ReduceWindowFunction_ANY) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesReduceWindowFunction()[index];
}

enum CustomOptionsFormat {
  CustomOptionsFormat_FLEXBUFFERS = 0,
  CustomOptionsFormat_MIN = CustomOptionsFormat_FLEXBUFFERS,
  CustomOptionsFormat_MAX = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1] {
  static const CustomOptionsFormat values[] = {
    CustomOptionsFormat_FLEXBUFFERS
  };
  return values;
}

inline const char * const *EnumNamesCustomOptionsFormat() {
  static const char * const names[] = {
    "FLEXBUFFERS",
    nullptr
  };
  return names;
}

inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e) {
  if (e < CustomOptionsFormat_FLEXBUFFERS || e > CustomOptionsFormat_FLEXBUFFERS) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesCustomOptionsFormat()[index];
}

struct CustomQuantizationT : public flatbuffers::NativeTable {
  typedef CustomQuantization TableType;
  std::vector<uint8_t> custom;
  CustomQuantizationT() {
  }
};

struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomQuantizationT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CustomQuantizationTypeTable();
  }
  const flatbuffers::Vector<uint8_t> *custom() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(custom()) &&
           verifier.EndTable();
  }
  CustomQuantizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomQuantization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomQuantizationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom) {
    fbb_.AddOffset(4, custom);
  }
  explicit CustomQuantizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomQuantizationBuilder &operator=(const CustomQuantizationBuilder &);
  flatbuffers::Offset<CustomQuantization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomQuantization>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0) {
  CustomQuantizationBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlockwiseQuantizationT : public flatbuffers::NativeTable {
  typedef BlockwiseQuantization TableType;
  int32_t scales;
  int32_t zero_points;
  int32_t block_size;
  BlockwiseQuantizationT()
      : scales(0),
        zero_points(0),
        block_size(0) {
  }
};

struct BlockwiseQuantization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlockwiseQuantizationT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BlockwiseQuantizationTypeTable();
  }
  int32_t scales() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t zero_points() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t block_size() const {
    return GetField<int32_t>(8, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           verifier.EndTable();
  }
  BlockwiseQuantizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlockwiseQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlockwiseQuantization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockwiseQuantizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlockwiseQuantizationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scales(int32_t scales) {
    fbb_.AddElement<int32_t>(4, scales, 0);
  }
  void add_zero_points(int32_t zero_points) {
    fbb_.AddElement<int32_t>(6, zero_points, 0);
  }
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(8, block_size, 0);
  }
  explicit BlockwiseQuantizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlockwiseQuantizationBuilder &operator=(const BlockwiseQuantizationBuilder &);
  flatbuffers::Offset<BlockwiseQuantization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockwiseQuantization>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockwiseQuantization> CreateBlockwiseQuantization(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t scales = 0,
    int32_t zero_points = 0,
    int32_t block_size = 0) {
  BlockwiseQuantizationBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  builder_.add_zero_points(zero_points);
  builder_.add_scales(scales);
  return builder_.Finish();
}

flatbuffers::Offset<BlockwiseQuantization> CreateBlockwiseQuantization(flatbuffers::FlatBufferBuilder &_fbb, const BlockwiseQuantizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizationParametersT : public flatbuffers::NativeTable {
  typedef QuantizationParameters TableType;
  std::vector<float> min;
  std::vector<float> max;
  std::vector<float> scale;
  std::vector<int64_t> zero_point;
  QuantizationDetailsUnion details;
  int32_t quantized_dimension;
  QuantizationParametersT()
      : quantized_dimension(0) {
  }
};

struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizationParametersT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantizationParametersTypeTable();
  }
  const flatbuffers::Vector<float> *min() const {
    return GetPointer<const flatbuffers::Vector<float> *>(4);
  }
  const flatbuffers::Vector<float> *max() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  const flatbuffers::Vector<int64_t> *zero_point() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(10);
  }
  QuantizationDetails details_type() const {
    return static_cast<QuantizationDetails>(GetField<uint8_t>(12, 0));
  }
  const void *details() const {
    return GetPointer<const void *>(14);
  }
  template<typename T> const T *details_as() const;
  const CustomQuantization *details_as_CustomQuantization() const {
    return details_type() == QuantizationDetails_CustomQuantization ? static_cast<const CustomQuantization *>(details()) : nullptr;
  }
  const BlockwiseQuantization *details_as_BlockwiseQuantization() const {
    return details_type() == QuantizationDetails_BlockwiseQuantization ? static_cast<const BlockwiseQuantization *>(details()) : nullptr;
  }
  int32_t quantized_dimension() const {
    return GetField<int32_t>(16, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(min()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(max()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(zero_point()) &&
           VerifyField<uint8_t>(verifier, 12) &&
           VerifyOffset(verifier, 14) &&
           VerifyQuantizationDetails(verifier, details(), details_type()) &&
           VerifyField<int32_t>(verifier, 16) &&
           verifier.EndTable();
  }
  QuantizationParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizationParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizationParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const CustomQuantization *QuantizationParameters::details_as<CustomQuantization>() const {
  return details_as_CustomQuantization();
}

template<> inline const BlockwiseQuantization *QuantizationParameters::details_as<BlockwiseQuantization>() const {
  return details_as_BlockwiseQuantization();
}

struct QuantizationParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min) {
    fbb_.AddOffset(4, min);
  }
  void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max) {
    fbb_.AddOffset(6, max);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(8, scale);
  }
  void add_zero_point(flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point) {
    fbb_.AddOffset(10, zero_point);
  }
  void add_details_type(QuantizationDetails details_type) {
    fbb_.AddElement<uint8_t>(12, static_cast<uint8_t>(details_type), 0);
  }
  void add_details(flatbuffers::Offset<void> details) {
    fbb_.AddOffset(14, details);
  }
  void add_quantized_dimension(int32_t quantized_dimension) {
    fbb_.AddElement<int32_t>(16, quantized_dimension, 0);
  }
  explicit QuantizationParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizationParametersBuilder &operator=(const QuantizationParametersBuilder &);
  flatbuffers::Offset<QuantizationParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizationParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point = 0,
    QuantizationDetails details_type = QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
  QuantizationParametersBuilder builder_(_fbb);
  builder_.add_quantized_dimension(quantized_dimension);
  builder_.add_details(details);
  builder_.add_zero_point(zero_point);
  builder_.add_scale(scale);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_details_type(details_type);
  return builder_.Finish();
}

flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int32VectorT : public flatbuffers::NativeTable {
  typedef Int32Vector TableType;
  std::vector<int32_t> values;
  Int32VectorT() {
  }
};

struct Int32Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int32VectorT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Int32VectorTypeTable();
  }
  const flatbuffers::Vector<int32_t> *values() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  Int32VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int32VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Int32Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int32VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<int32_t>> values) {
    fbb_.AddOffset(4, values);
  }
  explicit Int32VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int32VectorBuilder &operator=(const Int32VectorBuilder &);
  flatbuffers::Offset<Int32Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int32Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int32Vector> CreateInt32Vector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> values = 0) {
  Int32VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

flatbuffers::Offset<Int32Vector> CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Uint16VectorT : public flatbuffers::NativeTable {
  typedef Uint16Vector TableType;
  std::vector<uint16_t> values;
  Uint16VectorT() {
  }
};

struct Uint16Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Uint16VectorT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Uint16VectorTypeTable();
  }
  const flatbuffers::Vector<uint16_t> *values() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  Uint16VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Uint16VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Uint16Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Uint16VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values) {
    fbb_.AddOffset(4, values);
  }
  explicit Uint16VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Uint16VectorBuilder &operator=(const Uint16VectorBuilder &);
  flatbuffers::Offset<Uint16Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint16Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values = 0) {
  Uint16VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

flatbuffers::Offset<Uint16Vector> CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Uint8VectorT : public flatbuffers::NativeTable {
  typedef Uint8Vector TableType;
  std::vector<uint8_t> values;
  Uint8VectorT() {
  }
};

struct Uint8Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Uint8VectorT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Uint8VectorTypeTable();
  }
  const flatbuffers::Vector<uint8_t> *values() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  Uint8VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Uint8VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Uint8Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Uint8VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values) {
    fbb_.AddOffset(4, values);
  }
  explicit Uint8VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Uint8VectorBuilder &operator=(const Uint8VectorBuilder &);
  flatbuffers::Offset<Uint8Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint8Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values = 0) {
  Uint8VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

flatbuffers::Offset<Uint8Vector> CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DimensionMetadataT : public flatbuffers::NativeTable {
  typedef DimensionMetadata TableType;
  DimensionType format;
  int32_t dense_size;
  SparseIndexVectorUnion array_segments;
  SparseIndexVectorUnion array_indices;
  DimensionMetadataT()
      : format(DimensionType_DENSE),
        dense_size(0) {
  }
};

struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DimensionMetadataT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DimensionMetadataTypeTable();
  }
  DimensionType format() const {
    return static_cast<DimensionType>(GetField<int8_t>(4, 0));
  }
  int32_t dense_size() const {
    return GetField<int32_t>(6, 0);
  }
  SparseIndexVector array_segments_type() const {
    return static_cast<SparseIndexVector>(GetField<uint8_t>(8, 0));
  }
  const void *array_segments() const {
    return GetPointer<const void *>(10);
  }
  template<typename T> const T *array_segments_as() const;
  const Int32Vector *array_segments_as_Int32Vector() const {
    return array_segments_type() == SparseIndexVector_Int32Vector ? static_cast<const Int32Vector *>(array_segments()) : nullptr;
  }
  const Uint16Vector *array_segments_as_Uint16Vector() const {
    return array_segments_type() == SparseIndexVector_Uint16Vector ? static_cast<const Uint16Vector *>(array_segments()) : nullptr;
  }
  const Uint8Vector *array_segments_as_Uint8Vector() const {
    return array_segments_type() == SparseIndexVector_Uint8Vector ? static_cast<const Uint8Vector *>(array_segments()) : nullptr;
  }
  SparseIndexVector array_indices_type() const {
    return static_cast<SparseIndexVector>(GetField<uint8_t>(12, 0));
  }
  const void *array_indices() const {
    return GetPointer<const void *>(14);
  }
  template<typename T> const T *array_indices_as() const;
  const Int32Vector *array_indices_as_Int32Vector() const {
    return array_indices_type() == SparseIndexVector_Int32Vector ? static_cast<const Int32Vector *>(array_indices()) : nullptr;
  }
  const Uint16Vector *array_indices_as_Uint16Vector() const {
    return array_indices_type() == SparseIndexVector_Uint16Vector ? static_cast<const Uint16Vector *>(array_indices()) : nullptr;
  }
  const Uint8Vector *array_indices_as_Uint8Vector() const {
    return array_indices_type() == SparseIndexVector_Uint8Vector ? static_cast<const Uint8Vector *>(array_indices()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           VerifyOffset(verifier, 10) &&
           VerifySparseIndexVector(verifier, array_segments(), array_segments_type()) &&
           VerifyField<uint8_t>(verifier, 12) &&
           VerifyOffset(verifier, 14) &&
           VerifySparseIndexVector(verifier, array_indices(), array_indices_type()) &&
           verifier.EndTable();
  }
  DimensionMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DimensionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DimensionMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Int32Vector *DimensionMetadata::array_segments_as<Int32Vector>() const {
  return array_segments_as_Int32Vector();
}

template<> inline const Uint16Vector *DimensionMetadata::array_segments_as<Uint16Vector>() const {
  return array_segments_as_Uint16Vector();
}

template<> inline const Uint8Vector *DimensionMetadata::array_segments_as<Uint8Vector>() const {
  return array_segments_as_Uint8Vector();
}

template<> inline const Int32Vector *DimensionMetadata::array_indices_as<Int32Vector>() const {
  return array_indices_as_Int32Vector();
}

template<> inline const Uint16Vector *DimensionMetadata::array_indices_as<Uint16Vector>() const {
  return array_indices_as_Uint16Vector();
}

template<> inline const Uint8Vector *DimensionMetadata::array_indices_as<Uint8Vector>() const {
  return array_indices_as_Uint8Vector();
}

struct DimensionMetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(DimensionType format) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(format), 0);
  }
  void add_dense_size(int32_t dense_size) {
    fbb_.AddElement<int32_t>(6, dense_size, 0);
  }
  void add_array_segments_type(SparseIndexVector array_segments_type) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(array_segments_type), 0);
  }
  void add_array_segments(flatbuffers::Offset<void> array_segments) {
    fbb_.AddOffset(10, array_segments);
  }
  void add_array_indices_type(SparseIndexVector array_indices_type) {
    fbb_.AddElement<uint8_t>(12, static_cast<uint8_t>(array_indices_type), 0);
  }
  void add_array_indices(flatbuffers::Offset<void> array_indices) {
    fbb_.AddOffset(14, array_indices);
  }
  explicit DimensionMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionMetadataBuilder &operator=(const DimensionMetadataBuilder &);
  flatbuffers::Offset<DimensionMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    DimensionType format = DimensionType_DENSE,
    int32_t dense_size = 0,
    SparseIndexVector array_segments_type = SparseIndexVector_NONE,
    flatbuffers::Offset<void> array_segments = 0,
    SparseIndexVector array_indices_type = SparseIndexVector_NONE,
    flatbuffers::Offset<void> array_indices = 0) {
  DimensionMetadataBuilder builder_(_fbb);
  builder_.add_array_indices(array_indices);
  builder_.add_array_segments(array_segments);
  builder_.add_dense_size(dense_size);
  builder_.add_array_indices_type(array_indices_type);
  builder_.add_array_segments_type(array_segments_type);
  builder_.add_format(format);
  return builder_.Finish();
}

flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparsityParametersT : public flatbuffers::NativeTable {
  typedef SparsityParameters TableType;
  std::vector<int32_t> traversal_order;
  std::vector<int32_t> block_map;
  std::vector<std::unique_ptr<DimensionMetadataT>> dim_metadata;
  SparsityParametersT() {
  }
};

struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparsityParametersT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparsityParametersTypeTable();
  }
  const flatbuffers::Vector<int32_t> *traversal_order() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  const flatbuffers::Vector<int32_t> *block_map() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DimensionMetadata>> *dim_metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DimensionMetadata>> *>(8);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(traversal_order()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(block_map()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(dim_metadata()) &&
           verifier.VerifyVectorOfTables(dim_metadata()) &&
           verifier.EndTable();
  }
  SparsityParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparsityParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparsityParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparsityParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_traversal_order(flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order) {
    fbb_.AddOffset(4, traversal_order);
  }
  void add_block_map(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map) {
    fbb_.AddOffset(6, block_map);
  }
  void add_dim_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DimensionMetadata>>> dim_metadata) {
    fbb_.AddOffset(8, dim_metadata);
  }
  explicit SparsityParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparsityParametersBuilder &operator=(const SparsityParametersBuilder &);
  flatbuffers::Offset<SparsityParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparsityParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DimensionMetadata>>> dim_metadata = 0) {
  SparsityParametersBuilder builder_(_fbb);
  builder_.add_dim_metadata(dim_metadata);
  builder_.add_block_map(block_map);
  builder_.add_traversal_order(traversal_order);
  return builder_.Finish();
}

flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VariantSubTypeT : public flatbuffers::NativeTable {
  typedef VariantSubType TableType;
  std::vector<int32_t> shape;
  TensorType type;
  bool has_rank;
  VariantSubTypeT()
      : type(TensorType_FLOAT32),
        has_rank(false) {
  }
};

struct VariantSubType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VariantSubTypeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VariantSubTypeTypeTable();
  }
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  TensorType type() const {
    return static_cast<TensorType>(GetField<int8_t>(6, 0));
  }
  bool has_rank() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  VariantSubTypeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VariantSubTypeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VariantSubType> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VariantSubTypeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(4, shape);
  }
  void add_type(TensorType type) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(type), 0);
  }
  void add_has_rank(bool has_rank) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(has_rank), 0);
  }
  explicit VariantSubTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VariantSubTypeBuilder &operator=(const VariantSubTypeBuilder &);
  flatbuffers::Offset<VariantSubType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VariantSubType>(end);
    return o;
  }
};

inline flatbuffers::Offset<VariantSubType> CreateVariantSubType(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
    TensorType type = TensorType_FLOAT32,
    bool has_rank = false) {
  VariantSubTypeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_has_rank(has_rank);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<VariantSubType> CreateVariantSubType(flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorT : public flatbuffers::NativeTable {
  typedef Tensor TableType;
  std::vector<int32_t> shape;
  TensorType type;
  uint32_t buffer;
  std::string name;
  std::unique_ptr<QuantizationParametersT> quantization;
  bool is_variable;
  std::unique_ptr<SparsityParametersT> sparsity;
  std::vector<int32_t> shape_signature;
  bool has_rank;
  std::vector<std::unique_ptr<VariantSubTypeT>> variant_tensors;
  TensorT()
      : type(TensorType_FLOAT32),
        buffer(0),
        is_variable(false),
        has_rank(false) {
  }
};

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorTypeTable();
  }
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  TensorType type() const {
    return static_cast<TensorType>(GetField<int8_t>(6, 0));
  }
  uint32_t buffer() const {
    return GetField<uint32_t>(8, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(10);
  }
  const QuantizationParameters *quantization() const {
    return GetPointer<const QuantizationParameters *>(12);
  }
  bool is_variable() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  const SparsityParameters *sparsity() const {
    return GetPointer<const SparsityParameters *>(16);
  }
  const flatbuffers::Vector<int32_t> *shape_signature() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(18);
  }
  bool has_rank() const {
    return GetField<uint8_t>(20, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<VariantSubType>> *variant_tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VariantSubType>> *>(22);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, 6) &&
           VerifyField<uint32_t>(verifier, 8) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyTable(quantization()) &&
           VerifyField<uint8_t>(verifier, 14) &&
           VerifyOffset(verifier, 16) &&
           verifier.VerifyTable(sparsity()) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyVector(shape_signature()) &&
           VerifyField<uint8_t>(verifier, 20) &&
           VerifyOffset(verifier, 22) &&
           verifier.VerifyVector(variant_tensors()) &&
           verifier.VerifyVectorOfTables(variant_tensors()) &&
           verifier.EndTable();
  }
  TensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(4, shape);
  }
  void add_type(TensorType type) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(type), 0);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(8, buffer, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(10, name);
  }
  void add_quantization(flatbuffers::Offset<QuantizationParameters> quantization) {
    fbb_.AddOffset(12, quantization);
  }
  void add_is_variable(bool is_variable) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(is_variable), 0);
  }
  void add_sparsity(flatbuffers::Offset<SparsityParameters> sparsity) {
    fbb_.AddOffset(16, sparsity);
  }
  void add_shape_signature(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature) {
    fbb_.AddOffset(18, shape_signature);
  }
  void add_has_rank(bool has_rank) {
    fbb_.AddElement<uint8_t>(20, static_cast<uint8_t>(has_rank), 0);
  }
  void add_variant_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VariantSubType>>> variant_tensors) {
    fbb_.AddOffset(22, variant_tensors);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
    TensorType type = TensorType_FLOAT32,
    uint32_t buffer = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<QuantizationParameters> quantization = 0,
    bool is_variable = false,
    flatbuffers::Offset<SparsityParameters> sparsity = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature = 0,
    bool has_rank = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VariantSubType>>> variant_tensors = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_variant_tensors(variant_tensors);
  builder_.add_shape_signature(shape_signature);
  builder_.add_sparsity(sparsity);
  builder_.add_quantization(quantization);
  builder_.add_name(name);
  builder_.add_buffer(buffer);
  builder_.add_shape(shape);
  builder_.add_has_rank(has_rank);
  builder_.add_is_variable(is_variable);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloGatherOptionsT : public flatbuffers::NativeTable {
  typedef StablehloGatherOptions TableType;
  std::vector<int64_t> offset_dims;
  std::vector<int64_t> collapsed_slice_dims;
  std::vector<int64_t> start_index_map;
  int64_t index_vector_dim;
  std::vector<int64_t> slice_sizes;
  bool indices_are_sorted;
  StablehloGatherOptionsT()
      : index_vector_dim(0),
        indices_are_sorted(false) {
  }
};

struct StablehloGatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloGatherOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloGatherOptionsTypeTable();
  }
  const flatbuffers::Vector<int64_t> *offset_dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(4);
  }
  const flatbuffers::Vector<int64_t> *collapsed_slice_dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(6);
  }
  const flatbuffers::Vector<int64_t> *start_index_map() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(8);
  }
  int64_t index_vector_dim() const {
    return GetField<int64_t>(10, 0);
  }
  const flatbuffers::Vector<int64_t> *slice_sizes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(12);
  }
  bool indices_are_sorted() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(offset_dims()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(collapsed_slice_dims()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(start_index_map()) &&
           VerifyField<int64_t>(verifier, 10) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(slice_sizes()) &&
           VerifyField<uint8_t>(verifier, 14) &&
           verifier.EndTable();
  }
  StablehloGatherOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloGatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloGatherOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloGatherOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloGatherOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> offset_dims) {
    fbb_.AddOffset(4, offset_dims);
  }
  void add_collapsed_slice_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> collapsed_slice_dims) {
    fbb_.AddOffset(6, collapsed_slice_dims);
  }
  void add_start_index_map(flatbuffers::Offset<flatbuffers::Vector<int64_t>> start_index_map) {
    fbb_.AddOffset(8, start_index_map);
  }
  void add_index_vector_dim(int64_t index_vector_dim) {
    fbb_.AddElement<int64_t>(10, index_vector_dim, 0);
  }
  void add_slice_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> slice_sizes) {
    fbb_.AddOffset(12, slice_sizes);
  }
  void add_indices_are_sorted(bool indices_are_sorted) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(indices_are_sorted), 0);
  }
  explicit StablehloGatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloGatherOptionsBuilder &operator=(const StablehloGatherOptionsBuilder &);
  flatbuffers::Offset<StablehloGatherOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloGatherOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloGatherOptions> CreateStablehloGatherOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> offset_dims = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> collapsed_slice_dims = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> start_index_map = 0,
    int64_t index_vector_dim = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> slice_sizes = 0,
    bool indices_are_sorted = false) {
  StablehloGatherOptionsBuilder builder_(_fbb);
  builder_.add_index_vector_dim(index_vector_dim);
  builder_.add_slice_sizes(slice_sizes);
  builder_.add_start_index_map(start_index_map);
  builder_.add_collapsed_slice_dims(collapsed_slice_dims);
  builder_.add_offset_dims(offset_dims);
  builder_.add_indices_are_sorted(indices_are_sorted);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloGatherOptions> CreateStablehloGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloGatherOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloTransposeOptionsT : public flatbuffers::NativeTable {
  typedef StablehloTransposeOptions TableType;
  std::vector<int64_t> permutation;
  StablehloTransposeOptionsT() {
  }
};

struct StablehloTransposeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloTransposeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloTransposeOptionsTypeTable();
  }
  const flatbuffers::Vector<int64_t> *permutation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(permutation()) &&
           verifier.EndTable();
  }
  StablehloTransposeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloTransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloTransposeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloTransposeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloTransposeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_permutation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> permutation) {
    fbb_.AddOffset(4, permutation);
  }
  explicit StablehloTransposeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloTransposeOptionsBuilder &operator=(const StablehloTransposeOptionsBuilder &);
  flatbuffers::Offset<StablehloTransposeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloTransposeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloTransposeOptions> CreateStablehloTransposeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> permutation = 0) {
  StablehloTransposeOptionsBuilder builder_(_fbb);
  builder_.add_permutation(permutation);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloTransposeOptions> CreateStablehloTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloTransposeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloDotGeneralOptionsT : public flatbuffers::NativeTable {
  typedef StablehloDotGeneralOptions TableType;
  std::vector<int64_t> lhs_batching_dimensions;
  std::vector<int64_t> rhs_batching_dimensions;
  std::vector<int64_t> lhs_contracting_dimensions;
  std::vector<int64_t> rhs_contracting_dimensions;
  std::vector<StablehloPrecisionConfig> precision_config;
  StablehloDotGeneralOptionsT() {
  }
};

struct StablehloDotGeneralOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloDotGeneralOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloDotGeneralOptionsTypeTable();
  }
  const flatbuffers::Vector<int64_t> *lhs_batching_dimensions() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(4);
  }
  const flatbuffers::Vector<int64_t> *rhs_batching_dimensions() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(6);
  }
  const flatbuffers::Vector<int64_t> *lhs_contracting_dimensions() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(8);
  }
  const flatbuffers::Vector<int64_t> *rhs_contracting_dimensions() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(10);
  }
  const flatbuffers::Vector<uint32_t> *precision_config() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(12);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(lhs_batching_dimensions()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(rhs_batching_dimensions()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(lhs_contracting_dimensions()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(rhs_contracting_dimensions()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(precision_config()) &&
           verifier.EndTable();
  }
  StablehloDotGeneralOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloDotGeneralOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloDotGeneralOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloDotGeneralOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloDotGeneralOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lhs_batching_dimensions(flatbuffers::Offset<flatbuffers::Vector<int64_t>> lhs_batching_dimensions) {
    fbb_.AddOffset(4, lhs_batching_dimensions);
  }
  void add_rhs_batching_dimensions(flatbuffers::Offset<flatbuffers::Vector<int64_t>> rhs_batching_dimensions) {
    fbb_.AddOffset(6, rhs_batching_dimensions);
  }
  void add_lhs_contracting_dimensions(flatbuffers::Offset<flatbuffers::Vector<int64_t>> lhs_contracting_dimensions) {
    fbb_.AddOffset(8, lhs_contracting_dimensions);
  }
  void add_rhs_contracting_dimensions(flatbuffers::Offset<flatbuffers::Vector<int64_t>> rhs_contracting_dimensions) {
    fbb_.AddOffset(10, rhs_contracting_dimensions);
  }
  void add_precision_config(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> precision_config) {
    fbb_.AddOffset(12, precision_config);
  }
  explicit StablehloDotGeneralOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloDotGeneralOptionsBuilder &operator=(const StablehloDotGeneralOptionsBuilder &);
  flatbuffers::Offset<StablehloDotGeneralOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloDotGeneralOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloDotGeneralOptions> CreateStablehloDotGeneralOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> lhs_batching_dimensions = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> rhs_batching_dimensions = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> lhs_contracting_dimensions = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> rhs_contracting_dimensions = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> precision_config = 0) {
  StablehloDotGeneralOptionsBuilder builder_(_fbb);
  builder_.add_precision_config(precision_config);
  builder_.add_rhs_contracting_dimensions(rhs_contracting_dimensions);
  builder_.add_lhs_contracting_dimensions(lhs_contracting_dimensions);
  builder_.add_rhs_batching_dimensions(rhs_batching_dimensions);
  builder_.add_lhs_batching_dimensions(lhs_batching_dimensions);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloDotGeneralOptions> CreateStablehloDotGeneralOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloDotGeneralOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloReduceWindowOptionsT : public flatbuffers::NativeTable {
  typedef StablehloReduceWindowOptions TableType;
  std::vector<int64_t> window_dimensions;
  std::vector<int64_t> window_strides;
  std::vector<int64_t> base_dilations;
  std::vector<int64_t> window_dilations;
  std::vector<int64_t> padding;
  int32_t body_subgraph_index;
  StablehloReduceWindowOptionsT()
      : body_subgraph_index(0) {
  }
};

struct StablehloReduceWindowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloReduceWindowOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloReduceWindowOptionsTypeTable();
  }
  const flatbuffers::Vector<int64_t> *window_dimensions() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(4);
  }
  const flatbuffers::Vector<int64_t> *window_strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(6);
  }
  const flatbuffers::Vector<int64_t> *base_dilations() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(8);
  }
  const flatbuffers::Vector<int64_t> *window_dilations() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(10);
  }
  const flatbuffers::Vector<int64_t> *padding() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(12);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(14, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(window_dimensions()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(window_strides()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(base_dilations()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(window_dilations()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(padding()) &&
           VerifyField<int32_t>(verifier, 14) &&
           verifier.EndTable();
  }
  StablehloReduceWindowOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloReduceWindowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloReduceWindowOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceWindowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloReduceWindowOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_window_dimensions(flatbuffers::Offset<flatbuffers::Vector<int64_t>> window_dimensions) {
    fbb_.AddOffset(4, window_dimensions);
  }
  void add_window_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> window_strides) {
    fbb_.AddOffset(6, window_strides);
  }
  void add_base_dilations(flatbuffers::Offset<flatbuffers::Vector<int64_t>> base_dilations) {
    fbb_.AddOffset(8, base_dilations);
  }
  void add_window_dilations(flatbuffers::Offset<flatbuffers::Vector<int64_t>> window_dilations) {
    fbb_.AddOffset(10, window_dilations);
  }
  void add_padding(flatbuffers::Offset<flatbuffers::Vector<int64_t>> padding) {
    fbb_.AddOffset(12, padding);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(14, body_subgraph_index, 0);
  }
  explicit StablehloReduceWindowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloReduceWindowOptionsBuilder &operator=(const StablehloReduceWindowOptionsBuilder &);
  flatbuffers::Offset<StablehloReduceWindowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloReduceWindowOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloReduceWindowOptions> CreateStablehloReduceWindowOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> window_dimensions = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> window_strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> base_dilations = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> window_dilations = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> padding = 0,
    int32_t body_subgraph_index = 0) {
  StablehloReduceWindowOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_padding(padding);
  builder_.add_window_dilations(window_dilations);
  builder_.add_base_dilations(base_dilations);
  builder_.add_window_strides(window_strides);
  builder_.add_window_dimensions(window_dimensions);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloReduceWindowOptions> CreateStablehloReduceWindowOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceWindowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloWhileOptionsT : public flatbuffers::NativeTable {
  typedef StablehloWhileOptions TableType;
  int32_t cond_subgraph_index;
  int32_t body_subgraph_index;
  StablehloWhileOptionsT()
      : cond_subgraph_index(0),
        body_subgraph_index(0) {
  }
};

struct StablehloWhileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloWhileOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloWhileOptionsTypeTable();
  }
  int32_t cond_subgraph_index() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  StablehloWhileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloWhileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloWhileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloWhileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloWhileOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cond_subgraph_index(int32_t cond_subgraph_index) {
    fbb_.AddElement<int32_t>(4, cond_subgraph_index, 0);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(6, body_subgraph_index, 0);
  }
  explicit StablehloWhileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloWhileOptionsBuilder &operator=(const StablehloWhileOptionsBuilder &);
  flatbuffers::Offset<StablehloWhileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloWhileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloWhileOptions> CreateStablehloWhileOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cond_subgraph_index = 0,
    int32_t body_subgraph_index = 0) {
  StablehloWhileOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_cond_subgraph_index(cond_subgraph_index);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloWhileOptions> CreateStablehloWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloWhileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloSortOptionsT : public flatbuffers::NativeTable {
  typedef StablehloSortOptions TableType;
  int64_t dimension;
  bool is_stable;
  int32_t comparator_subgraph_index;
  StablehloSortOptionsT()
      : dimension(0),
        is_stable(false),
        comparator_subgraph_index(0) {
  }
};

struct StablehloSortOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloSortOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloSortOptionsTypeTable();
  }
  int64_t dimension() const {
    return GetField<int64_t>(4, 0);
  }
  bool is_stable() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  int32_t comparator_subgraph_index() const {
    return GetField<int32_t>(8, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           verifier.EndTable();
  }
  StablehloSortOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloSortOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloSortOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloSortOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloSortOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dimension(int64_t dimension) {
    fbb_.AddElement<int64_t>(4, dimension, 0);
  }
  void add_is_stable(bool is_stable) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(is_stable), 0);
  }
  void add_comparator_subgraph_index(int32_t comparator_subgraph_index) {
    fbb_.AddElement<int32_t>(8, comparator_subgraph_index, 0);
  }
  explicit StablehloSortOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloSortOptionsBuilder &operator=(const StablehloSortOptionsBuilder &);
  flatbuffers::Offset<StablehloSortOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloSortOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloSortOptions> CreateStablehloSortOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t dimension = 0,
    bool is_stable = false,
    int32_t comparator_subgraph_index = 0) {
  StablehloSortOptionsBuilder builder_(_fbb);
  builder_.add_dimension(dimension);
  builder_.add_comparator_subgraph_index(comparator_subgraph_index);
  builder_.add_is_stable(is_stable);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloSortOptions> CreateStablehloSortOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloSortOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloConcatenateOptionsT : public flatbuffers::NativeTable {
  typedef StablehloConcatenateOptions TableType;
  int64_t dimension;
  StablehloConcatenateOptionsT()
      : dimension(0) {
  }
};

struct StablehloConcatenateOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloConcatenateOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloConcatenateOptionsTypeTable();
  }
  int64_t dimension() const {
    return GetField<int64_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4) &&
           verifier.EndTable();
  }
  StablehloConcatenateOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloConcatenateOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloConcatenateOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloConcatenateOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloConcatenateOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dimension(int64_t dimension) {
    fbb_.AddElement<int64_t>(4, dimension, 0);
  }
  explicit StablehloConcatenateOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloConcatenateOptionsBuilder &operator=(const StablehloConcatenateOptionsBuilder &);
  flatbuffers::Offset<StablehloConcatenateOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloConcatenateOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloConcatenateOptions> CreateStablehloConcatenateOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t dimension = 0) {
  StablehloConcatenateOptionsBuilder builder_(_fbb);
  builder_.add_dimension(dimension);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloConcatenateOptions> CreateStablehloConcatenateOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloConcatenateOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloBroadcastInDimOptionsT : public flatbuffers::NativeTable {
  typedef StablehloBroadcastInDimOptions TableType;
  std::vector<int64_t> broadcast_dimensions;
  StablehloBroadcastInDimOptionsT() {
  }
};

struct StablehloBroadcastInDimOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloBroadcastInDimOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloBroadcastInDimOptionsTypeTable();
  }
  const flatbuffers::Vector<int64_t> *broadcast_dimensions() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(broadcast_dimensions()) &&
           verifier.EndTable();
  }
  StablehloBroadcastInDimOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloBroadcastInDimOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloBroadcastInDimOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloBroadcastInDimOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloBroadcastInDimOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_broadcast_dimensions(flatbuffers::Offset<flatbuffers::Vector<int64_t>> broadcast_dimensions) {
    fbb_.AddOffset(4, broadcast_dimensions);
  }
  explicit StablehloBroadcastInDimOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloBroadcastInDimOptionsBuilder &operator=(const StablehloBroadcastInDimOptionsBuilder &);
  flatbuffers::Offset<StablehloBroadcastInDimOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloBroadcastInDimOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloBroadcastInDimOptions> CreateStablehloBroadcastInDimOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> broadcast_dimensions = 0) {
  StablehloBroadcastInDimOptionsBuilder builder_(_fbb);
  builder_.add_broadcast_dimensions(broadcast_dimensions);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloBroadcastInDimOptions> CreateStablehloBroadcastInDimOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloBroadcastInDimOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloCompareOptionsT : public flatbuffers::NativeTable {
  typedef StablehloCompareOptions TableType;
  StablehloComparisonDirection comparison_direction;
  StablehloComparisonType compare_type;
  StablehloCompareOptionsT()
      : comparison_direction(StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ),
        compare_type(StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE) {
  }
};

struct StablehloCompareOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloCompareOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloCompareOptionsTypeTable();
  }
  StablehloComparisonDirection comparison_direction() const {
    return static_cast<StablehloComparisonDirection>(GetField<uint32_t>(4, 0));
  }
  StablehloComparisonType compare_type() const {
    return static_cast<StablehloComparisonType>(GetField<uint32_t>(6, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4) &&
           VerifyField<uint32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  StablehloCompareOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloCompareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloCompareOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCompareOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloCompareOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_comparison_direction(StablehloComparisonDirection comparison_direction) {
    fbb_.AddElement<uint32_t>(4, static_cast<uint32_t>(comparison_direction), 0);
  }
  void add_compare_type(StablehloComparisonType compare_type) {
    fbb_.AddElement<uint32_t>(6, static_cast<uint32_t>(compare_type), 0);
  }
  explicit StablehloCompareOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloCompareOptionsBuilder &operator=(const StablehloCompareOptionsBuilder &);
  flatbuffers::Offset<StablehloCompareOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloCompareOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloCompareOptions> CreateStablehloCompareOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    StablehloComparisonDirection comparison_direction = StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ,
    StablehloComparisonType compare_type = StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE) {
  StablehloCompareOptionsBuilder builder_(_fbb);
  builder_.add_compare_type(compare_type);
  builder_.add_comparison_direction(comparison_direction);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloCompareOptions> CreateStablehloCompareOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCompareOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloDynamicSliceOptionsT : public flatbuffers::NativeTable {
  typedef StablehloDynamicSliceOptions TableType;
  std::vector<int64_t> slice_sizes;
  StablehloDynamicSliceOptionsT() {
  }
};

struct StablehloDynamicSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloDynamicSliceOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloDynamicSliceOptionsTypeTable();
  }
  const flatbuffers::Vector<int64_t> *slice_sizes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(slice_sizes()) &&
           verifier.EndTable();
  }
  StablehloDynamicSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloDynamicSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloDynamicSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloDynamicSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloDynamicSliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slice_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> slice_sizes) {
    fbb_.AddOffset(4, slice_sizes);
  }
  explicit StablehloDynamicSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloDynamicSliceOptionsBuilder &operator=(const StablehloDynamicSliceOptionsBuilder &);
  flatbuffers::Offset<StablehloDynamicSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloDynamicSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloDynamicSliceOptions> CreateStablehloDynamicSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> slice_sizes = 0) {
  StablehloDynamicSliceOptionsBuilder builder_(_fbb);
  builder_.add_slice_sizes(slice_sizes);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloDynamicSliceOptions> CreateStablehloDynamicSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloDynamicSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloPadOptionsT : public flatbuffers::NativeTable {
  typedef StablehloPadOptions TableType;
  std::vector<int64_t> edge_padding_low;
  std::vector<int64_t> edge_padding_high;
  std::vector<int64_t> interior_padding;
  StablehloPadOptionsT() {
  }
};

struct StablehloPadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloPadOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloPadOptionsTypeTable();
  }
  const flatbuffers::Vector<int64_t> *edge_padding_low() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(4);
  }
  const flatbuffers::Vector<int64_t> *edge_padding_high() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(6);
  }
  const flatbuffers::Vector<int64_t> *interior_padding() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(8);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(edge_padding_low()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(edge_padding_high()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(interior_padding()) &&
           verifier.EndTable();
  }
  StablehloPadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloPadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloPadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloPadOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_edge_padding_low(flatbuffers::Offset<flatbuffers::Vector<int64_t>> edge_padding_low) {
    fbb_.AddOffset(4, edge_padding_low);
  }
  void add_edge_padding_high(flatbuffers::Offset<flatbuffers::Vector<int64_t>> edge_padding_high) {
    fbb_.AddOffset(6, edge_padding_high);
  }
  void add_interior_padding(flatbuffers::Offset<flatbuffers::Vector<int64_t>> interior_padding) {
    fbb_.AddOffset(8, interior_padding);
  }
  explicit StablehloPadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloPadOptionsBuilder &operator=(const StablehloPadOptionsBuilder &);
  flatbuffers::Offset<StablehloPadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloPadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloPadOptions> CreateStablehloPadOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> edge_padding_low = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> edge_padding_high = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> interior_padding = 0) {
  StablehloPadOptionsBuilder builder_(_fbb);
  builder_.add_interior_padding(interior_padding);
  builder_.add_edge_padding_high(edge_padding_high);
  builder_.add_edge_padding_low(edge_padding_low);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloPadOptions> CreateStablehloPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloPadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloIotaOptionsT : public flatbuffers::NativeTable {
  typedef StablehloIotaOptions TableType;
  int64_t iota_dimension;
  StablehloIotaOptionsT()
      : iota_dimension(0) {
  }
};

struct StablehloIotaOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloIotaOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloIotaOptionsTypeTable();
  }
  int64_t iota_dimension() const {
    return GetField<int64_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4) &&
           verifier.EndTable();
  }
  StablehloIotaOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloIotaOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloIotaOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloIotaOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloIotaOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_iota_dimension(int64_t iota_dimension) {
    fbb_.AddElement<int64_t>(4, iota_dimension, 0);
  }
  explicit StablehloIotaOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloIotaOptionsBuilder &operator=(const StablehloIotaOptionsBuilder &);
  flatbuffers::Offset<StablehloIotaOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloIotaOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloIotaOptions> CreateStablehloIotaOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t iota_dimension = 0) {
  StablehloIotaOptionsBuilder builder_(_fbb);
  builder_.add_iota_dimension(iota_dimension);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloIotaOptions> CreateStablehloIotaOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloIotaOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloCustomCallOptionsT : public flatbuffers::NativeTable {
  typedef StablehloCustomCallOptions TableType;
  std::string call_target_name;
  bool has_side_effect;
  std::string backend_config;
  int32_t api_version;
  std::vector<int32_t> called_computations;
  std::vector<uint8_t> custom_attributes;
  StablehloCustomCallOptionsT()
      : has_side_effect(false),
        api_version(0) {
  }
};

struct StablehloCustomCallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloCustomCallOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloCustomCallOptionsTypeTable();
  }
  const flatbuffers::String *call_target_name() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  bool has_side_effect() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  const flatbuffers::String *backend_config() const {
    return GetPointer<const flatbuffers::String *>(8);
  }
  int32_t api_version() const {
    return GetField<int32_t>(10, 0);
  }
  const flatbuffers::Vector<int32_t> *called_computations() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(12);
  }
  const flatbuffers::Vector<uint8_t> *custom_attributes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(14);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(call_target_name()) &&
           VerifyField<uint8_t>(verifier, 6) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyString(backend_config()) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(called_computations()) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyVector(custom_attributes()) &&
           verifier.EndTable();
  }
  StablehloCustomCallOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloCustomCallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloCustomCallOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCustomCallOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloCustomCallOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_call_target_name(flatbuffers::Offset<flatbuffers::String> call_target_name) {
    fbb_.AddOffset(4, call_target_name);
  }
  void add_has_side_effect(bool has_side_effect) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(has_side_effect), 0);
  }
  void add_backend_config(flatbuffers::Offset<flatbuffers::String> backend_config) {
    fbb_.AddOffset(8, backend_config);
  }
  void add_api_version(int32_t api_version) {
    fbb_.AddElement<int32_t>(10, api_version, 0);
  }
  void add_called_computations(flatbuffers::Offset<flatbuffers::Vector<int32_t>> called_computations) {
    fbb_.AddOffset(12, called_computations);
  }
  void add_custom_attributes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_attributes) {
    fbb_.AddOffset(14, custom_attributes);
  }
  explicit StablehloCustomCallOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloCustomCallOptionsBuilder &operator=(const StablehloCustomCallOptionsBuilder &);
  flatbuffers::Offset<StablehloCustomCallOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloCustomCallOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloCustomCallOptions> CreateStablehloCustomCallOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> call_target_name = 0,
    bool has_side_effect = false,
    flatbuffers::Offset<flatbuffers::String> backend_config = 0,
    int32_t api_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> called_computations = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_attributes = 0) {
  StablehloCustomCallOptionsBuilder builder_(_fbb);
  builder_.add_custom_attributes(custom_attributes);
  builder_.add_called_computations(called_computations);
  builder_.add_api_version(api_version);
  builder_.add_backend_config(backend_config);
  builder_.add_call_target_name(call_target_name);
  builder_.add_has_side_effect(has_side_effect);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloCustomCallOptions> CreateStablehloCustomCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCustomCallOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloReduceOptionsT : public flatbuffers::NativeTable {
  typedef StablehloReduceOptions TableType;
  std::vector<int64_t> dimensions;
  int32_t body_subgraph_index;
  StablehloReduceOptionsT()
      : body_subgraph_index(0) {
  }
};

struct StablehloReduceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloReduceOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloReduceOptionsTypeTable();
  }
  const flatbuffers::Vector<int64_t> *dimensions() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(4);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(dimensions()) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  StablehloReduceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloReduceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloReduceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloReduceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dimensions(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dimensions) {
    fbb_.AddOffset(4, dimensions);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(6, body_subgraph_index, 0);
  }
  explicit StablehloReduceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloReduceOptionsBuilder &operator=(const StablehloReduceOptionsBuilder &);
  flatbuffers::Offset<StablehloReduceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloReduceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloReduceOptions> CreateStablehloReduceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dimensions = 0,
    int32_t body_subgraph_index = 0) {
  StablehloReduceOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_dimensions(dimensions);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloReduceOptions> CreateStablehloReduceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloSliceOptionsT : public flatbuffers::NativeTable {
  typedef StablehloSliceOptions TableType;
  std::vector<int64_t> start_indices;
  std::vector<int64_t> limit_indices;
  std::vector<int64_t> strides;
  StablehloSliceOptionsT() {
  }
};

struct StablehloSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloSliceOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloSliceOptionsTypeTable();
  }
  const flatbuffers::Vector<int64_t> *start_indices() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(4);
  }
  const flatbuffers::Vector<int64_t> *limit_indices() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(6);
  }
  const flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(8);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(start_indices()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(limit_indices()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(strides()) &&
           verifier.EndTable();
  }
  StablehloSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloSliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_indices(flatbuffers::Offset<flatbuffers::Vector<int64_t>> start_indices) {
    fbb_.AddOffset(4, start_indices);
  }
  void add_limit_indices(flatbuffers::Offset<flatbuffers::Vector<int64_t>> limit_indices) {
    fbb_.AddOffset(6, limit_indices);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(8, strides);
  }
  explicit StablehloSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloSliceOptionsBuilder &operator=(const StablehloSliceOptionsBuilder &);
  flatbuffers::Offset<StablehloSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloSliceOptions> CreateStablehloSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> start_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> limit_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0) {
  StablehloSliceOptionsBuilder builder_(_fbb);
  builder_.add_strides(strides);
  builder_.add_limit_indices(limit_indices);
  builder_.add_start_indices(start_indices);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloSliceOptions> CreateStablehloSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloConvolutionOptionsT : public flatbuffers::NativeTable {
  typedef StablehloConvolutionOptions TableType;
  std::vector<int64_t> window_strides;
  std::vector<int64_t> padding;
  std::vector<int64_t> lhs_dilation;
  std::vector<int64_t> rhs_dilation;
  std::vector<bool> window_reversal;
  int64_t input_batch_dimension;
  int64_t input_feature_dimension;
  std::vector<int64_t> input_spatial_dimensions;
  int64_t kernel_input_feature_dimension;
  int64_t kernel_output_feature_dimension;
  std::vector<int64_t> kernel_spatial_dimensions;
  int64_t output_batch_dimension;
  int64_t output_feature_dimension;
  std::vector<int64_t> output_spatial_dimensions;
  int64_t feature_group_count;
  int64_t batch_group_count;
  std::vector<StablehloPrecisionConfig> precision_config;
  StablehloConvolutionOptionsT()
      : input_batch_dimension(0),
        input_feature_dimension(0),
        kernel_input_feature_dimension(0),
        kernel_output_feature_dimension(0),
        output_batch_dimension(0),
        output_feature_dimension(0),
        feature_group_count(0),
        batch_group_count(0) {
  }
};

struct StablehloConvolutionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloConvolutionOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloConvolutionOptionsTypeTable();
  }
  const flatbuffers::Vector<int64_t> *window_strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(4);
  }
  const flatbuffers::Vector<int64_t> *padding() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(6);
  }
  const flatbuffers::Vector<int64_t> *lhs_dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(8);
  }
  const flatbuffers::Vector<int64_t> *rhs_dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(10);
  }
  const flatbuffers::Vector<uint8_t> *window_reversal() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(12);
  }
  int64_t input_batch_dimension() const {
    return GetField<int64_t>(14, 0);
  }
  int64_t input_feature_dimension() const {
    return GetField<int64_t>(16, 0);
  }
  const flatbuffers::Vector<int64_t> *input_spatial_dimensions() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(18);
  }
  int64_t kernel_input_feature_dimension() const {
    return GetField<int64_t>(20, 0);
  }
  int64_t kernel_output_feature_dimension() const {
    return GetField<int64_t>(22, 0);
  }
  const flatbuffers::Vector<int64_t> *kernel_spatial_dimensions() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(24);
  }
  int64_t output_batch_dimension() const {
    return GetField<int64_t>(26, 0);
  }
  int64_t output_feature_dimension() const {
    return GetField<int64_t>(28, 0);
  }
  const flatbuffers::Vector<int64_t> *output_spatial_dimensions() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(30);
  }
  int64_t feature_group_count() const {
    return GetField<int64_t>(32, 0);
  }
  int64_t batch_group_count() const {
    return GetField<int64_t>(34, 0);
  }
  const flatbuffers::Vector<uint32_t> *precision_config() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(36);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(window_strides()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(padding()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(lhs_dilation()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(rhs_dilation()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(window_reversal()) &&
           VerifyField<int64_t>(verifier, 14) &&
           VerifyField<int64_t>(verifier, 16) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyVector(input_spatial_dimensions()) &&
           VerifyField<int64_t>(verifier, 20) &&
           VerifyField<int64_t>(verifier, 22) &&
           VerifyOffset(verifier, 24) &&
           verifier.VerifyVector(kernel_spatial_dimensions()) &&
           VerifyField<int64_t>(verifier, 26) &&
           VerifyField<int64_t>(verifier, 28) &&
           VerifyOffset(verifier, 30) &&
           verifier.VerifyVector(output_spatial_dimensions()) &&
           VerifyField<int64_t>(verifier, 32) &&
           VerifyField<int64_t>(verifier, 34) &&
           VerifyOffset(verifier, 36) &&
           verifier.VerifyVector(precision_config()) &&
           verifier.EndTable();
  }
  StablehloConvolutionOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloConvolutionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloConvolutionOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloConvolutionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloConvolutionOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_window_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> window_strides) {
    fbb_.AddOffset(4, window_strides);
  }
  void add_padding(flatbuffers::Offset<flatbuffers::Vector<int64_t>> padding) {
    fbb_.AddOffset(6, padding);
  }
  void add_lhs_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> lhs_dilation) {
    fbb_.AddOffset(8, lhs_dilation);
  }
  void add_rhs_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> rhs_dilation) {
    fbb_.AddOffset(10, rhs_dilation);
  }
  void add_window_reversal(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> window_reversal) {
    fbb_.AddOffset(12, window_reversal);
  }
  void add_input_batch_dimension(int64_t input_batch_dimension) {
    fbb_.AddElement<int64_t>(14, input_batch_dimension, 0);
  }
  void add_input_feature_dimension(int64_t input_feature_dimension) {
    fbb_.AddElement<int64_t>(16, input_feature_dimension, 0);
  }
  void add_input_spatial_dimensions(flatbuffers::Offset<flatbuffers::Vector<int64_t>> input_spatial_dimensions) {
    fbb_.AddOffset(18, input_spatial_dimensions);
  }
  void add_kernel_input_feature_dimension(int64_t kernel_input_feature_dimension) {
    fbb_.AddElement<int64_t>(20, kernel_input_feature_dimension, 0);
  }
  void add_kernel_output_feature_dimension(int64_t kernel_output_feature_dimension) {
    fbb_.AddElement<int64_t>(22, kernel_output_feature_dimension, 0);
  }
  void add_kernel_spatial_dimensions(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_spatial_dimensions) {
    fbb_.AddOffset(24, kernel_spatial_dimensions);
  }
  void add_output_batch_dimension(int64_t output_batch_dimension) {
    fbb_.AddElement<int64_t>(26, output_batch_dimension, 0);
  }
  void add_output_feature_dimension(int64_t output_feature_dimension) {
    fbb_.AddElement<int64_t>(28, output_feature_dimension, 0);
  }
  void add_output_spatial_dimensions(flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_spatial_dimensions) {
    fbb_.AddOffset(30, output_spatial_dimensions);
  }
  void add_feature_group_count(int64_t feature_group_count) {
    fbb_.AddElement<int64_t>(32, feature_group_count, 0);
  }
  void add_batch_group_count(int64_t batch_group_count) {
    fbb_.AddElement<int64_t>(34, batch_group_count, 0);
  }
  void add_precision_config(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> precision_config) {
    fbb_.AddOffset(36, precision_config);
  }
  explicit StablehloConvolutionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloConvolutionOptionsBuilder &operator=(const StablehloConvolutionOptionsBuilder &);
  flatbuffers::Offset<StablehloConvolutionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloConvolutionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloConvolutionOptions> CreateStablehloConvolutionOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> window_strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> padding = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> lhs_dilation = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> rhs_dilation = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> window_reversal = 0,
    int64_t input_batch_dimension = 0,
    int64_t input_feature_dimension = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> input_spatial_dimensions = 0,
    int64_t kernel_input_feature_dimension = 0,
    int64_t kernel_output_feature_dimension = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_spatial_dimensions = 0,
    int64_t output_batch_dimension = 0,
    int64_t output_feature_dimension = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_spatial_dimensions = 0,
    int64_t feature_group_count = 0,
    int64_t batch_group_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> precision_config = 0) {
  StablehloConvolutionOptionsBuilder builder_(_fbb);
  builder_.add_batch_group_count(batch_group_count);
  builder_.add_feature_group_count(feature_group_count);
  builder_.add_output_feature_dimension(output_feature_dimension);
  builder_.add_output_batch_dimension(output_batch_dimension);
  builder_.add_kernel_output_feature_dimension(kernel_output_feature_dimension);
  builder_.add_kernel_input_feature_dimension(kernel_input_feature_dimension);
  builder_.add_input_feature_dimension(input_feature_dimension);
  builder_.add_input_batch_dimension(input_batch_dimension);
  builder_.add_precision_config(precision_config);
  builder_.add_output_spatial_dimensions(output_spatial_dimensions);
  builder_.add_kernel_spatial_dimensions(kernel_spatial_dimensions);
  builder_.add_input_spatial_dimensions(input_spatial_dimensions);
  builder_.add_window_reversal(window_reversal);
  builder_.add_rhs_dilation(rhs_dilation);
  builder_.add_lhs_dilation(lhs_dilation);
  builder_.add_padding(padding);
  builder_.add_window_strides(window_strides);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloConvolutionOptions> CreateStablehloConvolutionOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloConvolutionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloScatterOptionsT : public flatbuffers::NativeTable {
  typedef StablehloScatterOptions TableType;
  bool indices_are_sorted;
  std::vector<int64_t> update_window_dims;
  std::vector<int64_t> inserted_window_dims;
  std::vector<int64_t> scatter_dims_to_operand_dims;
  int64_t index_vector_dim;
  bool unique_indices;
  int32_t update_computation_subgraph_index;
  StablehloScatterOptionsT()
      : indices_are_sorted(false),
        index_vector_dim(0),
        unique_indices(false),
        update_computation_subgraph_index(0) {
  }
};

struct StablehloScatterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloScatterOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloScatterOptionsTypeTable();
  }
  bool indices_are_sorted() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  const flatbuffers::Vector<int64_t> *update_window_dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(6);
  }
  const flatbuffers::Vector<int64_t> *inserted_window_dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(8);
  }
  const flatbuffers::Vector<int64_t> *scatter_dims_to_operand_dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(10);
  }
  int64_t index_vector_dim() const {
    return GetField<int64_t>(12, 0);
  }
  bool unique_indices() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  int32_t update_computation_subgraph_index() const {
    return GetField<int32_t>(16, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(update_window_dims()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(inserted_window_dims()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(scatter_dims_to_operand_dims()) &&
           VerifyField<int64_t>(verifier, 12) &&
           VerifyField<uint8_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           verifier.EndTable();
  }
  StablehloScatterOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloScatterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloScatterOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloScatterOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloScatterOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indices_are_sorted(bool indices_are_sorted) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(indices_are_sorted), 0);
  }
  void add_update_window_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> update_window_dims) {
    fbb_.AddOffset(6, update_window_dims);
  }
  void add_inserted_window_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> inserted_window_dims) {
    fbb_.AddOffset(8, inserted_window_dims);
  }
  void add_scatter_dims_to_operand_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> scatter_dims_to_operand_dims) {
    fbb_.AddOffset(10, scatter_dims_to_operand_dims);
  }
  void add_index_vector_dim(int64_t index_vector_dim) {
    fbb_.AddElement<int64_t>(12, index_vector_dim, 0);
  }
  void add_unique_indices(bool unique_indices) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(unique_indices), 0);
  }
  void add_update_computation_subgraph_index(int32_t update_computation_subgraph_index) {
    fbb_.AddElement<int32_t>(16, update_computation_subgraph_index, 0);
  }
  explicit StablehloScatterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloScatterOptionsBuilder &operator=(const StablehloScatterOptionsBuilder &);
  flatbuffers::Offset<StablehloScatterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloScatterOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloScatterOptions> CreateStablehloScatterOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool indices_are_sorted = false,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> update_window_dims = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> inserted_window_dims = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> scatter_dims_to_operand_dims = 0,
    int64_t index_vector_dim = 0,
    bool unique_indices = false,
    int32_t update_computation_subgraph_index = 0) {
  StablehloScatterOptionsBuilder builder_(_fbb);
  builder_.add_index_vector_dim(index_vector_dim);
  builder_.add_update_computation_subgraph_index(update_computation_subgraph_index);
  builder_.add_scatter_dims_to_operand_dims(scatter_dims_to_operand_dims);
  builder_.add_inserted_window_dims(inserted_window_dims);
  builder_.add_update_window_dims(update_window_dims);
  builder_.add_unique_indices(unique_indices);
  builder_.add_indices_are_sorted(indices_are_sorted);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloScatterOptions> CreateStablehloScatterOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloScatterOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloCaseOptionsT : public flatbuffers::NativeTable {
  typedef StablehloCaseOptions TableType;
  std::vector<int32_t> branch_subgraph_indices;
  StablehloCaseOptionsT() {
  }
};

struct StablehloCaseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloCaseOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloCaseOptionsTypeTable();
  }
  const flatbuffers::Vector<int32_t> *branch_subgraph_indices() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(branch_subgraph_indices()) &&
           verifier.EndTable();
  }
  StablehloCaseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloCaseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloCaseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCaseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloCaseOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_branch_subgraph_indices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> branch_subgraph_indices) {
    fbb_.AddOffset(4, branch_subgraph_indices);
  }
  explicit StablehloCaseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloCaseOptionsBuilder &operator=(const StablehloCaseOptionsBuilder &);
  flatbuffers::Offset<StablehloCaseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloCaseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloCaseOptions> CreateStablehloCaseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> branch_subgraph_indices = 0) {
  StablehloCaseOptionsBuilder builder_(_fbb);
  builder_.add_branch_subgraph_indices(branch_subgraph_indices);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloCaseOptions> CreateStablehloCaseOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCaseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloRngBitGeneratorOptionsT : public flatbuffers::NativeTable {
  typedef StablehloRngBitGeneratorOptions TableType;
  RngAlgorithm algorithm;
  StablehloRngBitGeneratorOptionsT()
      : algorithm(RngAlgorithm_DEFAULT) {
  }
};

struct StablehloRngBitGeneratorOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloRngBitGeneratorOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloRngBitGeneratorOptionsTypeTable();
  }
  RngAlgorithm algorithm() const {
    return static_cast<RngAlgorithm>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  StablehloRngBitGeneratorOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloRngBitGeneratorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloRngBitGeneratorOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloRngBitGeneratorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloRngBitGeneratorOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_algorithm(RngAlgorithm algorithm) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(algorithm), 0);
  }
  explicit StablehloRngBitGeneratorOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloRngBitGeneratorOptionsBuilder &operator=(const StablehloRngBitGeneratorOptionsBuilder &);
  flatbuffers::Offset<StablehloRngBitGeneratorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloRngBitGeneratorOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloRngBitGeneratorOptions> CreateStablehloRngBitGeneratorOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    RngAlgorithm algorithm = RngAlgorithm_DEFAULT) {
  StablehloRngBitGeneratorOptionsBuilder builder_(_fbb);
  builder_.add_algorithm(algorithm);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloRngBitGeneratorOptions> CreateStablehloRngBitGeneratorOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloRngBitGeneratorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DOptionsT : public flatbuffers::NativeTable {
  typedef Conv2DOptions TableType;
  Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  ActivationFunctionType fused_activation_function;
  int32_t dilation_w_factor;
  int32_t dilation_h_factor;
  TensorType quantized_bias_type;
  Conv2DOptionsT()
      : padding(Padding_SAME),
        stride_w(0),
        stride_h(0),
        fused_activation_function(ActivationFunctionType_NONE),
        dilation_w_factor(1),
        dilation_h_factor(1),
        quantized_bias_type(TensorType_FLOAT32) {
  }
};

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DOptionsTypeTable();
  }
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(4, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(8, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(10, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(12, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(14, 1);
  }
  TensorType quantized_bias_type() const {
    return static_cast<TensorType>(GetField<int8_t>(16, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int8_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int8_t>(verifier, 16) &&
           verifier.EndTable();
  }
  Conv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(6, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(8, stride_h, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(10, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(12, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(14, dilation_h_factor, 1);
  }
  void add_quantized_bias_type(TensorType quantized_bias_type) {
    fbb_.AddElement<int8_t>(16, static_cast<int8_t>(quantized_bias_type), 0);
  }
  explicit Conv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DOptionsBuilder &operator=(const Conv2DOptionsBuilder &);
  flatbuffers::Offset<Conv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1,
    TensorType quantized_bias_type = TensorType_FLOAT32) {
  Conv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_quantized_bias_type(quantized_bias_type);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv3DOptionsT : public flatbuffers::NativeTable {
  typedef Conv3DOptions TableType;
  Padding padding;
  int32_t stride_d;
  int32_t stride_w;
  int32_t stride_h;
  ActivationFunctionType fused_activation_function;
  int32_t dilation_d_factor;
  int32_t dilation_w_factor;
  int32_t dilation_h_factor;
  Conv3DOptionsT()
      : padding(Padding_SAME),
        stride_d(0),
        stride_w(0),
        stride_h(0),
        fused_activation_function(ActivationFunctionType_NONE),
        dilation_d_factor(1),
        dilation_w_factor(1),
        dilation_h_factor(1) {
  }
};

struct Conv3DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv3DOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv3DOptionsTypeTable();
  }
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(4, 0));
  }
  int32_t stride_d() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t stride_w() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(10, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(12, 0));
  }
  int32_t dilation_d_factor() const {
    return GetField<int32_t>(14, 1);
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(16, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(18, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<int8_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           VerifyField<int32_t>(verifier, 18) &&
           verifier.EndTable();
  }
  Conv3DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv3DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv3DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv3DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(padding), 0);
  }
  void add_stride_d(int32_t stride_d) {
    fbb_.AddElement<int32_t>(6, stride_d, 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(8, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(10, stride_h, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(12, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_d_factor(int32_t dilation_d_factor) {
    fbb_.AddElement<int32_t>(14, dilation_d_factor, 1);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(16, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(18, dilation_h_factor, 1);
  }
  explicit Conv3DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv3DOptionsBuilder &operator=(const Conv3DOptionsBuilder &);
  flatbuffers::Offset<Conv3DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv3DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_d = 0,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    int32_t dilation_d_factor = 1,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  Conv3DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_dilation_d_factor(dilation_d_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_stride_d(stride_d);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool2DOptionsT : public flatbuffers::NativeTable {
  typedef Pool2DOptions TableType;
  Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  int32_t filter_width;
  int32_t filter_height;
  ActivationFunctionType fused_activation_function;
  Pool2DOptionsT()
      : padding(Padding_SAME),
        stride_w(0),
        stride_h(0),
        filter_width(0),
        filter_height(0),
        fused_activation_function(ActivationFunctionType_NONE) {
  }
};

struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pool2DOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pool2DOptionsTypeTable();
  }
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(4, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t filter_width() const {
    return GetField<int32_t>(10, 0);
  }
  int32_t filter_height() const {
    return GetField<int32_t>(12, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(14, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyField<int8_t>(verifier, 14) &&
           verifier.EndTable();
  }
  Pool2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(6, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(8, stride_h, 0);
  }
  void add_filter_width(int32_t filter_width) {
    fbb_.AddElement<int32_t>(10, filter_width, 0);
  }
  void add_filter_height(int32_t filter_height) {
    fbb_.AddElement<int32_t>(12, filter_height, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(14, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit Pool2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Pool2DOptionsBuilder &operator=(const Pool2DOptionsBuilder &);
  flatbuffers::Offset<Pool2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t filter_width = 0,
    int32_t filter_height = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  Pool2DOptionsBuilder builder_(_fbb);
  builder_.add_filter_height(filter_height);
  builder_.add_filter_width(filter_width);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthwiseConv2DOptionsT : public flatbuffers::NativeTable {
  typedef DepthwiseConv2DOptions TableType;
  Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  int32_t depth_multiplier;
  ActivationFunctionType fused_activation_function;
  int32_t dilation_w_factor;
  int32_t dilation_h_factor;
  DepthwiseConv2DOptionsT()
      : padding(Padding_SAME),
        stride_w(0),
        stride_h(0),
        depth_multiplier(0),
        fused_activation_function(ActivationFunctionType_NONE),
        dilation_w_factor(1),
        dilation_h_factor(1) {
  }
};

struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepthwiseConv2DOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DepthwiseConv2DOptionsTypeTable();
  }
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(4, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(10, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(12, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(14, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(16, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<int8_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           verifier.EndTable();
  }
  DepthwiseConv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthwiseConv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthwiseConv2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthwiseConv2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(6, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(8, stride_h, 0);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(10, depth_multiplier, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(12, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(14, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(16, dilation_h_factor, 1);
  }
  explicit DepthwiseConv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthwiseConv2DOptionsBuilder &operator=(const DepthwiseConv2DOptionsBuilder &);
  flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t depth_multiplier = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  DepthwiseConv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatEmbeddingsOptionsT : public flatbuffers::NativeTable {
  typedef ConcatEmbeddingsOptions TableType;
  int32_t num_channels;
  std::vector<int32_t> num_columns_per_channel;
  std::vector<int32_t> embedding_dim_per_channel;
  ConcatEmbeddingsOptionsT()
      : num_channels(0) {
  }
};

struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConcatEmbeddingsOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConcatEmbeddingsOptionsTypeTable();
  }
  int32_t num_channels() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<int32_t> *num_columns_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(num_columns_per_channel()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(embedding_dim_per_channel()) &&
           verifier.EndTable();
  }
  ConcatEmbeddingsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatEmbeddingsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConcatEmbeddingsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatEmbeddingsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_channels(int32_t num_channels) {
    fbb_.AddElement<int32_t>(4, num_channels, 0);
  }
  void add_num_columns_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel) {
    fbb_.AddOffset(6, num_columns_per_channel);
  }
  void add_embedding_dim_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel) {
    fbb_.AddOffset(8, embedding_dim_per_channel);
  }
  explicit ConcatEmbeddingsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatEmbeddingsOptionsBuilder &operator=(const ConcatEmbeddingsOptionsBuilder &);
  flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0) {
  ConcatEmbeddingsOptionsBuilder builder_(_fbb);
  builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
  builder_.add_num_columns_per_channel(num_columns_per_channel);
  builder_.add_num_channels(num_channels);
  return builder_.Finish();
}

flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSHProjectionOptionsT : public flatbuffers::NativeTable {
  typedef LSHProjectionOptions TableType;
  LSHProjectionType type;
  LSHProjectionOptionsT()
      : type(LSHProjectionType_UNKNOWN) {
  }
};

struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSHProjectionOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LSHProjectionOptionsTypeTable();
  }
  LSHProjectionType type() const {
    return static_cast<LSHProjectionType>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  LSHProjectionOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSHProjectionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSHProjectionOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSHProjectionOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(LSHProjectionType type) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(type), 0);
  }
  explicit LSHProjectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSHProjectionOptionsBuilder &operator=(const LSHProjectionOptionsBuilder &);
  flatbuffers::Offset<LSHProjectionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSHProjectionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    LSHProjectionType type = LSHProjectionType_UNKNOWN) {
  LSHProjectionOptionsBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SVDFOptionsT : public flatbuffers::NativeTable {
  typedef SVDFOptions TableType;
  int32_t rank;
  ActivationFunctionType fused_activation_function;
  bool asymmetric_quantize_inputs;
  SVDFOptionsT()
      : rank(0),
        fused_activation_function(ActivationFunctionType_NONE),
        asymmetric_quantize_inputs(false) {
  }
};

struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SVDFOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SVDFOptionsTypeTable();
  }
  int32_t rank() const {
    return GetField<int32_t>(4, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(6, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int8_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  SVDFOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SVDFOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SVDFOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(4, rank, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SVDFOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVDFOptionsBuilder &operator=(const SVDFOptionsBuilder &);
  flatbuffers::Offset<SVDFOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SVDFOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  SVDFOptionsBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RNNOptionsT : public flatbuffers::NativeTable {
  typedef RNNOptions TableType;
  ActivationFunctionType fused_activation_function;
  bool asymmetric_quantize_inputs;
  RNNOptionsT()
      : fused_activation_function(ActivationFunctionType_NONE),
        asymmetric_quantize_inputs(false) {
  }
};

struct RNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RNNOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RNNOptionsTypeTable();
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(4, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  RNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit RNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RNNOptionsBuilder &operator=(const RNNOptionsBuilder &);
  flatbuffers::Offset<RNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  RNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SequenceRNNOptionsT : public flatbuffers::NativeTable {
  typedef SequenceRNNOptions TableType;
  bool time_major;
  ActivationFunctionType fused_activation_function;
  bool asymmetric_quantize_inputs;
  SequenceRNNOptionsT()
      : time_major(false),
        fused_activation_function(ActivationFunctionType_NONE),
        asymmetric_quantize_inputs(false) {
  }
};

struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SequenceRNNOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SequenceRNNOptionsTypeTable();
  }
  bool time_major() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(6, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           VerifyField<int8_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  SequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SequenceRNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SequenceRNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceRNNOptionsBuilder &operator=(const SequenceRNNOptionsBuilder &);
  flatbuffers::Offset<SequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  SequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceRNNOptionsT : public flatbuffers::NativeTable {
  typedef BidirectionalSequenceRNNOptions TableType;
  bool time_major;
  ActivationFunctionType fused_activation_function;
  bool merge_outputs;
  bool asymmetric_quantize_inputs;
  BidirectionalSequenceRNNOptionsT()
      : time_major(false),
        fused_activation_function(ActivationFunctionType_NONE),
        merge_outputs(false),
        asymmetric_quantize_inputs(false) {
  }
};

struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BidirectionalSequenceRNNOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BidirectionalSequenceRNNOptionsTypeTable();
  }
  bool time_major() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(6, 0));
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(10, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           VerifyField<int8_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           VerifyField<uint8_t>(verifier, 10) &&
           verifier.EndTable();
  }
  BidirectionalSequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BidirectionalSequenceRNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceRNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceRNNOptionsBuilder &operator=(const BidirectionalSequenceRNNOptionsBuilder &);
  flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool merge_outputs = false,
    bool asymmetric_quantize_inputs = false) {
  BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FullyConnectedOptionsT : public flatbuffers::NativeTable {
  typedef FullyConnectedOptions TableType;
  ActivationFunctionType fused_activation_function;
  FullyConnectedOptionsWeightsFormat weights_format;
  bool keep_num_dims;
  bool asymmetric_quantize_inputs;
  TensorType quantized_bias_type;
  FullyConnectedOptionsT()
      : fused_activation_function(ActivationFunctionType_NONE),
        weights_format(FullyConnectedOptionsWeightsFormat_DEFAULT),
        keep_num_dims(false),
        asymmetric_quantize_inputs(false),
        quantized_bias_type(TensorType_FLOAT32) {
  }
};

struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FullyConnectedOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FullyConnectedOptionsTypeTable();
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(4, 0));
  }
  FullyConnectedOptionsWeightsFormat weights_format() const {
    return static_cast<FullyConnectedOptionsWeightsFormat>(GetField<int8_t>(6, 0));
  }
  bool keep_num_dims() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(10, 0) != 0;
  }
  TensorType quantized_bias_type() const {
    return static_cast<TensorType>(GetField<int8_t>(12, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<int8_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           VerifyField<uint8_t>(verifier, 10) &&
           VerifyField<int8_t>(verifier, 12) &&
           verifier.EndTable();
  }
  FullyConnectedOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FullyConnectedOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FullyConnectedOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FullyConnectedOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_weights_format(FullyConnectedOptionsWeightsFormat weights_format) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(weights_format), 0);
  }
  void add_keep_num_dims(bool keep_num_dims) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(keep_num_dims), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  void add_quantized_bias_type(TensorType quantized_bias_type) {
    fbb_.AddElement<int8_t>(12, static_cast<int8_t>(quantized_bias_type), 0);
  }
  explicit FullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FullyConnectedOptionsBuilder &operator=(const FullyConnectedOptionsBuilder &);
  flatbuffers::Offset<FullyConnectedOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullyConnectedOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    FullyConnectedOptionsWeightsFormat weights_format = FullyConnectedOptionsWeightsFormat_DEFAULT,
    bool keep_num_dims = false,
    bool asymmetric_quantize_inputs = false,
    TensorType quantized_bias_type = TensorType_FLOAT32) {
  FullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_quantized_bias_type(quantized_bias_type);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_keep_num_dims(keep_num_dims);
  builder_.add_weights_format(weights_format);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxOptionsT : public flatbuffers::NativeTable {
  typedef SoftmaxOptions TableType;
  float beta;
  SoftmaxOptionsT()
      : beta(0.0f) {
  }
};

struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftmaxOptionsTypeTable();
  }
  float beta() const {
    return GetField<float>(4, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           verifier.EndTable();
  }
  SoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(4, beta, 0.0f);
  }
  explicit SoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxOptionsBuilder &operator=(const SoftmaxOptionsBuilder &);
  flatbuffers::Offset<SoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SoftmaxOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatenationOptionsT : public flatbuffers::NativeTable {
  typedef ConcatenationOptions TableType;
  int32_t axis;
  ActivationFunctionType fused_activation_function;
  ConcatenationOptionsT()
      : axis(0),
        fused_activation_function(ActivationFunctionType_NONE) {
  }
};

struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConcatenationOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConcatenationOptionsTypeTable();
  }
  int32_t axis() const {
    return GetField<int32_t>(4, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(6, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  ConcatenationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatenationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConcatenationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatenationOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(4, axis, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit ConcatenationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatenationOptionsBuilder &operator=(const ConcatenationOptionsBuilder &);
  flatbuffers::Offset<ConcatenationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatenationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  ConcatenationOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddOptionsT : public flatbuffers::NativeTable {
  typedef AddOptions TableType;
  ActivationFunctionType fused_activation_function;
  bool pot_scale_int16;
  AddOptionsT()
      : fused_activation_function(ActivationFunctionType_NONE),
        pot_scale_int16(true) {
  }
};

struct AddOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddOptionsTypeTable();
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(4, 0));
  }
  bool pot_scale_int16() const {
    return GetField<uint8_t>(6, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  AddOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(pot_scale_int16), 1);
  }
  explicit AddOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddOptionsBuilder &operator=(const AddOptionsBuilder &);
  flatbuffers::Offset<AddOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddOptions> CreateAddOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool pot_scale_int16 = true) {
  AddOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulOptionsT : public flatbuffers::NativeTable {
  typedef MulOptions TableType;
  ActivationFunctionType fused_activation_function;
  MulOptionsT()
      : fused_activation_function(ActivationFunctionType_NONE) {
  }
};

struct MulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MulOptionsTypeTable();
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  MulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MulOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit MulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulOptionsBuilder &operator=(const MulOptionsBuilder &);
  flatbuffers::Offset<MulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulOptions> CreateMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  MulOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct L2NormOptionsT : public flatbuffers::NativeTable {
  typedef L2NormOptions TableType;
  ActivationFunctionType fused_activation_function;
  L2NormOptionsT()
      : fused_activation_function(ActivationFunctionType_NONE) {
  }
};

struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef L2NormOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return L2NormOptionsTypeTable();
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  L2NormOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<L2NormOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct L2NormOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit L2NormOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  L2NormOptionsBuilder &operator=(const L2NormOptionsBuilder &);
  flatbuffers::Offset<L2NormOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2NormOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  L2NormOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LocalResponseNormalizationOptionsT : public flatbuffers::NativeTable {
  typedef LocalResponseNormalizationOptions TableType;
  int32_t radius;
  float bias;
  float alpha;
  float beta;
  LocalResponseNormalizationOptionsT()
      : radius(0),
        bias(0.0f),
        alpha(0.0f),
        beta(0.0f) {
  }
};

struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LocalResponseNormalizationOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LocalResponseNormalizationOptionsTypeTable();
  }
  int32_t radius() const {
    return GetField<int32_t>(4, 0);
  }
  float bias() const {
    return GetField<float>(6, 0.0f);
  }
  float alpha() const {
    return GetField<float>(8, 0.0f);
  }
  float beta() const {
    return GetField<float>(10, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyField<float>(verifier, 10) &&
           verifier.EndTable();
  }
  LocalResponseNormalizationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LocalResponseNormalizationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LocalResponseNormalizationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LocalResponseNormalizationOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(4, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(6, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(8, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(10, beta, 0.0f);
  }
  explicit LocalResponseNormalizationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LocalResponseNormalizationOptionsBuilder &operator=(const LocalResponseNormalizationOptionsBuilder &);
  flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LocalResponseNormalizationOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  return builder_.Finish();
}

flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMOptionsT : public flatbuffers::NativeTable {
  typedef LSTMOptions TableType;
  ActivationFunctionType fused_activation_function;
  float cell_clip;
  float proj_clip;
  LSTMKernelType kernel_type;
  bool asymmetric_quantize_inputs;
  LSTMOptionsT()
      : fused_activation_function(ActivationFunctionType_NONE),
        cell_clip(0.0f),
        proj_clip(0.0f),
        kernel_type(LSTMKernelType_FULL),
        asymmetric_quantize_inputs(false) {
  }
};

struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LSTMOptionsTypeTable();
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(4, 0));
  }
  float cell_clip() const {
    return GetField<float>(6, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(8, 0.0f);
  }
  LSTMKernelType kernel_type() const {
    return static_cast<LSTMKernelType>(GetField<int8_t>(10, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(12, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyField<int8_t>(verifier, 10) &&
           VerifyField<uint8_t>(verifier, 12) &&
           verifier.EndTable();
  }
  LSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(6, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(8, proj_clip, 0.0f);
  }
  void add_kernel_type(LSTMKernelType kernel_type) {
    fbb_.AddElement<int8_t>(10, static_cast<int8_t>(kernel_type), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(12, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit LSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSTMOptionsBuilder &operator=(const LSTMOptionsBuilder &);
  flatbuffers::Offset<LSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    LSTMKernelType kernel_type = LSTMKernelType_FULL,
    bool asymmetric_quantize_inputs = false) {
  LSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_kernel_type(kernel_type);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {
  typedef UnidirectionalSequenceLSTMOptions TableType;
  ActivationFunctionType fused_activation_function;
  float cell_clip;
  float proj_clip;
  bool time_major;
  bool asymmetric_quantize_inputs;
  bool diagonal_recurrent_tensors;
  UnidirectionalSequenceLSTMOptionsT()
      : fused_activation_function(ActivationFunctionType_NONE),
        cell_clip(0.0f),
        proj_clip(0.0f),
        time_major(false),
        asymmetric_quantize_inputs(false),
        diagonal_recurrent_tensors(false) {
  }
};

struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnidirectionalSequenceLSTMOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnidirectionalSequenceLSTMOptionsTypeTable();
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(4, 0));
  }
  float cell_clip() const {
    return GetField<float>(6, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(8, 0.0f);
  }
  bool time_major() const {
    return GetField<uint8_t>(10, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(12, 0) != 0;
  }
  bool diagonal_recurrent_tensors() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyField<uint8_t>(verifier, 10) &&
           VerifyField<uint8_t>(verifier, 12) &&
           VerifyField<uint8_t>(verifier, 14) &&
           verifier.EndTable();
  }
  UnidirectionalSequenceLSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnidirectionalSequenceLSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(6, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(8, proj_clip, 0.0f);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(time_major), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(12, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  void add_diagonal_recurrent_tensors(bool diagonal_recurrent_tensors) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(diagonal_recurrent_tensors), 0);
  }
  explicit UnidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnidirectionalSequenceLSTMOptionsBuilder &operator=(const UnidirectionalSequenceLSTMOptionsBuilder &);
  flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool time_major = false,
    bool asymmetric_quantize_inputs = false,
    bool diagonal_recurrent_tensors = false) {
  UnidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_diagonal_recurrent_tensors(diagonal_recurrent_tensors);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {
  typedef BidirectionalSequenceLSTMOptions TableType;
  ActivationFunctionType fused_activation_function;
  float cell_clip;
  float proj_clip;
  bool merge_outputs;
  bool time_major;
  bool asymmetric_quantize_inputs;
  BidirectionalSequenceLSTMOptionsT()
      : fused_activation_function(ActivationFunctionType_NONE),
        cell_clip(0.0f),
        proj_clip(0.0f),
        merge_outputs(false),
        time_major(true),
        asymmetric_quantize_inputs(false) {
  }
};

struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BidirectionalSequenceLSTMOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BidirectionalSequenceLSTMOptionsTypeTable();
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(4, 0));
  }
  float cell_clip() const {
    return GetField<float>(6, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(8, 0.0f);
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(10, 0) != 0;
  }
  bool time_major() const {
    return GetField<uint8_t>(12, 1) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyField<uint8_t>(verifier, 10) &&
           VerifyField<uint8_t>(verifier, 12) &&
           VerifyField<uint8_t>(verifier, 14) &&
           verifier.EndTable();
  }
  BidirectionalSequenceLSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceLSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(6, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(8, proj_clip, 0.0f);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(12, static_cast<uint8_t>(time_major), 1);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceLSTMOptionsBuilder &operator=(const BidirectionalSequenceLSTMOptionsBuilder &);
  flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool merge_outputs = false,
    bool time_major = true,
    bool asymmetric_quantize_inputs = false) {
  BidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeBilinearOptionsT : public flatbuffers::NativeTable {
  typedef ResizeBilinearOptions TableType;
  bool align_corners;
  bool half_pixel_centers;
  ResizeBilinearOptionsT()
      : align_corners(false),
        half_pixel_centers(false) {
  }
};

struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeBilinearOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResizeBilinearOptionsTypeTable();
  }
  bool align_corners() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool half_pixel_centers() const {
    return GetField<uint8_t>(10, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 8) &&
           VerifyField<uint8_t>(verifier, 10) &&
           verifier.EndTable();
  }
  ResizeBilinearOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeBilinearOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeBilinearOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBilinearOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeBilinearOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeBilinearOptionsBuilder &operator=(const ResizeBilinearOptionsBuilder &);
  flatbuffers::Offset<ResizeBilinearOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeBilinearOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false,
    bool half_pixel_centers = false) {
  ResizeBilinearOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeNearestNeighborOptionsT : public flatbuffers::NativeTable {
  typedef ResizeNearestNeighborOptions TableType;
  bool align_corners;
  bool half_pixel_centers;
  ResizeNearestNeighborOptionsT()
      : align_corners(false),
        half_pixel_centers(false) {
  }
};

struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeNearestNeighborOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResizeNearestNeighborOptionsTypeTable();
  }
  bool align_corners() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  bool half_pixel_centers() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  ResizeNearestNeighborOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeNearestNeighborOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeNearestNeighborOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeNearestNeighborOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeNearestNeighborOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeNearestNeighborOptionsBuilder &operator=(const ResizeNearestNeighborOptionsBuilder &);
  flatbuffers::Offset<ResizeNearestNeighborOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeNearestNeighborOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false,
    bool half_pixel_centers = false) {
  ResizeNearestNeighborOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOptionsT : public flatbuffers::NativeTable {
  typedef CallOptions TableType;
  uint32_t subgraph;
  CallOptionsT()
      : subgraph(0) {
  }
};

struct CallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CallOptionsTypeTable();
  }
  uint32_t subgraph() const {
    return GetField<uint32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  CallOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CallOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subgraph(uint32_t subgraph) {
    fbb_.AddElement<uint32_t>(4, subgraph, 0);
  }
  explicit CallOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallOptionsBuilder &operator=(const CallOptionsBuilder &);
  flatbuffers::Offset<CallOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOptions> CreateCallOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t subgraph = 0) {
  CallOptionsBuilder builder_(_fbb);
  builder_.add_subgraph(subgraph);
  return builder_.Finish();
}

flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadOptionsT : public flatbuffers::NativeTable {
  typedef PadOptions TableType;
  PadOptionsT() {
  }
};

struct PadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PadOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PadOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadOptionsBuilder &operator=(const PadOptionsBuilder &);
  flatbuffers::Offset<PadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadOptions> CreatePadOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PadOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadV2OptionsT : public flatbuffers::NativeTable {
  typedef PadV2Options TableType;
  PadV2OptionsT() {
  }
};

struct PadV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PadV2OptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PadV2OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PadV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PadV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadV2OptionsBuilder &operator=(const PadV2OptionsBuilder &);
  flatbuffers::Offset<PadV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PadV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeOptionsT : public flatbuffers::NativeTable {
  typedef ReshapeOptions TableType;
  std::vector<int32_t> new_shape;
  ReshapeOptionsT() {
  }
};

struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReshapeOptionsTypeTable();
  }
  const flatbuffers::Vector<int32_t> *new_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(new_shape()) &&
           verifier.EndTable();
  }
  ReshapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReshapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape) {
    fbb_.AddOffset(4, new_shape);
  }
  explicit ReshapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeOptionsBuilder &operator=(const ReshapeOptionsBuilder &);
  flatbuffers::Offset<ReshapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape = 0) {
  ReshapeOptionsBuilder builder_(_fbb);
  builder_.add_new_shape(new_shape);
  return builder_.Finish();
}

flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchNDOptionsT : public flatbuffers::NativeTable {
  typedef SpaceToBatchNDOptions TableType;
  SpaceToBatchNDOptionsT() {
  }
};

struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToBatchNDOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpaceToBatchNDOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SpaceToBatchNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToBatchNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToBatchNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchNDOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SpaceToBatchNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchNDOptionsBuilder &operator=(const SpaceToBatchNDOptionsBuilder &);
  flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SpaceToBatchNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceNDOptionsT : public flatbuffers::NativeTable {
  typedef BatchToSpaceNDOptions TableType;
  BatchToSpaceNDOptionsT() {
  }
};

struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchToSpaceNDOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchToSpaceNDOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BatchToSpaceNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchToSpaceNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchToSpaceNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceNDOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchToSpaceNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchToSpaceNDOptionsBuilder &operator=(const BatchToSpaceNDOptionsBuilder &);
  flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BatchToSpaceNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkipGramOptionsT : public flatbuffers::NativeTable {
  typedef SkipGramOptions TableType;
  int32_t ngram_size;
  int32_t max_skip_size;
  bool include_all_ngrams;
  SkipGramOptionsT()
      : ngram_size(0),
        max_skip_size(0),
        include_all_ngrams(false) {
  }
};

struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkipGramOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SkipGramOptionsTypeTable();
  }
  int32_t ngram_size() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t max_skip_size() const {
    return GetField<int32_t>(6, 0);
  }
  bool include_all_ngrams() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  SkipGramOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SkipGramOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkipGramOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ngram_size(int32_t ngram_size) {
    fbb_.AddElement<int32_t>(4, ngram_size, 0);
  }
  void add_max_skip_size(int32_t max_skip_size) {
    fbb_.AddElement<int32_t>(6, max_skip_size, 0);
  }
  void add_include_all_ngrams(bool include_all_ngrams) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(include_all_ngrams), 0);
  }
  explicit SkipGramOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkipGramOptionsBuilder &operator=(const SkipGramOptionsBuilder &);
  flatbuffers::Offset<SkipGramOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGramOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ngram_size = 0,
    int32_t max_skip_size = 0,
    bool include_all_ngrams = false) {
  SkipGramOptionsBuilder builder_(_fbb);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_ngram_size(ngram_size);
  builder_.add_include_all_ngrams(include_all_ngrams);
  return builder_.Finish();
}

flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToDepthOptionsT : public flatbuffers::NativeTable {
  typedef SpaceToDepthOptions TableType;
  int32_t block_size;
  SpaceToDepthOptionsT()
      : block_size(0) {
  }
};

struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToDepthOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpaceToDepthOptionsTypeTable();
  }
  int32_t block_size() const {
    return GetField<int32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  SpaceToDepthOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToDepthOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToDepthOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToDepthOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(4, block_size, 0);
  }
  explicit SpaceToDepthOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToDepthOptionsBuilder &operator=(const SpaceToDepthOptionsBuilder &);
  flatbuffers::Offset<SpaceToDepthOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepthOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t block_size = 0) {
  SpaceToDepthOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthToSpaceOptionsT : public flatbuffers::NativeTable {
  typedef DepthToSpaceOptions TableType;
  int32_t block_size;
  DepthToSpaceOptionsT()
      : block_size(0) {
  }
};

struct DepthToSpaceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepthToSpaceOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DepthToSpaceOptionsTypeTable();
  }
  int32_t block_size() const {
    return GetField<int32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  DepthToSpaceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthToSpaceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthToSpaceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthToSpaceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(4, block_size, 0);
  }
  explicit DepthToSpaceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthToSpaceOptionsBuilder &operator=(const DepthToSpaceOptionsBuilder &);
  flatbuffers::Offset<DepthToSpaceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpaceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t block_size = 0) {
  DepthToSpaceOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubOptionsT : public flatbuffers::NativeTable {
  typedef SubOptions TableType;
  ActivationFunctionType fused_activation_function;
  bool pot_scale_int16;
  SubOptionsT()
      : fused_activation_function(ActivationFunctionType_NONE),
        pot_scale_int16(true) {
  }
};

struct SubOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubOptionsTypeTable();
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(4, 0));
  }
  bool pot_scale_int16() const {
    return GetField<uint8_t>(6, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  SubOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(pot_scale_int16), 1);
  }
  explicit SubOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubOptionsBuilder &operator=(const SubOptionsBuilder &);
  flatbuffers::Offset<SubOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubOptions> CreateSubOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool pot_scale_int16 = true) {
  SubOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivOptionsT : public flatbuffers::NativeTable {
  typedef DivOptions TableType;
  ActivationFunctionType fused_activation_function;
  DivOptionsT()
      : fused_activation_function(ActivationFunctionType_NONE) {
  }
};

struct DivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DivOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DivOptionsTypeTable();
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  DivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit DivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivOptionsBuilder &operator=(const DivOptionsBuilder &);
  flatbuffers::Offset<DivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivOptions> CreateDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  DivOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKV2OptionsT : public flatbuffers::NativeTable {
  typedef TopKV2Options TableType;
  TopKV2OptionsT() {
  }
};

struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopKV2OptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TopKV2OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TopKV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopKV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TopKV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKV2OptionsBuilder &operator=(const TopKV2OptionsBuilder &);
  flatbuffers::Offset<TopKV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TopKV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmbeddingLookupSparseOptionsT : public flatbuffers::NativeTable {
  typedef EmbeddingLookupSparseOptions TableType;
  CombinerType combiner;
  EmbeddingLookupSparseOptionsT()
      : combiner(CombinerType_SUM) {
  }
};

struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmbeddingLookupSparseOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EmbeddingLookupSparseOptionsTypeTable();
  }
  CombinerType combiner() const {
    return static_cast<CombinerType>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  EmbeddingLookupSparseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmbeddingLookupSparseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EmbeddingLookupSparseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingLookupSparseOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_combiner(CombinerType combiner) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(combiner), 0);
  }
  explicit EmbeddingLookupSparseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingLookupSparseOptionsBuilder &operator=(const EmbeddingLookupSparseOptionsBuilder &);
  flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    CombinerType combiner = CombinerType_SUM) {
  EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
  builder_.add_combiner(combiner);
  return builder_.Finish();
}

flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherOptionsT : public flatbuffers::NativeTable {
  typedef GatherOptions TableType;
  int32_t axis;
  int32_t batch_dims;
  GatherOptionsT()
      : axis(0),
        batch_dims(0) {
  }
};

struct GatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherOptionsTypeTable();
  }
  int32_t axis() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t batch_dims() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  GatherOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(4, axis, 0);
  }
  void add_batch_dims(int32_t batch_dims) {
    fbb_.AddElement<int32_t>(6, batch_dims, 0);
  }
  explicit GatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherOptionsBuilder &operator=(const GatherOptionsBuilder &);
  flatbuffers::Offset<GatherOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t batch_dims = 0) {
  GatherOptionsBuilder builder_(_fbb);
  builder_.add_batch_dims(batch_dims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeOptionsT : public flatbuffers::NativeTable {
  typedef TransposeOptions TableType;
  TransposeOptionsT() {
  }
};

struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransposeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransposeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TransposeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransposeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TransposeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeOptionsBuilder &operator=(const TransposeOptionsBuilder &);
  flatbuffers::Offset<TransposeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TransposeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpOptionsT : public flatbuffers::NativeTable {
  typedef ExpOptions TableType;
  ExpOptionsT() {
  }
};

struct ExpOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpOptionsBuilder &operator=(const ExpOptionsBuilder &);
  flatbuffers::Offset<ExpOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CosOptionsT : public flatbuffers::NativeTable {
  typedef CosOptions TableType;
  CosOptionsT() {
  }
};

struct CosOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CosOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CosOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CosOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CosOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CosOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CosOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CosOptionsBuilder &operator=(const CosOptionsBuilder &);
  flatbuffers::Offset<CosOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CosOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CosOptions> CreateCosOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CosOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<CosOptions> CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReducerOptionsT : public flatbuffers::NativeTable {
  typedef ReducerOptions TableType;
  bool keep_dims;
  ReducerOptionsT()
      : keep_dims(false) {
  }
};

struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReducerOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReducerOptionsTypeTable();
  }
  bool keep_dims() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  ReducerOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReducerOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReducerOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(keep_dims), 0);
  }
  explicit ReducerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReducerOptionsBuilder &operator=(const ReducerOptionsBuilder &);
  flatbuffers::Offset<ReducerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReducerOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keep_dims = false) {
  ReducerOptionsBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeOptionsT : public flatbuffers::NativeTable {
  typedef SqueezeOptions TableType;
  std::vector<int32_t> squeeze_dims;
  SqueezeOptionsT() {
  }
};

struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqueezeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqueezeOptionsTypeTable();
  }
  const flatbuffers::Vector<int32_t> *squeeze_dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(squeeze_dims()) &&
           verifier.EndTable();
  }
  SqueezeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SqueezeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_squeeze_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims) {
    fbb_.AddOffset(4, squeeze_dims);
  }
  explicit SqueezeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqueezeOptionsBuilder &operator=(const SqueezeOptionsBuilder &);
  flatbuffers::Offset<SqueezeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqueezeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims = 0) {
  SqueezeOptionsBuilder builder_(_fbb);
  builder_.add_squeeze_dims(squeeze_dims);
  return builder_.Finish();
}

flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitOptionsT : public flatbuffers::NativeTable {
  typedef SplitOptions TableType;
  int32_t num_splits;
  SplitOptionsT()
      : num_splits(0) {
  }
};

struct SplitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SplitOptionsTypeTable();
  }
  int32_t num_splits() const {
    return GetField<int32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  SplitOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SplitOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(4, num_splits, 0);
  }
  explicit SplitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitOptionsBuilder &operator=(const SplitOptionsBuilder &);
  flatbuffers::Offset<SplitOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitVOptionsT : public flatbuffers::NativeTable {
  typedef SplitVOptions TableType;
  int32_t num_splits;
  SplitVOptionsT()
      : num_splits(0) {
  }
};

struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitVOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SplitVOptionsTypeTable();
  }
  int32_t num_splits() const {
    return GetField<int32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  SplitVOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitVOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SplitVOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitVOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(4, num_splits, 0);
  }
  explicit SplitVOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitVOptionsBuilder &operator=(const SplitVOptionsBuilder &);
  flatbuffers::Offset<SplitVOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitVOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitVOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceOptionsT : public flatbuffers::NativeTable {
  typedef StridedSliceOptions TableType;
  int32_t begin_mask;
  int32_t end_mask;
  int32_t ellipsis_mask;
  int32_t new_axis_mask;
  int32_t shrink_axis_mask;
  bool offset;
  StridedSliceOptionsT()
      : begin_mask(0),
        end_mask(0),
        ellipsis_mask(0),
        new_axis_mask(0),
        shrink_axis_mask(0),
        offset(false) {
  }
};

struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StridedSliceOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StridedSliceOptionsTypeTable();
  }
  int32_t begin_mask() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t ellipsis_mask() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t new_axis_mask() const {
    return GetField<int32_t>(10, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(12, 0);
  }
  bool offset() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyField<uint8_t>(verifier, 14) &&
           verifier.EndTable();
  }
  StridedSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StridedSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StridedSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(4, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(6, end_mask, 0);
  }
  void add_ellipsis_mask(int32_t ellipsis_mask) {
    fbb_.AddElement<int32_t>(8, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int32_t new_axis_mask) {
    fbb_.AddElement<int32_t>(10, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(12, shrink_axis_mask, 0);
  }
  void add_offset(bool offset) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(offset), 0);
  }
  explicit StridedSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceOptionsBuilder &operator=(const StridedSliceOptionsBuilder &);
  flatbuffers::Offset<StridedSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t ellipsis_mask = 0,
    int32_t new_axis_mask = 0,
    int32_t shrink_axis_mask = 0,
    bool offset = false) {
  StridedSliceOptionsBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  builder_.add_offset(offset);
  return builder_.Finish();
}

flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogSoftmaxOptionsT : public flatbuffers::NativeTable {
  typedef LogSoftmaxOptions TableType;
  LogSoftmaxOptionsT() {
  }
};

struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogSoftmaxOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogSoftmaxOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogSoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogSoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogSoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogSoftmaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogSoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogSoftmaxOptionsBuilder &operator=(const LogSoftmaxOptionsBuilder &);
  flatbuffers::Offset<LogSoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogSoftmaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastOptionsT : public flatbuffers::NativeTable {
  typedef CastOptions TableType;
  TensorType in_data_type;
  TensorType out_data_type;
  CastOptionsT()
      : in_data_type(TensorType_FLOAT32),
        out_data_type(TensorType_FLOAT32) {
  }
};

struct CastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CastOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CastOptionsTypeTable();
  }
  TensorType in_data_type() const {
    return static_cast<TensorType>(GetField<int8_t>(4, 0));
  }
  TensorType out_data_type() const {
    return static_cast<TensorType>(GetField<int8_t>(6, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<int8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  CastOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CastOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_data_type(TensorType in_data_type) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(in_data_type), 0);
  }
  void add_out_data_type(TensorType out_data_type) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(out_data_type), 0);
  }
  explicit CastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastOptionsBuilder &operator=(const CastOptionsBuilder &);
  flatbuffers::Offset<CastOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CastOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CastOptions> CreateCastOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType in_data_type = TensorType_FLOAT32,
    TensorType out_data_type = TensorType_FLOAT32) {
  CastOptionsBuilder builder_(_fbb);
  builder_.add_out_data_type(out_data_type);
  builder_.add_in_data_type(in_data_type);
  return builder_.Finish();
}

flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DequantizeOptionsT : public flatbuffers::NativeTable {
  typedef DequantizeOptions TableType;
  DequantizeOptionsT() {
  }
};

struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DequantizeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DequantizeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DequantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DequantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DequantizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DequantizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DequantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DequantizeOptionsBuilder &operator=(const DequantizeOptionsBuilder &);
  flatbuffers::Offset<DequantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DequantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DequantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumMinimumOptionsT : public flatbuffers::NativeTable {
  typedef MaximumMinimumOptions TableType;
  MaximumMinimumOptionsT() {
  }
};

struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaximumMinimumOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaximumMinimumOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MaximumMinimumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaximumMinimumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaximumMinimumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumMinimumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumMinimumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaximumMinimumOptionsBuilder &operator=(const MaximumMinimumOptionsBuilder &);
  flatbuffers::Offset<MaximumMinimumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumMinimumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumMinimumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileOptionsT : public flatbuffers::NativeTable {
  typedef TileOptions TableType;
  TileOptionsT() {
  }
};

struct TileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TileOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TileOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileOptionsBuilder &operator=(const TileOptionsBuilder &);
  flatbuffers::Offset<TileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileOptions> CreateTileOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TileOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxOptionsT : public flatbuffers::NativeTable {
  typedef ArgMaxOptions TableType;
  TensorType output_type;
  ArgMaxOptionsT()
      : output_type(TensorType_FLOAT32) {
  }
};

struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMaxOptionsTypeTable();
  }
  TensorType output_type() const {
    return static_cast<TensorType>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  ArgMaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(TensorType output_type) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxOptionsBuilder &operator=(const ArgMaxOptionsBuilder &);
  flatbuffers::Offset<ArgMaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType output_type = TensorType_FLOAT32) {
  ArgMaxOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMinOptionsT : public flatbuffers::NativeTable {
  typedef ArgMinOptions TableType;
  TensorType output_type;
  ArgMinOptionsT()
      : output_type(TensorType_FLOAT32) {
  }
};

struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMinOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMinOptionsTypeTable();
  }
  TensorType output_type() const {
    return static_cast<TensorType>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  ArgMinOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMinOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMinOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(TensorType output_type) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMinOptionsBuilder &operator=(const ArgMinOptionsBuilder &);
  flatbuffers::Offset<ArgMinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMinOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType output_type = TensorType_FLOAT32) {
  ArgMinOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterOptionsT : public flatbuffers::NativeTable {
  typedef GreaterOptions TableType;
  GreaterOptionsT() {
  }
};

struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GreaterOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterOptionsBuilder &operator=(const GreaterOptionsBuilder &);
  flatbuffers::Offset<GreaterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualOptionsT : public flatbuffers::NativeTable {
  typedef GreaterEqualOptions TableType;
  GreaterEqualOptionsT() {
  }
};

struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterEqualOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GreaterEqualOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterEqualOptionsBuilder &operator=(const GreaterEqualOptionsBuilder &);
  flatbuffers::Offset<GreaterEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessOptionsT : public flatbuffers::NativeTable {
  typedef LessOptions TableType;
  LessOptionsT() {
  }
};

struct LessOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LessOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessOptionsBuilder &operator=(const LessOptionsBuilder &);
  flatbuffers::Offset<LessOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessOptions> CreateLessOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualOptionsT : public flatbuffers::NativeTable {
  typedef LessEqualOptions TableType;
  LessEqualOptionsT() {
  }
};

struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessEqualOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LessEqualOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessEqualOptionsBuilder &operator=(const LessEqualOptionsBuilder &);
  flatbuffers::Offset<LessEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegOptionsT : public flatbuffers::NativeTable {
  typedef NegOptions TableType;
  NegOptionsT() {
  }
};

struct NegOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NegOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NegOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NegOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NegOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NegOptionsBuilder &operator=(const NegOptionsBuilder &);
  flatbuffers::Offset<NegOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegOptions> CreateNegOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectOptionsT : public flatbuffers::NativeTable {
  typedef SelectOptions TableType;
  SelectOptionsT() {
  }
};

struct SelectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SelectOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelectOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectOptionsBuilder &operator=(const SelectOptionsBuilder &);
  flatbuffers::Offset<SelectOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceOptionsT : public flatbuffers::NativeTable {
  typedef SliceOptions TableType;
  SliceOptionsT() {
  }
};

struct SliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SliceOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceOptionsBuilder &operator=(const SliceOptionsBuilder &);
  flatbuffers::Offset<SliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeConvOptionsT : public flatbuffers::NativeTable {
  typedef TransposeConvOptions TableType;
  Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  ActivationFunctionType fused_activation_function;
  TensorType quantized_bias_type;
  TransposeConvOptionsT()
      : padding(Padding_SAME),
        stride_w(0),
        stride_h(0),
        fused_activation_function(ActivationFunctionType_NONE),
        quantized_bias_type(TensorType_FLOAT32) {
  }
};

struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransposeConvOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransposeConvOptionsTypeTable();
  }
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(4, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(8, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(10, 0));
  }
  TensorType quantized_bias_type() const {
    return static_cast<TensorType>(GetField<int8_t>(12, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int8_t>(verifier, 10) &&
           VerifyField<int8_t>(verifier, 12) &&
           verifier.EndTable();
  }
  TransposeConvOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeConvOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransposeConvOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeConvOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(6, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(8, stride_h, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(10, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_quantized_bias_type(TensorType quantized_bias_type) {
    fbb_.AddElement<int8_t>(12, static_cast<int8_t>(quantized_bias_type), 0);
  }
  explicit TransposeConvOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeConvOptionsBuilder &operator=(const TransposeConvOptionsBuilder &);
  flatbuffers::Offset<TransposeConvOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeConvOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    TensorType quantized_bias_type = TensorType_FLOAT32) {
  TransposeConvOptionsBuilder builder_(_fbb);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_quantized_bias_type(quantized_bias_type);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsOptionsT : public flatbuffers::NativeTable {
  typedef ExpandDimsOptions TableType;
  ExpandDimsOptionsT() {
  }
};

struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpandDimsOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpandDimsOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpandDimsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpandDimsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpandDimsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpandDimsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpandDimsOptionsBuilder &operator=(const ExpandDimsOptionsBuilder &);
  flatbuffers::Offset<ExpandDimsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDimsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpandDimsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseToDenseOptionsT : public flatbuffers::NativeTable {
  typedef SparseToDenseOptions TableType;
  bool validate_indices;
  SparseToDenseOptionsT()
      : validate_indices(false) {
  }
};

struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseToDenseOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseToDenseOptionsTypeTable();
  }
  bool validate_indices() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  SparseToDenseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseToDenseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparseToDenseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseToDenseOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_validate_indices(bool validate_indices) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(validate_indices), 0);
  }
  explicit SparseToDenseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseToDenseOptionsBuilder &operator=(const SparseToDenseOptionsBuilder &);
  flatbuffers::Offset<SparseToDenseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDenseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool validate_indices = false) {
  SparseToDenseOptionsBuilder builder_(_fbb);
  builder_.add_validate_indices(validate_indices);
  return builder_.Finish();
}

flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualOptionsT : public flatbuffers::NativeTable {
  typedef EqualOptions TableType;
  EqualOptionsT() {
  }
};

struct EqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EqualOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EqualOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EqualOptionsBuilder &operator=(const EqualOptionsBuilder &);
  flatbuffers::Offset<EqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualOptionsT : public flatbuffers::NativeTable {
  typedef NotEqualOptions TableType;
  NotEqualOptionsT() {
  }
};

struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NotEqualOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NotEqualOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NotEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NotEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotEqualOptionsBuilder &operator=(const NotEqualOptionsBuilder &);
  flatbuffers::Offset<NotEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShapeOptionsT : public flatbuffers::NativeTable {
  typedef ShapeOptions TableType;
  TensorType out_type;
  ShapeOptionsT()
      : out_type(TensorType_FLOAT32) {
  }
};

struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShapeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShapeOptionsTypeTable();
  }
  TensorType out_type() const {
    return static_cast<TensorType>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  ShapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ShapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_out_type(TensorType out_type) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(out_type), 0);
  }
  explicit ShapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeOptionsBuilder &operator=(const ShapeOptionsBuilder &);
  flatbuffers::Offset<ShapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType out_type = TensorType_FLOAT32) {
  ShapeOptionsBuilder builder_(_fbb);
  builder_.add_out_type(out_type);
  return builder_.Finish();
}

flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RankOptionsT : public flatbuffers::NativeTable {
  typedef RankOptions TableType;
  RankOptionsT() {
  }
};

struct RankOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RankOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RankOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RankOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RankOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RankOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RankOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankOptionsBuilder &operator=(const RankOptionsBuilder &);
  flatbuffers::Offset<RankOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RankOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RankOptions> CreateRankOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RankOptions> CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowOptionsT : public flatbuffers::NativeTable {
  typedef PowOptions TableType;
  PowOptionsT() {
  }
};

struct PowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PowOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PowOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PowOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PowOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowOptionsBuilder &operator=(const PowOptionsBuilder &);
  flatbuffers::Offset<PowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowOptions> CreatePowOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PowOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantOptionsT : public flatbuffers::NativeTable {
  typedef FakeQuantOptions TableType;
  float min;
  float max;
  int32_t num_bits;
  bool narrow_range;
  FakeQuantOptionsT()
      : min(0.0f),
        max(0.0f),
        num_bits(0),
        narrow_range(false) {
  }
};

struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FakeQuantOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FakeQuantOptionsTypeTable();
  }
  float min() const {
    return GetField<float>(4, 0.0f);
  }
  float max() const {
    return GetField<float>(6, 0.0f);
  }
  int32_t num_bits() const {
    return GetField<int32_t>(8, 0);
  }
  bool narrow_range() const {
    return GetField<uint8_t>(10, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<uint8_t>(verifier, 10) &&
           verifier.EndTable();
  }
  FakeQuantOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FakeQuantOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(float min) {
    fbb_.AddElement<float>(4, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(6, max, 0.0f);
  }
  void add_num_bits(int32_t num_bits) {
    fbb_.AddElement<int32_t>(8, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantOptionsBuilder &operator=(const FakeQuantOptionsBuilder &);
  flatbuffers::Offset<FakeQuantOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min = 0.0f,
    float max = 0.0f,
    int32_t num_bits = 0,
    bool narrow_range = false) {
  FakeQuantOptionsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackOptionsT : public flatbuffers::NativeTable {
  typedef PackOptions TableType;
  int32_t values_count;
  int32_t axis;
  PackOptionsT()
      : values_count(0),
        axis(0) {
  }
};

struct PackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PackOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PackOptionsTypeTable();
  }
  int32_t values_count() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  PackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values_count(int32_t values_count) {
    fbb_.AddElement<int32_t>(4, values_count, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(6, axis, 0);
  }
  explicit PackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PackOptionsBuilder &operator=(const PackOptionsBuilder &);
  flatbuffers::Offset<PackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PackOptions> CreatePackOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t values_count = 0,
    int32_t axis = 0) {
  PackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_values_count(values_count);
  return builder_.Finish();
}

flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalOrOptionsT : public flatbuffers::NativeTable {
  typedef LogicalOrOptions TableType;
  LogicalOrOptionsT() {
  }
};

struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalOrOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogicalOrOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalOrOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalOrOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalOrOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalOrOptionsBuilder &operator=(const LogicalOrOptionsBuilder &);
  flatbuffers::Offset<LogicalOrOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOrOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotOptionsT : public flatbuffers::NativeTable {
  typedef OneHotOptions TableType;
  int32_t axis;
  OneHotOptionsT()
      : axis(0) {
  }
};

struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OneHotOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OneHotOptionsTypeTable();
  }
  int32_t axis() const {
    return GetField<int32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  OneHotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OneHotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(4, axis, 0);
  }
  explicit OneHotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneHotOptionsBuilder &operator=(const OneHotOptionsBuilder &);
  flatbuffers::Offset<OneHotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  OneHotOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AbsOptionsT : public flatbuffers::NativeTable {
  typedef AbsOptions TableType;
  AbsOptionsT() {
  }
};

struct AbsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AbsOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AbsOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AbsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AbsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AbsOptionsBuilder &operator=(const AbsOptionsBuilder &);
  flatbuffers::Offset<AbsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HardSwishOptionsT : public flatbuffers::NativeTable {
  typedef HardSwishOptions TableType;
  HardSwishOptionsT() {
  }
};

struct HardSwishOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardSwishOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HardSwishOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HardSwishOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HardSwishOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HardSwishOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HardSwishOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HardSwishOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HardSwishOptionsBuilder &operator=(const HardSwishOptionsBuilder &);
  flatbuffers::Offset<HardSwishOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardSwishOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HardSwishOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalAndOptionsT : public flatbuffers::NativeTable {
  typedef LogicalAndOptions TableType;
  LogicalAndOptionsT() {
  }
};

struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalAndOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogicalAndOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalAndOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalAndOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalAndOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalAndOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalAndOptionsBuilder &operator=(const LogicalAndOptionsBuilder &);
  flatbuffers::Offset<LogicalAndOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAndOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalNotOptionsT : public flatbuffers::NativeTable {
  typedef LogicalNotOptions TableType;
  LogicalNotOptionsT() {
  }
};

struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalNotOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogicalNotOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalNotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalNotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalNotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalNotOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalNotOptionsBuilder &operator=(const LogicalNotOptionsBuilder &);
  flatbuffers::Offset<LogicalNotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnpackOptionsT : public flatbuffers::NativeTable {
  typedef UnpackOptions TableType;
  int32_t num;
  int32_t axis;
  UnpackOptionsT()
      : num(0),
        axis(0) {
  }
};

struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnpackOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnpackOptionsTypeTable();
  }
  int32_t num() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  UnpackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnpackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnpackOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(4, num, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(6, axis, 0);
  }
  explicit UnpackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnpackOptionsBuilder &operator=(const UnpackOptionsBuilder &);
  flatbuffers::Offset<UnpackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnpackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num = 0,
    int32_t axis = 0) {
  UnpackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorDivOptionsT : public flatbuffers::NativeTable {
  typedef FloorDivOptions TableType;
  FloorDivOptionsT() {
  }
};

struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorDivOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FloorDivOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorDivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorDivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorDivOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorDivOptionsBuilder &operator=(const FloorDivOptionsBuilder &);
  flatbuffers::Offset<FloorDivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquareOptionsT : public flatbuffers::NativeTable {
  typedef SquareOptions TableType;
  SquareOptionsT() {
  }
};

struct SquareOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquareOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SquareOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquareOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SquareOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquareOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquareOptionsBuilder &operator=(const SquareOptionsBuilder &);
  flatbuffers::Offset<SquareOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquareOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquareOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZerosLikeOptionsT : public flatbuffers::NativeTable {
  typedef ZerosLikeOptions TableType;
  ZerosLikeOptionsT() {
  }
};

struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ZerosLikeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ZerosLikeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ZerosLikeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ZerosLikeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZerosLikeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ZerosLikeOptionsBuilder &operator=(const ZerosLikeOptionsBuilder &);
  flatbuffers::Offset<ZerosLikeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLikeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillOptionsT : public flatbuffers::NativeTable {
  typedef FillOptions TableType;
  FillOptionsT() {
  }
};

struct FillOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FillOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FillOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FillOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FillOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillOptionsBuilder &operator=(const FillOptionsBuilder &);
  flatbuffers::Offset<FillOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FillOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FillOptions> CreateFillOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FillOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorModOptionsT : public flatbuffers::NativeTable {
  typedef FloorModOptions TableType;
  FloorModOptionsT() {
  }
};

struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorModOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FloorModOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorModOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorModOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorModOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorModOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorModOptionsBuilder &operator=(const FloorModOptionsBuilder &);
  flatbuffers::Offset<FloorModOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorModOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeOptionsT : public flatbuffers::NativeTable {
  typedef RangeOptions TableType;
  RangeOptionsT() {
  }
};

struct RangeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RangeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RangeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RangeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RangeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RangeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeOptionsBuilder &operator=(const RangeOptionsBuilder &);
  flatbuffers::Offset<RangeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RangeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RangeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReluOptionsT : public flatbuffers::NativeTable {
  typedef LeakyReluOptions TableType;
  float alpha;
  LeakyReluOptionsT()
      : alpha(0.0f) {
  }
};

struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeakyReluOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LeakyReluOptionsTypeTable();
  }
  float alpha() const {
    return GetField<float>(4, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           verifier.EndTable();
  }
  LeakyReluOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeakyReluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeakyReluOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReluOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(4, alpha, 0.0f);
  }
  explicit LeakyReluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeakyReluOptionsBuilder &operator=(const LeakyReluOptionsBuilder &);
  flatbuffers::Offset<LeakyReluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  LeakyReluOptionsBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquaredDifferenceOptionsT : public flatbuffers::NativeTable {
  typedef SquaredDifferenceOptions TableType;
  SquaredDifferenceOptionsT() {
  }
};

struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquaredDifferenceOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SquaredDifferenceOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquaredDifferenceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquaredDifferenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SquaredDifferenceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquaredDifferenceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquaredDifferenceOptionsBuilder &operator=(const SquaredDifferenceOptionsBuilder &);
  flatbuffers::Offset<SquaredDifferenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifferenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MirrorPadOptionsT : public flatbuffers::NativeTable {
  typedef MirrorPadOptions TableType;
  MirrorPadMode mode;
  MirrorPadOptionsT()
      : mode(MirrorPadMode_REFLECT) {
  }
};

struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MirrorPadOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MirrorPadOptionsTypeTable();
  }
  MirrorPadMode mode() const {
    return static_cast<MirrorPadMode>(GetField<int8_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  MirrorPadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MirrorPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MirrorPadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MirrorPadOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(MirrorPadMode mode) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(mode), 0);
  }
  explicit MirrorPadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MirrorPadOptionsBuilder &operator=(const MirrorPadOptionsBuilder &);
  flatbuffers::Offset<MirrorPadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MirrorPadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    MirrorPadMode mode = MirrorPadMode_REFLECT) {
  MirrorPadOptionsBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueOptionsT : public flatbuffers::NativeTable {
  typedef UniqueOptions TableType;
  TensorType idx_out_type;
  UniqueOptionsT()
      : idx_out_type(TensorType_INT32) {
  }
};

struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UniqueOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UniqueOptionsTypeTable();
  }
  TensorType idx_out_type() const {
    return static_cast<TensorType>(GetField<int8_t>(4, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  UniqueOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UniqueOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx_out_type(TensorType idx_out_type) {
    fbb_.AddElement<int8_t>(4, static_cast<int8_t>(idx_out_type), 2);
  }
  explicit UniqueOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniqueOptionsBuilder &operator=(const UniqueOptionsBuilder &);
  flatbuffers::Offset<UniqueOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniqueOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType idx_out_type = TensorType_INT32) {
  UniqueOptionsBuilder builder_(_fbb);
  builder_.add_idx_out_type(idx_out_type);
  return builder_.Finish();
}

flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseV2OptionsT : public flatbuffers::NativeTable {
  typedef ReverseV2Options TableType;
  ReverseV2OptionsT() {
  }
};

struct ReverseV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReverseV2OptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReverseV2OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReverseV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReverseV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReverseV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseV2OptionsBuilder &operator=(const ReverseV2OptionsBuilder &);
  flatbuffers::Offset<ReverseV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReverseV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddNOptionsT : public flatbuffers::NativeTable {
  typedef AddNOptions TableType;
  AddNOptionsT() {
  }
};

struct AddNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddNOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddNOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AddNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNOptionsBuilder &operator=(const AddNOptionsBuilder &);
  flatbuffers::Offset<AddNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddNOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AddNOptions> CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherNdOptionsT : public flatbuffers::NativeTable {
  typedef GatherNdOptions TableType;
  GatherNdOptionsT() {
  }
};

struct GatherNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherNdOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherNdOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GatherNdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherNdOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherNdOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GatherNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherNdOptionsBuilder &operator=(const GatherNdOptionsBuilder &);
  flatbuffers::Offset<GatherNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GatherNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhereOptionsT : public flatbuffers::NativeTable {
  typedef WhereOptions TableType;
  WhereOptionsT() {
  }
};

struct WhereOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WhereOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WhereOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  WhereOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhereOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WhereOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhereOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WhereOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhereOptionsBuilder &operator=(const WhereOptionsBuilder &);
  flatbuffers::Offset<WhereOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhereOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WhereOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<WhereOptions> CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseSequenceOptionsT : public flatbuffers::NativeTable {
  typedef ReverseSequenceOptions TableType;
  int32_t seq_dim;
  int32_t batch_dim;
  ReverseSequenceOptionsT()
      : seq_dim(0),
        batch_dim(0) {
  }
};

struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReverseSequenceOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReverseSequenceOptionsTypeTable();
  }
  int32_t seq_dim() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t batch_dim() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  ReverseSequenceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseSequenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReverseSequenceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseSequenceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_dim(int32_t seq_dim) {
    fbb_.AddElement<int32_t>(4, seq_dim, 0);
  }
  void add_batch_dim(int32_t batch_dim) {
    fbb_.AddElement<int32_t>(6, batch_dim, 0);
  }
  explicit ReverseSequenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseSequenceOptionsBuilder &operator=(const ReverseSequenceOptionsBuilder &);
  flatbuffers::Offset<ReverseSequenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seq_dim = 0,
    int32_t batch_dim = 0) {
  ReverseSequenceOptionsBuilder builder_(_fbb);
  builder_.add_batch_dim(batch_dim);
  builder_.add_seq_dim(seq_dim);
  return builder_.Finish();
}

flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixDiagOptionsT : public flatbuffers::NativeTable {
  typedef MatrixDiagOptions TableType;
  MatrixDiagOptionsT() {
  }
};

struct MatrixDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatrixDiagOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MatrixDiagOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MatrixDiagOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatrixDiagOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixDiagOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MatrixDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixDiagOptionsBuilder &operator=(const MatrixDiagOptionsBuilder &);
  flatbuffers::Offset<MatrixDiagOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixDiagOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MatrixDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizeOptionsT : public flatbuffers::NativeTable {
  typedef QuantizeOptions TableType;
  QuantizeOptionsT() {
  }
};

struct QuantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantizeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  QuantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit QuantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizeOptionsBuilder &operator=(const QuantizeOptionsBuilder &);
  flatbuffers::Offset<QuantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  QuantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixSetDiagOptionsT : public flatbuffers::NativeTable {
  typedef MatrixSetDiagOptions TableType;
  MatrixSetDiagOptionsT() {
  }
};

struct MatrixSetDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatrixSetDiagOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MatrixSetDiagOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MatrixSetDiagOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixSetDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatrixSetDiagOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixSetDiagOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MatrixSetDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixSetDiagOptionsBuilder &operator=(const MatrixSetDiagOptionsBuilder &);
  flatbuffers::Offset<MatrixSetDiagOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixSetDiagOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MatrixSetDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IfOptionsT : public flatbuffers::NativeTable {
  typedef IfOptions TableType;
  int32_t then_subgraph_index;
  int32_t else_subgraph_index;
  IfOptionsT()
      : then_subgraph_index(0),
        else_subgraph_index(0) {
  }
};

struct IfOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IfOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IfOptionsTypeTable();
  }
  int32_t then_subgraph_index() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t else_subgraph_index() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  IfOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IfOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IfOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IfOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_then_subgraph_index(int32_t then_subgraph_index) {
    fbb_.AddElement<int32_t>(4, then_subgraph_index, 0);
  }
  void add_else_subgraph_index(int32_t else_subgraph_index) {
    fbb_.AddElement<int32_t>(6, else_subgraph_index, 0);
  }
  explicit IfOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IfOptionsBuilder &operator=(const IfOptionsBuilder &);
  flatbuffers::Offset<IfOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IfOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<IfOptions> CreateIfOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t then_subgraph_index = 0,
    int32_t else_subgraph_index = 0) {
  IfOptionsBuilder builder_(_fbb);
  builder_.add_else_subgraph_index(else_subgraph_index);
  builder_.add_then_subgraph_index(then_subgraph_index);
  return builder_.Finish();
}

flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOnceOptionsT : public flatbuffers::NativeTable {
  typedef CallOnceOptions TableType;
  int32_t init_subgraph_index;
  CallOnceOptionsT()
      : init_subgraph_index(0) {
  }
};

struct CallOnceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallOnceOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CallOnceOptionsTypeTable();
  }
  int32_t init_subgraph_index() const {
    return GetField<int32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  CallOnceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallOnceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CallOnceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOnceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_init_subgraph_index(int32_t init_subgraph_index) {
    fbb_.AddElement<int32_t>(4, init_subgraph_index, 0);
  }
  explicit CallOnceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallOnceOptionsBuilder &operator=(const CallOnceOptionsBuilder &);
  flatbuffers::Offset<CallOnceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOnceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t init_subgraph_index = 0) {
  CallOnceOptionsBuilder builder_(_fbb);
  builder_.add_init_subgraph_index(init_subgraph_index);
  return builder_.Finish();
}

flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhileOptionsT : public flatbuffers::NativeTable {
  typedef WhileOptions TableType;
  int32_t cond_subgraph_index;
  int32_t body_subgraph_index;
  WhileOptionsT()
      : cond_subgraph_index(0),
        body_subgraph_index(0) {
  }
};

struct WhileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WhileOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WhileOptionsTypeTable();
  }
  int32_t cond_subgraph_index() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  WhileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WhileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhileOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cond_subgraph_index(int32_t cond_subgraph_index) {
    fbb_.AddElement<int32_t>(4, cond_subgraph_index, 0);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(6, body_subgraph_index, 0);
  }
  explicit WhileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhileOptionsBuilder &operator=(const WhileOptionsBuilder &);
  flatbuffers::Offset<WhileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cond_subgraph_index = 0,
    int32_t body_subgraph_index = 0) {
  WhileOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_cond_subgraph_index(cond_subgraph_index);
  return builder_.Finish();
}

flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV4OptionsT : public flatbuffers::NativeTable {
  typedef NonMaxSuppressionV4Options TableType;
  NonMaxSuppressionV4OptionsT() {
  }
};

struct NonMaxSuppressionV4Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonMaxSuppressionV4OptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NonMaxSuppressionV4OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NonMaxSuppressionV4OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionV4OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonMaxSuppressionV4Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV4OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV4OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionV4OptionsBuilder &operator=(const NonMaxSuppressionV4OptionsBuilder &);
  flatbuffers::Offset<NonMaxSuppressionV4Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV4Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV4OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV5OptionsT : public flatbuffers::NativeTable {
  typedef NonMaxSuppressionV5Options TableType;
  NonMaxSuppressionV5OptionsT() {
  }
};

struct NonMaxSuppressionV5Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonMaxSuppressionV5OptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NonMaxSuppressionV5OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NonMaxSuppressionV5OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionV5OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonMaxSuppressionV5Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV5OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV5OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionV5OptionsBuilder &operator=(const NonMaxSuppressionV5OptionsBuilder &);
  flatbuffers::Offset<NonMaxSuppressionV5Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV5Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV5OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScatterNdOptionsT : public flatbuffers::NativeTable {
  typedef ScatterNdOptions TableType;
  ScatterNdOptionsT() {
  }
};

struct ScatterNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScatterNdOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScatterNdOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ScatterNdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScatterNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScatterNdOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScatterNdOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScatterNdOptionsBuilder &operator=(const ScatterNdOptionsBuilder &);
  flatbuffers::Offset<ScatterNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectV2OptionsT : public flatbuffers::NativeTable {
  typedef SelectV2Options TableType;
  SelectV2OptionsT() {
  }
};

struct SelectV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectV2OptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SelectV2OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelectV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectV2OptionsBuilder &operator=(const SelectV2OptionsBuilder &);
  flatbuffers::Offset<SelectV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DensifyOptionsT : public flatbuffers::NativeTable {
  typedef DensifyOptions TableType;
  DensifyOptionsT() {
  }
};

struct DensifyOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DensifyOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DensifyOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DensifyOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DensifyOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DensifyOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DensifyOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DensifyOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DensifyOptionsBuilder &operator=(const DensifyOptionsBuilder &);
  flatbuffers::Offset<DensifyOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DensifyOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DensifyOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SegmentSumOptionsT : public flatbuffers::NativeTable {
  typedef SegmentSumOptions TableType;
  SegmentSumOptionsT() {
  }
};

struct SegmentSumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SegmentSumOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SegmentSumOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SegmentSumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SegmentSumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SegmentSumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SegmentSumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SegmentSumOptionsBuilder &operator=(const SegmentSumOptionsBuilder &);
  flatbuffers::Offset<SegmentSumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SegmentSumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SegmentSumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchMatMulOptionsT : public flatbuffers::NativeTable {
  typedef BatchMatMulOptions TableType;
  bool adj_x;
  bool adj_y;
  bool asymmetric_quantize_inputs;
  BatchMatMulOptionsT()
      : adj_x(false),
        adj_y(false),
        asymmetric_quantize_inputs(false) {
  }
};

struct BatchMatMulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchMatMulOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchMatMulOptionsTypeTable();
  }
  bool adj_x() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  bool adj_y() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(8, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           VerifyField<uint8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  BatchMatMulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchMatMulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchMatMulOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchMatMulOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_adj_x(bool adj_x) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(adj_x), 0);
  }
  void add_adj_y(bool adj_y) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(adj_y), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(8, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BatchMatMulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchMatMulOptionsBuilder &operator=(const BatchMatMulOptionsBuilder &);
  flatbuffers::Offset<BatchMatMulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchMatMulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool adj_x = false,
    bool adj_y = false,
    bool asymmetric_quantize_inputs = false) {
  BatchMatMulOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_adj_y(adj_y);
  builder_.add_adj_x(adj_x);
  return builder_.Finish();
}

flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CumsumOptionsT : public flatbuffers::NativeTable {
  typedef CumsumOptions TableType;
  bool exclusive;
  bool reverse;
  CumsumOptionsT()
      : exclusive(false),
        reverse(false) {
  }
};

struct CumsumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CumsumOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CumsumOptionsTypeTable();
  }
  bool exclusive() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  bool reverse() const {
    return GetField<uint8_t>(6, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           VerifyField<uint8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  CumsumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CumsumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CumsumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CumsumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse) {
    fbb_.AddElement<uint8_t>(6, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumsumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CumsumOptionsBuilder &operator=(const CumsumOptionsBuilder &);
  flatbuffers::Offset<CumsumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CumsumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool exclusive = false,
    bool reverse = false) {
  CumsumOptionsBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastToOptionsT : public flatbuffers::NativeTable {
  typedef BroadcastToOptions TableType;
  BroadcastToOptionsT() {
  }
};

struct BroadcastToOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BroadcastToOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BroadcastToOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BroadcastToOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastToOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BroadcastToOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastToOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BroadcastToOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BroadcastToOptionsBuilder &operator=(const BroadcastToOptionsBuilder &);
  flatbuffers::Offset<BroadcastToOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastToOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BroadcastToOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Rfft2dOptionsT : public flatbuffers::NativeTable {
  typedef Rfft2dOptions TableType;
  Rfft2dOptionsT() {
  }
};

struct Rfft2dOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Rfft2dOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Rfft2dOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Rfft2dOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Rfft2dOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rfft2dOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Rfft2dOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Rfft2dOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Rfft2dOptionsBuilder &operator=(const Rfft2dOptionsBuilder &);
  flatbuffers::Offset<Rfft2dOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rfft2dOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Rfft2dOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableOptionsT : public flatbuffers::NativeTable {
  typedef HashtableOptions TableType;
  int32_t table_id;
  TensorType key_dtype;
  TensorType value_dtype;
  HashtableOptionsT()
      : table_id(0),
        key_dtype(TensorType_FLOAT32),
        value_dtype(TensorType_FLOAT32) {
  }
};

struct HashtableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HashtableOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HashtableOptionsTypeTable();
  }
  int32_t table_id() const {
    return GetField<int32_t>(4, 0);
  }
  TensorType key_dtype() const {
    return static_cast<TensorType>(GetField<int8_t>(6, 0));
  }
  TensorType value_dtype() const {
    return static_cast<TensorType>(GetField<int8_t>(8, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int8_t>(verifier, 6) &&
           VerifyField<int8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  HashtableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_table_id(int32_t table_id) {
    fbb_.AddElement<int32_t>(4, table_id, 0);
  }
  void add_key_dtype(TensorType key_dtype) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(key_dtype), 0);
  }
  void add_value_dtype(TensorType value_dtype) {
    fbb_.AddElement<int8_t>(8, static_cast<int8_t>(value_dtype), 0);
  }
  explicit HashtableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableOptionsBuilder &operator=(const HashtableOptionsBuilder &);
  flatbuffers::Offset<HashtableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t table_id = 0,
    TensorType key_dtype = TensorType_FLOAT32,
    TensorType value_dtype = TensorType_FLOAT32) {
  HashtableOptionsBuilder builder_(_fbb);
  builder_.add_table_id(table_id);
  builder_.add_value_dtype(value_dtype);
  builder_.add_key_dtype(key_dtype);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableFindOptionsT : public flatbuffers::NativeTable {
  typedef HashtableFindOptions TableType;
  HashtableFindOptionsT() {
  }
};

struct HashtableFindOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HashtableFindOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HashtableFindOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableFindOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableFindOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableFindOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableFindOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableFindOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableFindOptionsBuilder &operator=(const HashtableFindOptionsBuilder &);
  flatbuffers::Offset<HashtableFindOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableFindOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableFindOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableImportOptionsT : public flatbuffers::NativeTable {
  typedef HashtableImportOptions TableType;
  HashtableImportOptionsT() {
  }
};

struct HashtableImportOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HashtableImportOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HashtableImportOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableImportOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableImportOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableImportOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableImportOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableImportOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableImportOptionsBuilder &operator=(const HashtableImportOptionsBuilder &);
  flatbuffers::Offset<HashtableImportOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableImportOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableImportOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableSizeOptionsT : public flatbuffers::NativeTable {
  typedef HashtableSizeOptions TableType;
  HashtableSizeOptionsT() {
  }
};

struct HashtableSizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HashtableSizeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HashtableSizeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableSizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableSizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableSizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableSizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableSizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableSizeOptionsBuilder &operator=(const HashtableSizeOptionsBuilder &);
  flatbuffers::Offset<HashtableSizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableSizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableSizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VarHandleOptionsT : public flatbuffers::NativeTable {
  typedef VarHandleOptions TableType;
  std::string container;
  std::string shared_name;
  VarHandleOptionsT() {
  }
};

struct VarHandleOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VarHandleOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VarHandleOptionsTypeTable();
  }
  const flatbuffers::String *container() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::String *shared_name() const {
    return GetPointer<const flatbuffers::String *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(container()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyString(shared_name()) &&
           verifier.EndTable();
  }
  VarHandleOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VarHandleOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VarHandleOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VarHandleOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_container(flatbuffers::Offset<flatbuffers::String> container) {
    fbb_.AddOffset(4, container);
  }
  void add_shared_name(flatbuffers::Offset<flatbuffers::String> shared_name) {
    fbb_.AddOffset(6, shared_name);
  }
  explicit VarHandleOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarHandleOptionsBuilder &operator=(const VarHandleOptionsBuilder &);
  flatbuffers::Offset<VarHandleOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarHandleOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> container = 0,
    flatbuffers::Offset<flatbuffers::String> shared_name = 0) {
  VarHandleOptionsBuilder builder_(_fbb);
  builder_.add_shared_name(shared_name);
  builder_.add_container(container);
  return builder_.Finish();
}

flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadVariableOptionsT : public flatbuffers::NativeTable {
  typedef ReadVariableOptions TableType;
  ReadVariableOptionsT() {
  }
};

struct ReadVariableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReadVariableOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReadVariableOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReadVariableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReadVariableOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadVariableOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReadVariableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadVariableOptionsBuilder &operator=(const ReadVariableOptionsBuilder &);
  flatbuffers::Offset<ReadVariableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadVariableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReadVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssignVariableOptionsT : public flatbuffers::NativeTable {
  typedef AssignVariableOptions TableType;
  AssignVariableOptionsT() {
  }
};

struct AssignVariableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignVariableOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssignVariableOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AssignVariableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssignVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AssignVariableOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssignVariableOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignVariableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignVariableOptionsBuilder &operator=(const AssignVariableOptionsBuilder &);
  flatbuffers::Offset<AssignVariableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignVariableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AssignVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomOptionsT : public flatbuffers::NativeTable {
  typedef RandomOptions TableType;
  int64_t seed;
  int64_t seed2;
  RandomOptionsT()
      : seed(0),
        seed2(0) {
  }
};

struct RandomOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RandomOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RandomOptionsTypeTable();
  }
  int64_t seed() const {
    return GetField<int64_t>(4, 0);
  }
  int64_t seed2() const {
    return GetField<int64_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4) &&
           VerifyField<int64_t>(verifier, 6) &&
           verifier.EndTable();
  }
  RandomOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RandomOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(int64_t seed) {
    fbb_.AddElement<int64_t>(4, seed, 0);
  }
  void add_seed2(int64_t seed2) {
    fbb_.AddElement<int64_t>(6, seed2, 0);
  }
  explicit RandomOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RandomOptionsBuilder &operator=(const RandomOptionsBuilder &);
  flatbuffers::Offset<RandomOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RandomOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RandomOptions> CreateRandomOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seed = 0,
    int64_t seed2 = 0) {
  RandomOptionsBuilder builder_(_fbb);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

flatbuffers::Offset<RandomOptions> CreateRandomOptions(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BucketizeOptionsT : public flatbuffers::NativeTable {
  typedef BucketizeOptions TableType;
  std::vector<float> boundaries;
  BucketizeOptionsT() {
  }
};

struct BucketizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BucketizeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BucketizeOptionsTypeTable();
  }
  const flatbuffers::Vector<float> *boundaries() const {
    return GetPointer<const flatbuffers::Vector<float> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(boundaries()) &&
           verifier.EndTable();
  }
  BucketizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BucketizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BucketizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BucketizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boundaries(flatbuffers::Offset<flatbuffers::Vector<float>> boundaries) {
    fbb_.AddOffset(4, boundaries);
  }
  explicit BucketizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BucketizeOptionsBuilder &operator=(const BucketizeOptionsBuilder &);
  flatbuffers::Offset<BucketizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BucketizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> boundaries = 0) {
  BucketizeOptionsBuilder builder_(_fbb);
  builder_.add_boundaries(boundaries);
  return builder_.Finish();
}

flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeluOptionsT : public flatbuffers::NativeTable {
  typedef GeluOptions TableType;
  bool approximate;
  GeluOptionsT()
      : approximate(false) {
  }
};

struct GeluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeluOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeluOptionsTypeTable();
  }
  bool approximate() const {
    return GetField<uint8_t>(4, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4) &&
           verifier.EndTable();
  }
  GeluOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeluOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeluOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_approximate(bool approximate) {
    fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(approximate), 0);
  }
  explicit GeluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeluOptionsBuilder &operator=(const GeluOptionsBuilder &);
  flatbuffers::Offset<GeluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeluOptions> CreateGeluOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool approximate = false) {
  GeluOptionsBuilder builder_(_fbb);
  builder_.add_approximate(approximate);
  return builder_.Finish();
}

flatbuffers::Offset<GeluOptions> CreateGeluOptions(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DynamicUpdateSliceOptionsT : public flatbuffers::NativeTable {
  typedef DynamicUpdateSliceOptions TableType;
  DynamicUpdateSliceOptionsT() {
  }
};

struct DynamicUpdateSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DynamicUpdateSliceOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DynamicUpdateSliceOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DynamicUpdateSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DynamicUpdateSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DynamicUpdateSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DynamicUpdateSliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DynamicUpdateSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DynamicUpdateSliceOptionsBuilder &operator=(const DynamicUpdateSliceOptionsBuilder &);
  flatbuffers::Offset<DynamicUpdateSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DynamicUpdateSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DynamicUpdateSliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsortedSegmentProdOptionsT : public flatbuffers::NativeTable {
  typedef UnsortedSegmentProdOptions TableType;
  UnsortedSegmentProdOptionsT() {
  }
};

struct UnsortedSegmentProdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsortedSegmentProdOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnsortedSegmentProdOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UnsortedSegmentProdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsortedSegmentProdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnsortedSegmentProdOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsortedSegmentProdOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentProdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnsortedSegmentProdOptionsBuilder &operator=(const UnsortedSegmentProdOptionsBuilder &);
  flatbuffers::Offset<UnsortedSegmentProdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsortedSegmentProdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnsortedSegmentProdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsortedSegmentMaxOptionsT : public flatbuffers::NativeTable {
  typedef UnsortedSegmentMaxOptions TableType;
  UnsortedSegmentMaxOptionsT() {
  }
};

struct UnsortedSegmentMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsortedSegmentMaxOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnsortedSegmentMaxOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UnsortedSegmentMaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsortedSegmentMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnsortedSegmentMaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsortedSegmentMaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnsortedSegmentMaxOptionsBuilder &operator=(const UnsortedSegmentMaxOptionsBuilder &);
  flatbuffers::Offset<UnsortedSegmentMaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsortedSegmentMaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnsortedSegmentMaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsortedSegmentSumOptionsT : public flatbuffers::NativeTable {
  typedef UnsortedSegmentSumOptions TableType;
  UnsortedSegmentSumOptionsT() {
  }
};

struct UnsortedSegmentSumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsortedSegmentSumOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnsortedSegmentSumOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UnsortedSegmentSumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsortedSegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnsortedSegmentSumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsortedSegmentSumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentSumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnsortedSegmentSumOptionsBuilder &operator=(const UnsortedSegmentSumOptionsBuilder &);
  flatbuffers::Offset<UnsortedSegmentSumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsortedSegmentSumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnsortedSegmentSumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ATan2OptionsT : public flatbuffers::NativeTable {
  typedef ATan2Options TableType;
  ATan2OptionsT() {
  }
};

struct ATan2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ATan2OptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ATan2OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ATan2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ATan2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ATan2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ATan2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ATan2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ATan2OptionsBuilder &operator=(const ATan2OptionsBuilder &);
  flatbuffers::Offset<ATan2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ATan2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<ATan2Options> CreateATan2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ATan2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ATan2Options> CreateATan2Options(flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsortedSegmentMinOptionsT : public flatbuffers::NativeTable {
  typedef UnsortedSegmentMinOptions TableType;
  UnsortedSegmentMinOptionsT() {
  }
};

struct UnsortedSegmentMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsortedSegmentMinOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnsortedSegmentMinOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UnsortedSegmentMinOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsortedSegmentMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnsortedSegmentMinOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsortedSegmentMinOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnsortedSegmentMinOptionsBuilder &operator=(const UnsortedSegmentMinOptionsBuilder &);
  flatbuffers::Offset<UnsortedSegmentMinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsortedSegmentMinOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnsortedSegmentMinOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignOptionsT : public flatbuffers::NativeTable {
  typedef SignOptions TableType;
  SignOptionsT() {
  }
};

struct SignOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SignOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SignOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SignOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignOptionsBuilder &operator=(const SignOptionsBuilder &);
  flatbuffers::Offset<SignOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignOptions> CreateSignOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SignOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SignOptions> CreateSignOptions(flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BitcastOptionsT : public flatbuffers::NativeTable {
  typedef BitcastOptions TableType;
  BitcastOptionsT() {
  }
};

struct BitcastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BitcastOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BitcastOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BitcastOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BitcastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BitcastOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BitcastOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BitcastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BitcastOptionsBuilder &operator=(const BitcastOptionsBuilder &);
  flatbuffers::Offset<BitcastOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BitcastOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BitcastOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BitwiseXorOptionsT : public flatbuffers::NativeTable {
  typedef BitwiseXorOptions TableType;
  BitwiseXorOptionsT() {
  }
};

struct BitwiseXorOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BitwiseXorOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BitwiseXorOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BitwiseXorOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BitwiseXorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BitwiseXorOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BitwiseXorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BitwiseXorOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BitwiseXorOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BitwiseXorOptionsBuilder &operator=(const BitwiseXorOptionsBuilder &);
  flatbuffers::Offset<BitwiseXorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BitwiseXorOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BitwiseXorOptions> CreateBitwiseXorOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BitwiseXorOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BitwiseXorOptions> CreateBitwiseXorOptions(flatbuffers::FlatBufferBuilder &_fbb, const BitwiseXorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RightShiftOptionsT : public flatbuffers::NativeTable {
  typedef RightShiftOptions TableType;
  RightShiftOptionsT() {
  }
};

struct RightShiftOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RightShiftOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RightShiftOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RightShiftOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RightShiftOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RightShiftOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RightShiftOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RightShiftOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RightShiftOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RightShiftOptionsBuilder &operator=(const RightShiftOptionsBuilder &);
  flatbuffers::Offset<RightShiftOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RightShiftOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RightShiftOptions> CreateRightShiftOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RightShiftOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RightShiftOptions> CreateRightShiftOptions(flatbuffers::FlatBufferBuilder &_fbb, const RightShiftOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DilateOptionsT : public flatbuffers::NativeTable {
  typedef DilateOptions TableType;
  DilateOptionsT() {
  }
};

struct DilateOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DilateOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DilateOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DilateOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DilateOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DilateOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DilateOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DilateOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DilateOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DilateOptionsBuilder &operator=(const DilateOptionsBuilder &);
  flatbuffers::Offset<DilateOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DilateOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DilateOptions> CreateDilateOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DilateOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DilateOptions> CreateDilateOptions(flatbuffers::FlatBufferBuilder &_fbb, const DilateOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceWindowOptionsT : public flatbuffers::NativeTable {
  typedef ReduceWindowOptions TableType;
  ReduceWindowFunction reduce_function;
  ReduceWindowOptionsT()
      : reduce_function(ReduceWindowFunction_UNSUPPORTED) {
  }
};

struct ReduceWindowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceWindowOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceWindowOptionsTypeTable();
  }
  ReduceWindowFunction reduce_function() const {
    return static_cast<ReduceWindowFunction>(GetField<int32_t>(4, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  ReduceWindowOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceWindowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceWindowOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceWindowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceWindowOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reduce_function(ReduceWindowFunction reduce_function) {
    fbb_.AddElement<int32_t>(4, static_cast<int32_t>(reduce_function), 0);
  }
  explicit ReduceWindowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReduceWindowOptionsBuilder &operator=(const ReduceWindowOptionsBuilder &);
  flatbuffers::Offset<ReduceWindowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceWindowOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceWindowOptions> CreateReduceWindowOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ReduceWindowFunction reduce_function = ReduceWindowFunction_UNSUPPORTED) {
  ReduceWindowOptionsBuilder builder_(_fbb);
  builder_.add_reduce_function(reduce_function);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceWindowOptions> CreateReduceWindowOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReduceWindowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorCodeT : public flatbuffers::NativeTable {
  typedef OperatorCode TableType;
  int8_t deprecated_builtin_code;
  std::string custom_code;
  int32_t version;
  BuiltinOperator builtin_code;
  OperatorCodeT()
      : deprecated_builtin_code(0),
        version(1),
        builtin_code(BuiltinOperator_ADD) {
  }
};

struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorCodeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OperatorCodeTypeTable();
  }
  int8_t deprecated_builtin_code() const {
    return GetField<int8_t>(4, 0);
  }
  const flatbuffers::String *custom_code() const {
    return GetPointer<const flatbuffers::String *>(6);
  }
  int32_t version() const {
    return GetField<int32_t>(8, 1);
  }
  BuiltinOperator builtin_code() const {
    return static_cast<BuiltinOperator>(GetField<int32_t>(10, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyString(custom_code()) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           verifier.EndTable();
  }
  OperatorCodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OperatorCode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorCodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deprecated_builtin_code(int8_t deprecated_builtin_code) {
    fbb_.AddElement<int8_t>(4, deprecated_builtin_code, 0);
  }
  void add_custom_code(flatbuffers::Offset<flatbuffers::String> custom_code) {
    fbb_.AddOffset(6, custom_code);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(8, version, 1);
  }
  void add_builtin_code(BuiltinOperator builtin_code) {
    fbb_.AddElement<int32_t>(10, static_cast<int32_t>(builtin_code), 0);
  }
  explicit OperatorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorCodeBuilder &operator=(const OperatorCodeBuilder &);
  flatbuffers::Offset<OperatorCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t deprecated_builtin_code = 0,
    flatbuffers::Offset<flatbuffers::String> custom_code = 0,
    int32_t version = 1,
    BuiltinOperator builtin_code = BuiltinOperator_ADD) {
  OperatorCodeBuilder builder_(_fbb);
  builder_.add_builtin_code(builtin_code);
  builder_.add_version(version);
  builder_.add_custom_code(custom_code);
  builder_.add_deprecated_builtin_code(deprecated_builtin_code);
  return builder_.Finish();
}

flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StableHLOCompositeOptionsT : public flatbuffers::NativeTable {
  typedef StableHLOCompositeOptions TableType;
  std::string name;
  int32_t decomposition_subgraph_index;
  std::vector<uint8_t> composite_attributes;
  CustomOptionsFormat composite_attributes_format;
  int32_t version;
  StableHLOCompositeOptionsT()
      : decomposition_subgraph_index(0),
        composite_attributes_format(CustomOptionsFormat_FLEXBUFFERS),
        version(0) {
  }
};

struct StableHLOCompositeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StableHLOCompositeOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StableHLOCompositeOptionsTypeTable();
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  int32_t decomposition_subgraph_index() const {
    return GetField<int32_t>(6, 0);
  }
  const flatbuffers::Vector<uint8_t> *composite_attributes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(8);
  }
  CustomOptionsFormat composite_attributes_format() const {
    return static_cast<CustomOptionsFormat>(GetField<int8_t>(10, 0));
  }
  int32_t version() const {
    return GetField<int32_t>(12, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(composite_attributes()) &&
           VerifyField<int8_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           verifier.EndTable();
  }
  StableHLOCompositeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StableHLOCompositeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StableHLOCompositeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StableHLOCompositeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StableHLOCompositeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(4, name);
  }
  void add_decomposition_subgraph_index(int32_t decomposition_subgraph_index) {
    fbb_.AddElement<int32_t>(6, decomposition_subgraph_index, 0);
  }
  void add_composite_attributes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> composite_attributes) {
    fbb_.AddOffset(8, composite_attributes);
  }
  void add_composite_attributes_format(CustomOptionsFormat composite_attributes_format) {
    fbb_.AddElement<int8_t>(10, static_cast<int8_t>(composite_attributes_format), 0);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(12, version, 0);
  }
  explicit StableHLOCompositeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StableHLOCompositeOptionsBuilder &operator=(const StableHLOCompositeOptionsBuilder &);
  flatbuffers::Offset<StableHLOCompositeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StableHLOCompositeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StableHLOCompositeOptions> CreateStableHLOCompositeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t decomposition_subgraph_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> composite_attributes = 0,
    CustomOptionsFormat composite_attributes_format = CustomOptionsFormat_FLEXBUFFERS,
    int32_t version = 0) {
  StableHLOCompositeOptionsBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_composite_attributes(composite_attributes);
  builder_.add_decomposition_subgraph_index(decomposition_subgraph_index);
  builder_.add_name(name);
  builder_.add_composite_attributes_format(composite_attributes_format);
  return builder_.Finish();
}

flatbuffers::Offset<StableHLOCompositeOptions> CreateStableHLOCompositeOptions(flatbuffers::FlatBufferBuilder &_fbb, const StableHLOCompositeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloShiftLeftOptionsT : public flatbuffers::NativeTable {
  typedef StablehloShiftLeftOptions TableType;
  StablehloShiftLeftOptionsT() {
  }
};

struct StablehloShiftLeftOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StablehloShiftLeftOptionsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StablehloShiftLeftOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  StablehloShiftLeftOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloShiftLeftOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StablehloShiftLeftOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloShiftLeftOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloShiftLeftOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StablehloShiftLeftOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StablehloShiftLeftOptionsBuilder &operator=(const StablehloShiftLeftOptionsBuilder &);
  flatbuffers::Offset<StablehloShiftLeftOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StablehloShiftLeftOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StablehloShiftLeftOptions> CreateStablehloShiftLeftOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StablehloShiftLeftOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<StablehloShiftLeftOptions> CreateStablehloShiftLeftOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloShiftLeftOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorT : public flatbuffers::NativeTable {
  typedef Operator TableType;
  uint32_t opcode_index;
  std::vector<int32_t> inputs;
  std::vector<int32_t> outputs;
  BuiltinOptionsUnion builtin_options;
  std::vector<uint8_t> custom_options;
  CustomOptionsFormat custom_options_format;
  std::vector<bool> mutating_variable_inputs;
  std::vector<int32_t> intermediates;
  uint64_t large_custom_options_offset;
  uint64_t large_custom_options_size;
  BuiltinOptions2Union builtin_options_2;
  int32_t debug_metadata_index;
  OperatorT()
      : opcode_index(0),
        custom_options_format(CustomOptionsFormat_FLEXBUFFERS),
        large_custom_options_offset(0),
        large_custom_options_size(0),
        debug_metadata_index(-1) {
  }
};

struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OperatorTypeTable();
  }
  uint32_t opcode_index() const {
    return GetField<uint32_t>(4, 0);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  BuiltinOptions builtin_options_type() const {
    return static_cast<BuiltinOptions>(GetField<uint8_t>(10, 0));
  }
  const void *builtin_options() const {
    return GetPointer<const void *>(12);
  }
  template<typename T> const T *builtin_options_as() const;
  const Conv2DOptions *builtin_options_as_Conv2DOptions() const {
    return builtin_options_type() == BuiltinOptions_Conv2DOptions ? static_cast<const Conv2DOptions *>(builtin_options()) : nullptr;
  }
  const DepthwiseConv2DOptions *builtin_options_as_DepthwiseConv2DOptions() const {
    return builtin_options_type() == BuiltinOptions_DepthwiseConv2DOptions ? static_cast<const DepthwiseConv2DOptions *>(builtin_options()) : nullptr;
  }
  const ConcatEmbeddingsOptions *builtin_options_as_ConcatEmbeddingsOptions() const {
    return builtin_options_type() == BuiltinOptions_ConcatEmbeddingsOptions ? static_cast<const ConcatEmbeddingsOptions *>(builtin_options()) : nullptr;
  }
  const LSHProjectionOptions *builtin_options_as_LSHProjectionOptions() const {
    return builtin_options_type() == BuiltinOptions_LSHProjectionOptions ? static_cast<const LSHProjectionOptions *>(builtin_options()) : nullptr;
  }
  const Pool2DOptions *builtin_options_as_Pool2DOptions() const {
    return builtin_options_type() == BuiltinOptions_Pool2DOptions ? static_cast<const Pool2DOptions *>(builtin_options()) : nullptr;
  }
  const SVDFOptions *builtin_options_as_SVDFOptions() const {
    return builtin_options_type() == BuiltinOptions_SVDFOptions ? static_cast<const SVDFOptions *>(builtin_options()) : nullptr;
  }
  const RNNOptions *builtin_options_as_RNNOptions() const {
    return builtin_options_type() == BuiltinOptions_RNNOptions ? static_cast<const RNNOptions *>(builtin_options()) : nullptr;
  }
  const FullyConnectedOptions *builtin_options_as_FullyConnectedOptions() const {
    return builtin_options_type() == BuiltinOptions_FullyConnectedOptions ? static_cast<const FullyConnectedOptions *>(builtin_options()) : nullptr;
  }
  const SoftmaxOptions *builtin_options_as_SoftmaxOptions() const {
    return builtin_options_type() == BuiltinOptions_SoftmaxOptions ? static_cast<const SoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const ConcatenationOptions *builtin_options_as_ConcatenationOptions() const {
    return builtin_options_type() == BuiltinOptions_ConcatenationOptions ? static_cast<const ConcatenationOptions *>(builtin_options()) : nullptr;
  }
  const AddOptions *builtin_options_as_AddOptions() const {
    return builtin_options_type() == BuiltinOptions_AddOptions ? static_cast<const AddOptions *>(builtin_options()) : nullptr;
  }
  const L2NormOptions *builtin_options_as_L2NormOptions() const {
    return builtin_options_type() == BuiltinOptions_L2NormOptions ? static_cast<const L2NormOptions *>(builtin_options()) : nullptr;
  }
  const LocalResponseNormalizationOptions *builtin_options_as_LocalResponseNormalizationOptions() const {
    return builtin_options_type() == BuiltinOptions_LocalResponseNormalizationOptions ? static_cast<const LocalResponseNormalizationOptions *>(builtin_options()) : nullptr;
  }
  const LSTMOptions *builtin_options_as_LSTMOptions() const {
    return builtin_options_type() == BuiltinOptions_LSTMOptions ? static_cast<const LSTMOptions *>(builtin_options()) : nullptr;
  }
  const ResizeBilinearOptions *builtin_options_as_ResizeBilinearOptions() const {
    return builtin_options_type() == BuiltinOptions_ResizeBilinearOptions ? static_cast<const ResizeBilinearOptions *>(builtin_options()) : nullptr;
  }
  const CallOptions *builtin_options_as_CallOptions() const {
    return builtin_options_type() == BuiltinOptions_CallOptions ? static_cast<const CallOptions *>(builtin_options()) : nullptr;
  }
  const ReshapeOptions *builtin_options_as_ReshapeOptions() const {
    return builtin_options_type() == BuiltinOptions_ReshapeOptions ? static_cast<const ReshapeOptions *>(builtin_options()) : nullptr;
  }
  const SkipGramOptions *builtin_options_as_SkipGramOptions() const {
    return builtin_options_type() == BuiltinOptions_SkipGramOptions ? static_cast<const SkipGramOptions *>(builtin_options()) : nullptr;
  }
  const SpaceToDepthOptions *builtin_options_as_SpaceToDepthOptions() const {
    return builtin_options_type() == BuiltinOptions_SpaceToDepthOptions ? static_cast<const SpaceToDepthOptions *>(builtin_options()) : nullptr;
  }
  const EmbeddingLookupSparseOptions *builtin_options_as_EmbeddingLookupSparseOptions() const {
    return builtin_options_type() == BuiltinOptions_EmbeddingLookupSparseOptions ? static_cast<const EmbeddingLookupSparseOptions *>(builtin_options()) : nullptr;
  }
  const MulOptions *builtin_options_as_MulOptions() const {
    return builtin_options_type() == BuiltinOptions_MulOptions ? static_cast<const MulOptions *>(builtin_options()) : nullptr;
  }
  const PadOptions *builtin_options_as_PadOptions() const {
    return builtin_options_type() == BuiltinOptions_PadOptions ? static_cast<const PadOptions *>(builtin_options()) : nullptr;
  }
  const GatherOptions *builtin_options_as_GatherOptions() const {
    return builtin_options_type() == BuiltinOptions_GatherOptions ? static_cast<const GatherOptions *>(builtin_options()) : nullptr;
  }
  const BatchToSpaceNDOptions *builtin_options_as_BatchToSpaceNDOptions() const {
    return builtin_options_type() == BuiltinOptions_BatchToSpaceNDOptions ? static_cast<const BatchToSpaceNDOptions *>(builtin_options()) : nullptr;
  }
  const SpaceToBatchNDOptions *builtin_options_as_SpaceToBatchNDOptions() const {
    return builtin_options_type() == BuiltinOptions_SpaceToBatchNDOptions ? static_cast<const SpaceToBatchNDOptions *>(builtin_options()) : nullptr;
  }
  const TransposeOptions *builtin_options_as_TransposeOptions() const {
    return builtin_options_type() == BuiltinOptions_TransposeOptions ? static_cast<const TransposeOptions *>(builtin_options()) : nullptr;
  }
  const ReducerOptions *builtin_options_as_ReducerOptions() const {
    return builtin_options_type() == BuiltinOptions_ReducerOptions ? static_cast<const ReducerOptions *>(builtin_options()) : nullptr;
  }
  const SubOptions *builtin_options_as_SubOptions() const {
    return builtin_options_type() == BuiltinOptions_SubOptions ? static_cast<const SubOptions *>(builtin_options()) : nullptr;
  }
  const DivOptions *builtin_options_as_DivOptions() const {
    return builtin_options_type() == BuiltinOptions_DivOptions ? static_cast<const DivOptions *>(builtin_options()) : nullptr;
  }
  const SqueezeOptions *builtin_options_as_SqueezeOptions() const {
    return builtin_options_type() == BuiltinOptions_SqueezeOptions ? static_cast<const SqueezeOptions *>(builtin_options()) : nullptr;
  }
  const SequenceRNNOptions *builtin_options_as_SequenceRNNOptions() const {
    return builtin_options_type() == BuiltinOptions_SequenceRNNOptions ? static_cast<const SequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const StridedSliceOptions *builtin_options_as_StridedSliceOptions() const {
    return builtin_options_type() == BuiltinOptions_StridedSliceOptions ? static_cast<const StridedSliceOptions *>(builtin_options()) : nullptr;
  }
  const ExpOptions *builtin_options_as_ExpOptions() const {
    return builtin_options_type() == BuiltinOptions_ExpOptions ? static_cast<const ExpOptions *>(builtin_options()) : nullptr;
  }
  const TopKV2Options *builtin_options_as_TopKV2Options() const {
    return builtin_options_type() == BuiltinOptions_TopKV2Options ? static_cast<const TopKV2Options *>(builtin_options()) : nullptr;
  }
  const SplitOptions *builtin_options_as_SplitOptions() const {
    return builtin_options_type() == BuiltinOptions_SplitOptions ? static_cast<const SplitOptions *>(builtin_options()) : nullptr;
  }
  const LogSoftmaxOptions *builtin_options_as_LogSoftmaxOptions() const {
    return builtin_options_type() == BuiltinOptions_LogSoftmaxOptions ? static_cast<const LogSoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const CastOptions *builtin_options_as_CastOptions() const {
    return builtin_options_type() == BuiltinOptions_CastOptions ? static_cast<const CastOptions *>(builtin_options()) : nullptr;
  }
  const DequantizeOptions *builtin_options_as_DequantizeOptions() const {
    return builtin_options_type() == BuiltinOptions_DequantizeOptions ? static_cast<const DequantizeOptions *>(builtin_options()) : nullptr;
  }
  const MaximumMinimumOptions *builtin_options_as_MaximumMinimumOptions() const {
    return builtin_options_type() == BuiltinOptions_MaximumMinimumOptions ? static_cast<const MaximumMinimumOptions *>(builtin_options()) : nullptr;
  }
  const ArgMaxOptions *builtin_options_as_ArgMaxOptions() const {
    return builtin_options_type() == BuiltinOptions_ArgMaxOptions ? static_cast<const ArgMaxOptions *>(builtin_options()) : nullptr;
  }
  const LessOptions *builtin_options_as_LessOptions() const {
    return builtin_options_type() == BuiltinOptions_LessOptions ? static_cast<const LessOptions *>(builtin_options()) : nullptr;
  }
  const NegOptions *builtin_options_as_NegOptions() const {
    return builtin_options_type() == BuiltinOptions_NegOptions ? static_cast<const NegOptions *>(builtin_options()) : nullptr;
  }
  const PadV2Options *builtin_options_as_PadV2Options() const {
    return builtin_options_type() == BuiltinOptions_PadV2Options ? static_cast<const PadV2Options *>(builtin_options()) : nullptr;
  }
  const GreaterOptions *builtin_options_as_GreaterOptions() const {
    return builtin_options_type() == BuiltinOptions_GreaterOptions ? static_cast<const GreaterOptions *>(builtin_options()) : nullptr;
  }
  const GreaterEqualOptions *builtin_options_as_GreaterEqualOptions() const {
    return builtin_options_type() == BuiltinOptions_GreaterEqualOptions ? static_cast<const GreaterEqualOptions *>(builtin_options()) : nullptr;
  }
  const LessEqualOptions *builtin_options_as_LessEqualOptions() const {
    return builtin_options_type() == BuiltinOptions_LessEqualOptions ? static_cast<const LessEqualOptions *>(builtin_options()) : nullptr;
  }
  const SelectOptions *builtin_options_as_SelectOptions() const {
    return builtin_options_type() == BuiltinOptions_SelectOptions ? static_cast<const SelectOptions *>(builtin_options()) : nullptr;
  }
  const SliceOptions *builtin_options_as_SliceOptions() const {
    return builtin_options_type() == BuiltinOptions_SliceOptions ? static_cast<const SliceOptions *>(builtin_options()) : nullptr;
  }
  const TransposeConvOptions *builtin_options_as_TransposeConvOptions() const {
    return builtin_options_type() == BuiltinOptions_TransposeConvOptions ? static_cast<const TransposeConvOptions *>(builtin_options()) : nullptr;
  }
  const SparseToDenseOptions *builtin_options_as_SparseToDenseOptions() const {
    return builtin_options_type() == BuiltinOptions_SparseToDenseOptions ? static_cast<const SparseToDenseOptions *>(builtin_options()) : nullptr;
  }
  const TileOptions *builtin_options_as_TileOptions() const {
    return builtin_options_type() == BuiltinOptions_TileOptions ? static_cast<const TileOptions *>(builtin_options()) : nullptr;
  }
  const ExpandDimsOptions *builtin_options_as_ExpandDimsOptions() const {
    return builtin_options_type() == BuiltinOptions_ExpandDimsOptions ? static_cast<const ExpandDimsOptions *>(builtin_options()) : nullptr;
  }
  const EqualOptions *builtin_options_as_EqualOptions() const {
    return builtin_options_type() == BuiltinOptions_EqualOptions ? static_cast<const EqualOptions *>(builtin_options()) : nullptr;
  }
  const NotEqualOptions *builtin_options_as_NotEqualOptions() const {
    return builtin_options_type() == BuiltinOptions_NotEqualOptions ? static_cast<const NotEqualOptions *>(builtin_options()) : nullptr;
  }
  const ShapeOptions *builtin_options_as_ShapeOptions() const {
    return builtin_options_type() == BuiltinOptions_ShapeOptions ? static_cast<const ShapeOptions *>(builtin_options()) : nullptr;
  }
  const PowOptions *builtin_options_as_PowOptions() const {
    return builtin_options_type() == BuiltinOptions_PowOptions ? static_cast<const PowOptions *>(builtin_options()) : nullptr;
  }
  const ArgMinOptions *builtin_options_as_ArgMinOptions() const {
    return builtin_options_type() == BuiltinOptions_ArgMinOptions ? static_cast<const ArgMinOptions *>(builtin_options()) : nullptr;
  }
  const FakeQuantOptions *builtin_options_as_FakeQuantOptions() const {
    return builtin_options_type() == BuiltinOptions_FakeQuantOptions ? static_cast<const FakeQuantOptions *>(builtin_options()) : nullptr;
  }
  const PackOptions *builtin_options_as_PackOptions() const {
    return builtin_options_type() == BuiltinOptions_PackOptions ? static_cast<const PackOptions *>(builtin_options()) : nullptr;
  }
  const LogicalOrOptions *builtin_options_as_LogicalOrOptions() const {
    return builtin_options_type() == BuiltinOptions_LogicalOrOptions ? static_cast<const LogicalOrOptions *>(builtin_options()) : nullptr;
  }
  const OneHotOptions *builtin_options_as_OneHotOptions() const {
    return builtin_options_type() == BuiltinOptions_OneHotOptions ? static_cast<const OneHotOptions *>(builtin_options()) : nullptr;
  }
  const LogicalAndOptions *builtin_options_as_LogicalAndOptions() const {
    return builtin_options_type() == BuiltinOptions_LogicalAndOptions ? static_cast<const LogicalAndOptions *>(builtin_options()) : nullptr;
  }
  const LogicalNotOptions *builtin_options_as_LogicalNotOptions() const {
    return builtin_options_type() == BuiltinOptions_LogicalNotOptions ? static_cast<const LogicalNotOptions *>(builtin_options()) : nullptr;
  }
  const UnpackOptions *builtin_options_as_UnpackOptions() const {
    return builtin_options_type() == BuiltinOptions_UnpackOptions ? static_cast<const UnpackOptions *>(builtin_options()) : nullptr;
  }
  const FloorDivOptions *builtin_options_as_FloorDivOptions() const {
    return builtin_options_type() == BuiltinOptions_FloorDivOptions ? static_cast<const FloorDivOptions *>(builtin_options()) : nullptr;
  }
  const SquareOptions *builtin_options_as_SquareOptions() const {
    return builtin_options_type() == BuiltinOptions_SquareOptions ? static_cast<const SquareOptions *>(builtin_options()) : nullptr;
  }
  const ZerosLikeOptions *builtin_options_as_ZerosLikeOptions() const {
    return builtin_options_type() == BuiltinOptions_ZerosLikeOptions ? static_cast<const ZerosLikeOptions *>(builtin_options()) : nullptr;
  }
  const FillOptions *builtin_options_as_FillOptions() const {
    return builtin_options_type() == BuiltinOptions_FillOptions ? static_cast<const FillOptions *>(builtin_options()) : nullptr;
  }
  const BidirectionalSequenceLSTMOptions *builtin_options_as_BidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == BuiltinOptions_BidirectionalSequenceLSTMOptions ? static_cast<const BidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const BidirectionalSequenceRNNOptions *builtin_options_as_BidirectionalSequenceRNNOptions() const {
    return builtin_options_type() == BuiltinOptions_BidirectionalSequenceRNNOptions ? static_cast<const BidirectionalSequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const UnidirectionalSequenceLSTMOptions *builtin_options_as_UnidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == BuiltinOptions_UnidirectionalSequenceLSTMOptions ? static_cast<const UnidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const FloorModOptions *builtin_options_as_FloorModOptions() const {
    return builtin_options_type() == BuiltinOptions_FloorModOptions ? static_cast<const FloorModOptions *>(builtin_options()) : nullptr;
  }
  const RangeOptions *builtin_options_as_RangeOptions() const {
    return builtin_options_type() == BuiltinOptions_RangeOptions ? static_cast<const RangeOptions *>(builtin_options()) : nullptr;
  }
  const ResizeNearestNeighborOptions *builtin_options_as_ResizeNearestNeighborOptions() const {
    return builtin_options_type() == BuiltinOptions_ResizeNearestNeighborOptions ? static_cast<const ResizeNearestNeighborOptions *>(builtin_options()) : nullptr;
  }
  const LeakyReluOptions *builtin_options_as_LeakyReluOptions() const {
    return builtin_options_type() == BuiltinOptions_LeakyReluOptions ? static_cast<const LeakyReluOptions *>(builtin_options()) : nullptr;
  }
  const SquaredDifferenceOptions *builtin_options_as_SquaredDifferenceOptions() const {
    return builtin_options_type() == BuiltinOptions_SquaredDifferenceOptions ? static_cast<const SquaredDifferenceOptions *>(builtin_options()) : nullptr;
  }
  const MirrorPadOptions *builtin_options_as_MirrorPadOptions() const {
    return builtin_options_type() == BuiltinOptions_MirrorPadOptions ? static_cast<const MirrorPadOptions *>(builtin_options()) : nullptr;
  }
  const AbsOptions *builtin_options_as_AbsOptions() const {
    return builtin_options_type() == BuiltinOptions_AbsOptions ? static_cast<const AbsOptions *>(builtin_options()) : nullptr;
  }
  const SplitVOptions *builtin_options_as_SplitVOptions() const {
    return builtin_options_type() == BuiltinOptions_SplitVOptions ? static_cast<const SplitVOptions *>(builtin_options()) : nullptr;
  }
  const UniqueOptions *builtin_options_as_UniqueOptions() const {
    return builtin_options_type() == BuiltinOptions_UniqueOptions ? static_cast<const UniqueOptions *>(builtin_options()) : nullptr;
  }
  const ReverseV2Options *builtin_options_as_ReverseV2Options() const {
    return builtin_options_type() == BuiltinOptions_ReverseV2Options ? static_cast<const ReverseV2Options *>(builtin_options()) : nullptr;
  }
  const AddNOptions *builtin_options_as_AddNOptions() const {
    return builtin_options_type() == BuiltinOptions_AddNOptions ? static_cast<const AddNOptions *>(builtin_options()) : nullptr;
  }
  const GatherNdOptions *builtin_options_as_GatherNdOptions() const {
    return builtin_options_type() == BuiltinOptions_GatherNdOptions ? static_cast<const GatherNdOptions *>(builtin_options()) : nullptr;
  }
  const CosOptions *builtin_options_as_CosOptions() const {
    return builtin_options_type() == BuiltinOptions_CosOptions ? static_cast<const CosOptions *>(builtin_options()) : nullptr;
  }
  const WhereOptions *builtin_options_as_WhereOptions() const {
    return builtin_options_type() == BuiltinOptions_WhereOptions ? static_cast<const WhereOptions *>(builtin_options()) : nullptr;
  }
  const RankOptions *builtin_options_as_RankOptions() const {
    return builtin_options_type() == BuiltinOptions_RankOptions ? static_cast<const RankOptions *>(builtin_options()) : nullptr;
  }
  const ReverseSequenceOptions *builtin_options_as_ReverseSequenceOptions() const {
    return builtin_options_type() == BuiltinOptions_ReverseSequenceOptions ? static_cast<const ReverseSequenceOptions *>(builtin_options()) : nullptr;
  }
  const MatrixDiagOptions *builtin_options_as_MatrixDiagOptions() const {
    return builtin_options_type() == BuiltinOptions_MatrixDiagOptions ? static_cast<const MatrixDiagOptions *>(builtin_options()) : nullptr;
  }
  const QuantizeOptions *builtin_options_as_QuantizeOptions() const {
    return builtin_options_type() == BuiltinOptions_QuantizeOptions ? static_cast<const QuantizeOptions *>(builtin_options()) : nullptr;
  }
  const MatrixSetDiagOptions *builtin_options_as_MatrixSetDiagOptions() const {
    return builtin_options_type() == BuiltinOptions_MatrixSetDiagOptions ? static_cast<const MatrixSetDiagOptions *>(builtin_options()) : nullptr;
  }
  const HardSwishOptions *builtin_options_as_HardSwishOptions() const {
    return builtin_options_type() == BuiltinOptions_HardSwishOptions ? static_cast<const HardSwishOptions *>(builtin_options()) : nullptr;
  }
  const IfOptions *builtin_options_as_IfOptions() const {
    return builtin_options_type() == BuiltinOptions_IfOptions ? static_cast<const IfOptions *>(builtin_options()) : nullptr;
  }
  const WhileOptions *builtin_options_as_WhileOptions() const {
    return builtin_options_type() == BuiltinOptions_WhileOptions ? static_cast<const WhileOptions *>(builtin_options()) : nullptr;
  }
  const DepthToSpaceOptions *builtin_options_as_DepthToSpaceOptions() const {
    return builtin_options_type() == BuiltinOptions_DepthToSpaceOptions ? static_cast<const DepthToSpaceOptions *>(builtin_options()) : nullptr;
  }
  const NonMaxSuppressionV4Options *builtin_options_as_NonMaxSuppressionV4Options() const {
    return builtin_options_type() == BuiltinOptions_NonMaxSuppressionV4Options ? static_cast<const NonMaxSuppressionV4Options *>(builtin_options()) : nullptr;
  }
  const NonMaxSuppressionV5Options *builtin_options_as_NonMaxSuppressionV5Options() const {
    return builtin_options_type() == BuiltinOptions_NonMaxSuppressionV5Options ? static_cast<const NonMaxSuppressionV5Options *>(builtin_options()) : nullptr;
  }
  const ScatterNdOptions *builtin_options_as_ScatterNdOptions() const {
    return builtin_options_type() == BuiltinOptions_ScatterNdOptions ? static_cast<const ScatterNdOptions *>(builtin_options()) : nullptr;
  }
  const SelectV2Options *builtin_options_as_SelectV2Options() const {
    return builtin_options_type() == BuiltinOptions_SelectV2Options ? static_cast<const SelectV2Options *>(builtin_options()) : nullptr;
  }
  const DensifyOptions *builtin_options_as_DensifyOptions() const {
    return builtin_options_type() == BuiltinOptions_DensifyOptions ? static_cast<const DensifyOptions *>(builtin_options()) : nullptr;
  }
  const SegmentSumOptions *builtin_options_as_SegmentSumOptions() const {
    return builtin_options_type() == BuiltinOptions_SegmentSumOptions ? static_cast<const SegmentSumOptions *>(builtin_options()) : nullptr;
  }
  const BatchMatMulOptions *builtin_options_as_BatchMatMulOptions() const {
    return builtin_options_type() == BuiltinOptions_BatchMatMulOptions ? static_cast<const BatchMatMulOptions *>(builtin_options()) : nullptr;
  }
  const CumsumOptions *builtin_options_as_CumsumOptions() const {
    return builtin_options_type() == BuiltinOptions_CumsumOptions ? static_cast<const CumsumOptions *>(builtin_options()) : nullptr;
  }
  const CallOnceOptions *builtin_options_as_CallOnceOptions() const {
    return builtin_options_type() == BuiltinOptions_CallOnceOptions ? static_cast<const CallOnceOptions *>(builtin_options()) : nullptr;
  }
  const BroadcastToOptions *builtin_options_as_BroadcastToOptions() const {
    return builtin_options_type() == BuiltinOptions_BroadcastToOptions ? static_cast<const BroadcastToOptions *>(builtin_options()) : nullptr;
  }
  const Rfft2dOptions *builtin_options_as_Rfft2dOptions() const {
    return builtin_options_type() == BuiltinOptions_Rfft2dOptions ? static_cast<const Rfft2dOptions *>(builtin_options()) : nullptr;
  }
  const Conv3DOptions *builtin_options_as_Conv3DOptions() const {
    return builtin_options_type() == BuiltinOptions_Conv3DOptions ? static_cast<const Conv3DOptions *>(builtin_options()) : nullptr;
  }
  const HashtableOptions *builtin_options_as_HashtableOptions() const {
    return builtin_options_type() == BuiltinOptions_HashtableOptions ? static_cast<const HashtableOptions *>(builtin_options()) : nullptr;
  }
  const HashtableFindOptions *builtin_options_as_HashtableFindOptions() const {
    return builtin_options_type() == BuiltinOptions_HashtableFindOptions ? static_cast<const HashtableFindOptions *>(builtin_options()) : nullptr;
  }
  const HashtableImportOptions *builtin_options_as_HashtableImportOptions() const {
    return builtin_options_type() == BuiltinOptions_HashtableImportOptions ? static_cast<const HashtableImportOptions *>(builtin_options()) : nullptr;
  }
  const HashtableSizeOptions *builtin_options_as_HashtableSizeOptions() const {
    return builtin_options_type() == BuiltinOptions_HashtableSizeOptions ? static_cast<const HashtableSizeOptions *>(builtin_options()) : nullptr;
  }
  const VarHandleOptions *builtin_options_as_VarHandleOptions() const {
    return builtin_options_type() == BuiltinOptions_VarHandleOptions ? static_cast<const VarHandleOptions *>(builtin_options()) : nullptr;
  }
  const ReadVariableOptions *builtin_options_as_ReadVariableOptions() const {
    return builtin_options_type() == BuiltinOptions_ReadVariableOptions ? static_cast<const ReadVariableOptions *>(builtin_options()) : nullptr;
  }
  const AssignVariableOptions *builtin_options_as_AssignVariableOptions() const {
    return builtin_options_type() == BuiltinOptions_AssignVariableOptions ? static_cast<const AssignVariableOptions *>(builtin_options()) : nullptr;
  }
  const RandomOptions *builtin_options_as_RandomOptions() const {
    return builtin_options_type() == BuiltinOptions_RandomOptions ? static_cast<const RandomOptions *>(builtin_options()) : nullptr;
  }
  const BucketizeOptions *builtin_options_as_BucketizeOptions() const {
    return builtin_options_type() == BuiltinOptions_BucketizeOptions ? static_cast<const BucketizeOptions *>(builtin_options()) : nullptr;
  }
  const GeluOptions *builtin_options_as_GeluOptions() const {
    return builtin_options_type() == BuiltinOptions_GeluOptions ? static_cast<const GeluOptions *>(builtin_options()) : nullptr;
  }
  const DynamicUpdateSliceOptions *builtin_options_as_DynamicUpdateSliceOptions() const {
    return builtin_options_type() == BuiltinOptions_DynamicUpdateSliceOptions ? static_cast<const DynamicUpdateSliceOptions *>(builtin_options()) : nullptr;
  }
  const UnsortedSegmentProdOptions *builtin_options_as_UnsortedSegmentProdOptions() const {
    return builtin_options_type() == BuiltinOptions_UnsortedSegmentProdOptions ? static_cast<const UnsortedSegmentProdOptions *>(builtin_options()) : nullptr;
  }
  const UnsortedSegmentMaxOptions *builtin_options_as_UnsortedSegmentMaxOptions() const {
    return builtin_options_type() == BuiltinOptions_UnsortedSegmentMaxOptions ? static_cast<const UnsortedSegmentMaxOptions *>(builtin_options()) : nullptr;
  }
  const UnsortedSegmentMinOptions *builtin_options_as_UnsortedSegmentMinOptions() const {
    return builtin_options_type() == BuiltinOptions_UnsortedSegmentMinOptions ? static_cast<const UnsortedSegmentMinOptions *>(builtin_options()) : nullptr;
  }
  const UnsortedSegmentSumOptions *builtin_options_as_UnsortedSegmentSumOptions() const {
    return builtin_options_type() == BuiltinOptions_UnsortedSegmentSumOptions ? static_cast<const UnsortedSegmentSumOptions *>(builtin_options()) : nullptr;
  }
  const ATan2Options *builtin_options_as_ATan2Options() const {
    return builtin_options_type() == BuiltinOptions_ATan2Options ? static_cast<const ATan2Options *>(builtin_options()) : nullptr;
  }
  const SignOptions *builtin_options_as_SignOptions() const {
    return builtin_options_type() == BuiltinOptions_SignOptions ? static_cast<const SignOptions *>(builtin_options()) : nullptr;
  }
  const BitcastOptions *builtin_options_as_BitcastOptions() const {
    return builtin_options_type() == BuiltinOptions_BitcastOptions ? static_cast<const BitcastOptions *>(builtin_options()) : nullptr;
  }
  const BitwiseXorOptions *builtin_options_as_BitwiseXorOptions() const {
    return builtin_options_type() == BuiltinOptions_BitwiseXorOptions ? static_cast<const BitwiseXorOptions *>(builtin_options()) : nullptr;
  }
  const RightShiftOptions *builtin_options_as_RightShiftOptions() const {
    return builtin_options_type() == BuiltinOptions_RightShiftOptions ? static_cast<const RightShiftOptions *>(builtin_options()) : nullptr;
  }
  const flatbuffers::Vector<uint8_t> *custom_options() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(14);
  }
  CustomOptionsFormat custom_options_format() const {
    return static_cast<CustomOptionsFormat>(GetField<int8_t>(16, 0));
  }
  const flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(18);
  }
  const flatbuffers::Vector<int32_t> *intermediates() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(20);
  }
  uint64_t large_custom_options_offset() const {
    return GetField<uint64_t>(22, 0);
  }
  uint64_t large_custom_options_size() const {
    return GetField<uint64_t>(24, 0);
  }
  BuiltinOptions2 builtin_options_2_type() const {
    return static_cast<BuiltinOptions2>(GetField<uint8_t>(26, 0));
  }
  const void *builtin_options_2() const {
    return GetPointer<const void *>(28);
  }
  template<typename T> const T *builtin_options_2_as() const;
  const StablehloConcatenateOptions *builtin_options_2_as_StablehloConcatenateOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloConcatenateOptions ? static_cast<const StablehloConcatenateOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloBroadcastInDimOptions *builtin_options_2_as_StablehloBroadcastInDimOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloBroadcastInDimOptions ? static_cast<const StablehloBroadcastInDimOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloSliceOptions *builtin_options_2_as_StablehloSliceOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloSliceOptions ? static_cast<const StablehloSliceOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloConvolutionOptions *builtin_options_2_as_StablehloConvolutionOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloConvolutionOptions ? static_cast<const StablehloConvolutionOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloCustomCallOptions *builtin_options_2_as_StablehloCustomCallOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloCustomCallOptions ? static_cast<const StablehloCustomCallOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloReduceOptions *builtin_options_2_as_StablehloReduceOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloReduceOptions ? static_cast<const StablehloReduceOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloScatterOptions *builtin_options_2_as_StablehloScatterOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloScatterOptions ? static_cast<const StablehloScatterOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloCompareOptions *builtin_options_2_as_StablehloCompareOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloCompareOptions ? static_cast<const StablehloCompareOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloDynamicSliceOptions *builtin_options_2_as_StablehloDynamicSliceOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloDynamicSliceOptions ? static_cast<const StablehloDynamicSliceOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloPadOptions *builtin_options_2_as_StablehloPadOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloPadOptions ? static_cast<const StablehloPadOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloIotaOptions *builtin_options_2_as_StablehloIotaOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloIotaOptions ? static_cast<const StablehloIotaOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloDotGeneralOptions *builtin_options_2_as_StablehloDotGeneralOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloDotGeneralOptions ? static_cast<const StablehloDotGeneralOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloReduceWindowOptions *builtin_options_2_as_StablehloReduceWindowOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloReduceWindowOptions ? static_cast<const StablehloReduceWindowOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloSortOptions *builtin_options_2_as_StablehloSortOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloSortOptions ? static_cast<const StablehloSortOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloWhileOptions *builtin_options_2_as_StablehloWhileOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloWhileOptions ? static_cast<const StablehloWhileOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloGatherOptions *builtin_options_2_as_StablehloGatherOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloGatherOptions ? static_cast<const StablehloGatherOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloTransposeOptions *builtin_options_2_as_StablehloTransposeOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloTransposeOptions ? static_cast<const StablehloTransposeOptions *>(builtin_options_2()) : nullptr;
  }
  const DilateOptions *builtin_options_2_as_DilateOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_DilateOptions ? static_cast<const DilateOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloRngBitGeneratorOptions *builtin_options_2_as_StablehloRngBitGeneratorOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloRngBitGeneratorOptions ? static_cast<const StablehloRngBitGeneratorOptions *>(builtin_options_2()) : nullptr;
  }
  const ReduceWindowOptions *builtin_options_2_as_ReduceWindowOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_ReduceWindowOptions ? static_cast<const ReduceWindowOptions *>(builtin_options_2()) : nullptr;
  }
  const StableHLOCompositeOptions *builtin_options_2_as_StableHLOCompositeOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StableHLOCompositeOptions ? static_cast<const StableHLOCompositeOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloShiftLeftOptions *builtin_options_2_as_StablehloShiftLeftOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloShiftLeftOptions ? static_cast<const StablehloShiftLeftOptions *>(builtin_options_2()) : nullptr;
  }
  const StablehloCaseOptions *builtin_options_2_as_StablehloCaseOptions() const {
    return builtin_options_2_type() == BuiltinOptions2_StablehloCaseOptions ? static_cast<const StablehloCaseOptions *>(builtin_options_2()) : nullptr;
  }
  int32_t debug_metadata_index() const {
    return GetField<int32_t>(30, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(outputs()) &&
           VerifyField<uint8_t>(verifier, 10) &&
           VerifyOffset(verifier, 12) &&
           VerifyBuiltinOptions(verifier, builtin_options(), builtin_options_type()) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyVector(custom_options()) &&
           VerifyField<int8_t>(verifier, 16) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyVector(mutating_variable_inputs()) &&
           VerifyOffset(verifier, 20) &&
           verifier.VerifyVector(intermediates()) &&
           VerifyField<uint64_t>(verifier, 22) &&
           VerifyField<uint64_t>(verifier, 24) &&
           VerifyField<uint8_t>(verifier, 26) &&
           VerifyOffset(verifier, 28) &&
           VerifyBuiltinOptions2(verifier, builtin_options_2(), builtin_options_2_type()) &&
           VerifyField<int32_t>(verifier, 30) &&
           verifier.EndTable();
  }
  OperatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Operator> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Conv2DOptions *Operator::builtin_options_as<Conv2DOptions>() const {
  return builtin_options_as_Conv2DOptions();
}

template<> inline const DepthwiseConv2DOptions *Operator::builtin_options_as<DepthwiseConv2DOptions>() const {
  return builtin_options_as_DepthwiseConv2DOptions();
}

template<> inline const ConcatEmbeddingsOptions *Operator::builtin_options_as<ConcatEmbeddingsOptions>() const {
  return builtin_options_as_ConcatEmbeddingsOptions();
}

template<> inline const LSHProjectionOptions *Operator::builtin_options_as<LSHProjectionOptions>() const {
  return builtin_options_as_LSHProjectionOptions();
}

template<> inline const Pool2DOptions *Operator::builtin_options_as<Pool2DOptions>() const {
  return builtin_options_as_Pool2DOptions();
}

template<> inline const SVDFOptions *Operator::builtin_options_as<SVDFOptions>() const {
  return builtin_options_as_SVDFOptions();
}

template<> inline const RNNOptions *Operator::builtin_options_as<RNNOptions>() const {
  return builtin_options_as_RNNOptions();
}

template<> inline const FullyConnectedOptions *Operator::builtin_options_as<FullyConnectedOptions>() const {
  return builtin_options_as_FullyConnectedOptions();
}

template<> inline const SoftmaxOptions *Operator::builtin_options_as<SoftmaxOptions>() const {
  return builtin_options_as_SoftmaxOptions();
}

template<> inline const ConcatenationOptions *Operator::builtin_options_as<ConcatenationOptions>() const {
  return builtin_options_as_ConcatenationOptions();
}

template<> inline const AddOptions *Operator::builtin_options_as<AddOptions>() const {
  return builtin_options_as_AddOptions();
}

template<> inline const L2NormOptions *Operator::builtin_options_as<L2NormOptions>() const {
  return builtin_options_as_L2NormOptions();
}

template<> inline const LocalResponseNormalizationOptions *Operator::builtin_options_as<LocalResponseNormalizationOptions>() const {
  return builtin_options_as_LocalResponseNormalizationOptions();
}

template<> inline const LSTMOptions *Operator::builtin_options_as<LSTMOptions>() const {
  return builtin_options_as_LSTMOptions();
}

template<> inline const ResizeBilinearOptions *Operator::builtin_options_as<ResizeBilinearOptions>() const {
  return builtin_options_as_ResizeBilinearOptions();
}

template<> inline const CallOptions *Operator::builtin_options_as<CallOptions>() const {
  return builtin_options_as_CallOptions();
}

template<> inline const ReshapeOptions *Operator::builtin_options_as<ReshapeOptions>() const {
  return builtin_options_as_ReshapeOptions();
}

template<> inline const SkipGramOptions *Operator::builtin_options_as<SkipGramOptions>() const {
  return builtin_options_as_SkipGramOptions();
}

template<> inline const SpaceToDepthOptions *Operator::builtin_options_as<SpaceToDepthOptions>() const {
  return builtin_options_as_SpaceToDepthOptions();
}

template<> inline const EmbeddingLookupSparseOptions *Operator::builtin_options_as<EmbeddingLookupSparseOptions>() const {
  return builtin_options_as_EmbeddingLookupSparseOptions();
}

template<> inline const MulOptions *Operator::builtin_options_as<MulOptions>() const {
  return builtin_options_as_MulOptions();
}

template<> inline const PadOptions *Operator::builtin_options_as<PadOptions>() const {
  return builtin_options_as_PadOptions();
}

template<> inline const GatherOptions *Operator::builtin_options_as<GatherOptions>() const {
  return builtin_options_as_GatherOptions();
}

template<> inline const BatchToSpaceNDOptions *Operator::builtin_options_as<BatchToSpaceNDOptions>() const {
  return builtin_options_as_BatchToSpaceNDOptions();
}

template<> inline const SpaceToBatchNDOptions *Operator::builtin_options_as<SpaceToBatchNDOptions>() const {
  return builtin_options_as_SpaceToBatchNDOptions();
}

template<> inline const TransposeOptions *Operator::builtin_options_as<TransposeOptions>() const {
  return builtin_options_as_TransposeOptions();
}

template<> inline const ReducerOptions *Operator::builtin_options_as<ReducerOptions>() const {
  return builtin_options_as_ReducerOptions();
}

template<> inline const SubOptions *Operator::builtin_options_as<SubOptions>() const {
  return builtin_options_as_SubOptions();
}

template<> inline const DivOptions *Operator::builtin_options_as<DivOptions>() const {
  return builtin_options_as_DivOptions();
}

template<> inline const SqueezeOptions *Operator::builtin_options_as<SqueezeOptions>() const {
  return builtin_options_as_SqueezeOptions();
}

template<> inline const SequenceRNNOptions *Operator::builtin_options_as<SequenceRNNOptions>() const {
  return builtin_options_as_SequenceRNNOptions();
}

template<> inline const StridedSliceOptions *Operator::builtin_options_as<StridedSliceOptions>() const {
  return builtin_options_as_StridedSliceOptions();
}

template<> inline const ExpOptions *Operator::builtin_options_as<ExpOptions>() const {
  return builtin_options_as_ExpOptions();
}

template<> inline const TopKV2Options *Operator::builtin_options_as<TopKV2Options>() const {
  return builtin_options_as_TopKV2Options();
}

template<> inline const SplitOptions *Operator::builtin_options_as<SplitOptions>() const {
  return builtin_options_as_SplitOptions();
}

template<> inline const LogSoftmaxOptions *Operator::builtin_options_as<LogSoftmaxOptions>() const {
  return builtin_options_as_LogSoftmaxOptions();
}

template<> inline const CastOptions *Operator::builtin_options_as<CastOptions>() const {
  return builtin_options_as_CastOptions();
}

template<> inline const DequantizeOptions *Operator::builtin_options_as<DequantizeOptions>() const {
  return builtin_options_as_DequantizeOptions();
}

template<> inline const MaximumMinimumOptions *Operator::builtin_options_as<MaximumMinimumOptions>() const {
  return builtin_options_as_MaximumMinimumOptions();
}

template<> inline const ArgMaxOptions *Operator::builtin_options_as<ArgMaxOptions>() const {
  return builtin_options_as_ArgMaxOptions();
}

template<> inline const LessOptions *Operator::builtin_options_as<LessOptions>() const {
  return builtin_options_as_LessOptions();
}

template<> inline const NegOptions *Operator::builtin_options_as<NegOptions>() const {
  return builtin_options_as_NegOptions();
}

template<> inline const PadV2Options *Operator::builtin_options_as<PadV2Options>() const {
  return builtin_options_as_PadV2Options();
}

template<> inline const GreaterOptions *Operator::builtin_options_as<GreaterOptions>() const {
  return builtin_options_as_GreaterOptions();
}

template<> inline const GreaterEqualOptions *Operator::builtin_options_as<GreaterEqualOptions>() const {
  return builtin_options_as_GreaterEqualOptions();
}

template<> inline const LessEqualOptions *Operator::builtin_options_as<LessEqualOptions>() const {
  return builtin_options_as_LessEqualOptions();
}

template<> inline const SelectOptions *Operator::builtin_options_as<SelectOptions>() const {
  return builtin_options_as_SelectOptions();
}

template<> inline const SliceOptions *Operator::builtin_options_as<SliceOptions>() const {
  return builtin_options_as_SliceOptions();
}

template<> inline const TransposeConvOptions *Operator::builtin_options_as<TransposeConvOptions>() const {
  return builtin_options_as_TransposeConvOptions();
}

template<> inline const SparseToDenseOptions *Operator::builtin_options_as<SparseToDenseOptions>() const {
  return builtin_options_as_SparseToDenseOptions();
}

template<> inline const TileOptions *Operator::builtin_options_as<TileOptions>() const {
  return builtin_options_as_TileOptions();
}

template<> inline const ExpandDimsOptions *Operator::builtin_options_as<ExpandDimsOptions>() const {
  return builtin_options_as_ExpandDimsOptions();
}

template<> inline const EqualOptions *Operator::builtin_options_as<EqualOptions>() const {
  return builtin_options_as_EqualOptions();
}

template<> inline const NotEqualOptions *Operator::builtin_options_as<NotEqualOptions>() const {
  return builtin_options_as_NotEqualOptions();
}

template<> inline const ShapeOptions *Operator::builtin_options_as<ShapeOptions>() const {
  return builtin_options_as_ShapeOptions();
}

template<> inline const PowOptions *Operator::builtin_options_as<PowOptions>() const {
  return builtin_options_as_PowOptions();
}

template<> inline const ArgMinOptions *Operator::builtin_options_as<ArgMinOptions>() const {
  return builtin_options_as_ArgMinOptions();
}

template<> inline const FakeQuantOptions *Operator::builtin_options_as<FakeQuantOptions>() const {
  return builtin_options_as_FakeQuantOptions();
}

template<> inline const PackOptions *Operator::builtin_options_as<PackOptions>() const {
  return builtin_options_as_PackOptions();
}

template<> inline const LogicalOrOptions *Operator::builtin_options_as<LogicalOrOptions>() const {
  return builtin_options_as_LogicalOrOptions();
}

template<> inline const OneHotOptions *Operator::builtin_options_as<OneHotOptions>() const {
  return builtin_options_as_OneHotOptions();
}

template<> inline const LogicalAndOptions *Operator::builtin_options_as<LogicalAndOptions>() const {
  return builtin_options_as_LogicalAndOptions();
}

template<> inline const LogicalNotOptions *Operator::builtin_options_as<LogicalNotOptions>() const {
  return builtin_options_as_LogicalNotOptions();
}

template<> inline const UnpackOptions *Operator::builtin_options_as<UnpackOptions>() const {
  return builtin_options_as_UnpackOptions();
}

template<> inline const FloorDivOptions *Operator::builtin_options_as<FloorDivOptions>() const {
  return builtin_options_as_FloorDivOptions();
}

template<> inline const SquareOptions *Operator::builtin_options_as<SquareOptions>() const {
  return builtin_options_as_SquareOptions();
}

template<> inline const ZerosLikeOptions *Operator::builtin_options_as<ZerosLikeOptions>() const {
  return builtin_options_as_ZerosLikeOptions();
}

template<> inline const FillOptions *Operator::builtin_options_as<FillOptions>() const {
  return builtin_options_as_FillOptions();
}

template<> inline const BidirectionalSequenceLSTMOptions *Operator::builtin_options_as<BidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_BidirectionalSequenceLSTMOptions();
}

template<> inline const BidirectionalSequenceRNNOptions *Operator::builtin_options_as<BidirectionalSequenceRNNOptions>() const {
  return builtin_options_as_BidirectionalSequenceRNNOptions();
}

template<> inline const UnidirectionalSequenceLSTMOptions *Operator::builtin_options_as<UnidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_UnidirectionalSequenceLSTMOptions();
}

template<> inline const FloorModOptions *Operator::builtin_options_as<FloorModOptions>() const {
  return builtin_options_as_FloorModOptions();
}

template<> inline const RangeOptions *Operator::builtin_options_as<RangeOptions>() const {
  return builtin_options_as_RangeOptions();
}

template<> inline const ResizeNearestNeighborOptions *Operator::builtin_options_as<ResizeNearestNeighborOptions>() const {
  return builtin_options_as_ResizeNearestNeighborOptions();
}

template<> inline const LeakyReluOptions *Operator::builtin_options_as<LeakyReluOptions>() const {
  return builtin_options_as_LeakyReluOptions();
}

template<> inline const SquaredDifferenceOptions *Operator::builtin_options_as<SquaredDifferenceOptions>() const {
  return builtin_options_as_SquaredDifferenceOptions();
}

template<> inline const MirrorPadOptions *Operator::builtin_options_as<MirrorPadOptions>() const {
  return builtin_options_as_MirrorPadOptions();
}

template<> inline const AbsOptions *Operator::builtin_options_as<AbsOptions>() const {
  return builtin_options_as_AbsOptions();
}

template<> inline const SplitVOptions *Operator::builtin_options_as<SplitVOptions>() const {
  return builtin_options_as_SplitVOptions();
}

template<> inline const UniqueOptions *Operator::builtin_options_as<UniqueOptions>() const {
  return builtin_options_as_UniqueOptions();
}

template<> inline const ReverseV2Options *Operator::builtin_options_as<ReverseV2Options>() const {
  return builtin_options_as_ReverseV2Options();
}

template<> inline const AddNOptions *Operator::builtin_options_as<AddNOptions>() const {
  return builtin_options_as_AddNOptions();
}

template<> inline const GatherNdOptions *Operator::builtin_options_as<GatherNdOptions>() const {
  return builtin_options_as_GatherNdOptions();
}

template<> inline const CosOptions *Operator::builtin_options_as<CosOptions>() const {
  return builtin_options_as_CosOptions();
}

template<> inline const WhereOptions *Operator::builtin_options_as<WhereOptions>() const {
  return builtin_options_as_WhereOptions();
}

template<> inline const RankOptions *Operator::builtin_options_as<RankOptions>() const {
  return builtin_options_as_RankOptions();
}

template<> inline const ReverseSequenceOptions *Operator::builtin_options_as<ReverseSequenceOptions>() const {
  return builtin_options_as_ReverseSequenceOptions();
}

template<> inline const MatrixDiagOptions *Operator::builtin_options_as<MatrixDiagOptions>() const {
  return builtin_options_as_MatrixDiagOptions();
}

template<> inline const QuantizeOptions *Operator::builtin_options_as<QuantizeOptions>() const {
  return builtin_options_as_QuantizeOptions();
}

template<> inline const MatrixSetDiagOptions *Operator::builtin_options_as<MatrixSetDiagOptions>() const {
  return builtin_options_as_MatrixSetDiagOptions();
}

template<> inline const HardSwishOptions *Operator::builtin_options_as<HardSwishOptions>() const {
  return builtin_options_as_HardSwishOptions();
}

template<> inline const IfOptions *Operator::builtin_options_as<IfOptions>() const {
  return builtin_options_as_IfOptions();
}

template<> inline const WhileOptions *Operator::builtin_options_as<WhileOptions>() const {
  return builtin_options_as_WhileOptions();
}

template<> inline const DepthToSpaceOptions *Operator::builtin_options_as<DepthToSpaceOptions>() const {
  return builtin_options_as_DepthToSpaceOptions();
}

template<> inline const NonMaxSuppressionV4Options *Operator::builtin_options_as<NonMaxSuppressionV4Options>() const {
  return builtin_options_as_NonMaxSuppressionV4Options();
}

template<> inline const NonMaxSuppressionV5Options *Operator::builtin_options_as<NonMaxSuppressionV5Options>() const {
  return builtin_options_as_NonMaxSuppressionV5Options();
}

template<> inline const ScatterNdOptions *Operator::builtin_options_as<ScatterNdOptions>() const {
  return builtin_options_as_ScatterNdOptions();
}

template<> inline const SelectV2Options *Operator::builtin_options_as<SelectV2Options>() const {
  return builtin_options_as_SelectV2Options();
}

template<> inline const DensifyOptions *Operator::builtin_options_as<DensifyOptions>() const {
  return builtin_options_as_DensifyOptions();
}

template<> inline const SegmentSumOptions *Operator::builtin_options_as<SegmentSumOptions>() const {
  return builtin_options_as_SegmentSumOptions();
}

template<> inline const BatchMatMulOptions *Operator::builtin_options_as<BatchMatMulOptions>() const {
  return builtin_options_as_BatchMatMulOptions();
}

template<> inline const CumsumOptions *Operator::builtin_options_as<CumsumOptions>() const {
  return builtin_options_as_CumsumOptions();
}

template<> inline const CallOnceOptions *Operator::builtin_options_as<CallOnceOptions>() const {
  return builtin_options_as_CallOnceOptions();
}

template<> inline const BroadcastToOptions *Operator::builtin_options_as<BroadcastToOptions>() const {
  return builtin_options_as_BroadcastToOptions();
}

template<> inline const Rfft2dOptions *Operator::builtin_options_as<Rfft2dOptions>() const {
  return builtin_options_as_Rfft2dOptions();
}

template<> inline const Conv3DOptions *Operator::builtin_options_as<Conv3DOptions>() const {
  return builtin_options_as_Conv3DOptions();
}

template<> inline const HashtableOptions *Operator::builtin_options_as<HashtableOptions>() const {
  return builtin_options_as_HashtableOptions();
}

template<> inline const HashtableFindOptions *Operator::builtin_options_as<HashtableFindOptions>() const {
  return builtin_options_as_HashtableFindOptions();
}

template<> inline const HashtableImportOptions *Operator::builtin_options_as<HashtableImportOptions>() const {
  return builtin_options_as_HashtableImportOptions();
}

template<> inline const HashtableSizeOptions *Operator::builtin_options_as<HashtableSizeOptions>() const {
  return builtin_options_as_HashtableSizeOptions();
}

template<> inline const VarHandleOptions *Operator::builtin_options_as<VarHandleOptions>() const {
  return builtin_options_as_VarHandleOptions();
}

template<> inline const ReadVariableOptions *Operator::builtin_options_as<ReadVariableOptions>() const {
  return builtin_options_as_ReadVariableOptions();
}

template<> inline const AssignVariableOptions *Operator::builtin_options_as<AssignVariableOptions>() const {
  return builtin_options_as_AssignVariableOptions();
}

template<> inline const RandomOptions *Operator::builtin_options_as<RandomOptions>() const {
  return builtin_options_as_RandomOptions();
}

template<> inline const BucketizeOptions *Operator::builtin_options_as<BucketizeOptions>() const {
  return builtin_options_as_BucketizeOptions();
}

template<> inline const GeluOptions *Operator::builtin_options_as<GeluOptions>() const {
  return builtin_options_as_GeluOptions();
}

template<> inline const DynamicUpdateSliceOptions *Operator::builtin_options_as<DynamicUpdateSliceOptions>() const {
  return builtin_options_as_DynamicUpdateSliceOptions();
}

template<> inline const UnsortedSegmentProdOptions *Operator::builtin_options_as<UnsortedSegmentProdOptions>() const {
  return builtin_options_as_UnsortedSegmentProdOptions();
}

template<> inline const UnsortedSegmentMaxOptions *Operator::builtin_options_as<UnsortedSegmentMaxOptions>() const {
  return builtin_options_as_UnsortedSegmentMaxOptions();
}

template<> inline const UnsortedSegmentMinOptions *Operator::builtin_options_as<UnsortedSegmentMinOptions>() const {
  return builtin_options_as_UnsortedSegmentMinOptions();
}

template<> inline const UnsortedSegmentSumOptions *Operator::builtin_options_as<UnsortedSegmentSumOptions>() const {
  return builtin_options_as_UnsortedSegmentSumOptions();
}

template<> inline const ATan2Options *Operator::builtin_options_as<ATan2Options>() const {
  return builtin_options_as_ATan2Options();
}

template<> inline const SignOptions *Operator::builtin_options_as<SignOptions>() const {
  return builtin_options_as_SignOptions();
}

template<> inline const BitcastOptions *Operator::builtin_options_as<BitcastOptions>() const {
  return builtin_options_as_BitcastOptions();
}

template<> inline const BitwiseXorOptions *Operator::builtin_options_as<BitwiseXorOptions>() const {
  return builtin_options_as_BitwiseXorOptions();
}

template<> inline const RightShiftOptions *Operator::builtin_options_as<RightShiftOptions>() const {
  return builtin_options_as_RightShiftOptions();
}

template<> inline const StablehloConcatenateOptions *Operator::builtin_options_2_as<StablehloConcatenateOptions>() const {
  return builtin_options_2_as_StablehloConcatenateOptions();
}

template<> inline const StablehloBroadcastInDimOptions *Operator::builtin_options_2_as<StablehloBroadcastInDimOptions>() const {
  return builtin_options_2_as_StablehloBroadcastInDimOptions();
}

template<> inline const StablehloSliceOptions *Operator::builtin_options_2_as<StablehloSliceOptions>() const {
  return builtin_options_2_as_StablehloSliceOptions();
}

template<> inline const StablehloConvolutionOptions *Operator::builtin_options_2_as<StablehloConvolutionOptions>() const {
  return builtin_options_2_as_StablehloConvolutionOptions();
}

template<> inline const StablehloCustomCallOptions *Operator::builtin_options_2_as<StablehloCustomCallOptions>() const {
  return builtin_options_2_as_StablehloCustomCallOptions();
}

template<> inline const StablehloReduceOptions *Operator::builtin_options_2_as<StablehloReduceOptions>() const {
  return builtin_options_2_as_StablehloReduceOptions();
}

template<> inline const StablehloScatterOptions *Operator::builtin_options_2_as<StablehloScatterOptions>() const {
  return builtin_options_2_as_StablehloScatterOptions();
}

template<> inline const StablehloCompareOptions *Operator::builtin_options_2_as<StablehloCompareOptions>() const {
  return builtin_options_2_as_StablehloCompareOptions();
}

template<> inline const StablehloDynamicSliceOptions *Operator::builtin_options_2_as<StablehloDynamicSliceOptions>() const {
  return builtin_options_2_as_StablehloDynamicSliceOptions();
}

template<> inline const StablehloPadOptions *Operator::builtin_options_2_as<StablehloPadOptions>() const {
  return builtin_options_2_as_StablehloPadOptions();
}

template<> inline const StablehloIotaOptions *Operator::builtin_options_2_as<StablehloIotaOptions>() const {
  return builtin_options_2_as_StablehloIotaOptions();
}

template<> inline const StablehloDotGeneralOptions *Operator::builtin_options_2_as<StablehloDotGeneralOptions>() const {
  return builtin_options_2_as_StablehloDotGeneralOptions();
}

template<> inline const StablehloReduceWindowOptions *Operator::builtin_options_2_as<StablehloReduceWindowOptions>() const {
  return builtin_options_2_as_StablehloReduceWindowOptions();
}

template<> inline const StablehloSortOptions *Operator::builtin_options_2_as<StablehloSortOptions>() const {
  return builtin_options_2_as_StablehloSortOptions();
}

template<> inline const StablehloWhileOptions *Operator::builtin_options_2_as<StablehloWhileOptions>() const {
  return builtin_options_2_as_StablehloWhileOptions();
}

template<> inline const StablehloGatherOptions *Operator::builtin_options_2_as<StablehloGatherOptions>() const {
  return builtin_options_2_as_StablehloGatherOptions();
}

template<> inline const StablehloTransposeOptions *Operator::builtin_options_2_as<StablehloTransposeOptions>() const {
  return builtin_options_2_as_StablehloTransposeOptions();
}

template<> inline const DilateOptions *Operator::builtin_options_2_as<DilateOptions>() const {
  return builtin_options_2_as_DilateOptions();
}

template<> inline const StablehloRngBitGeneratorOptions *Operator::builtin_options_2_as<StablehloRngBitGeneratorOptions>() const {
  return builtin_options_2_as_StablehloRngBitGeneratorOptions();
}

template<> inline const ReduceWindowOptions *Operator::builtin_options_2_as<ReduceWindowOptions>() const {
  return builtin_options_2_as_ReduceWindowOptions();
}

template<> inline const StableHLOCompositeOptions *Operator::builtin_options_2_as<StableHLOCompositeOptions>() const {
  return builtin_options_2_as_StableHLOCompositeOptions();
}

template<> inline const StablehloShiftLeftOptions *Operator::builtin_options_2_as<StablehloShiftLeftOptions>() const {
  return builtin_options_2_as_StablehloShiftLeftOptions();
}

template<> inline const StablehloCaseOptions *Operator::builtin_options_2_as<StablehloCaseOptions>() const {
  return builtin_options_2_as_StablehloCaseOptions();
}

struct OperatorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opcode_index(uint32_t opcode_index) {
    fbb_.AddElement<uint32_t>(4, opcode_index, 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(6, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(8, outputs);
  }
  void add_builtin_options_type(BuiltinOptions builtin_options_type) {
    fbb_.AddElement<uint8_t>(10, static_cast<uint8_t>(builtin_options_type), 0);
  }
  void add_builtin_options(flatbuffers::Offset<void> builtin_options) {
    fbb_.AddOffset(12, builtin_options);
  }
  void add_custom_options(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options) {
    fbb_.AddOffset(14, custom_options);
  }
  void add_custom_options_format(CustomOptionsFormat custom_options_format) {
    fbb_.AddElement<int8_t>(16, static_cast<int8_t>(custom_options_format), 0);
  }
  void add_mutating_variable_inputs(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs) {
    fbb_.AddOffset(18, mutating_variable_inputs);
  }
  void add_intermediates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates) {
    fbb_.AddOffset(20, intermediates);
  }
  void add_large_custom_options_offset(uint64_t large_custom_options_offset) {
    fbb_.AddElement<uint64_t>(22, large_custom_options_offset, 0);
  }
  void add_large_custom_options_size(uint64_t large_custom_options_size) {
    fbb_.AddElement<uint64_t>(24, large_custom_options_size, 0);
  }
  void add_builtin_options_2_type(BuiltinOptions2 builtin_options_2_type) {
    fbb_.AddElement<uint8_t>(26, static_cast<uint8_t>(builtin_options_2_type), 0);
  }
  void add_builtin_options_2(flatbuffers::Offset<void> builtin_options_2) {
    fbb_.AddOffset(28, builtin_options_2);
  }
  void add_debug_metadata_index(int32_t debug_metadata_index) {
    fbb_.AddElement<int32_t>(30, debug_metadata_index, -1);
  }
  explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorBuilder &operator=(const OperatorBuilder &);
  flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline flatbuffers::Offset<Operator> CreateOperator(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    BuiltinOptions builtin_options_type = BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options = 0,
    CustomOptionsFormat custom_options_format = CustomOptionsFormat_FLEXBUFFERS,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates = 0,
    uint64_t large_custom_options_offset = 0,
    uint64_t large_custom_options_size = 0,
    BuiltinOptions2 builtin_options_2_type = BuiltinOptions2_NONE,
    flatbuffers::Offset<void> builtin_options_2 = 0,
    int32_t debug_metadata_index = -1) {
  OperatorBuilder builder_(_fbb);
  builder_.add_large_custom_options_size(large_custom_options_size);
  builder_.add_large_custom_options_offset(large_custom_options_offset);
  builder_.add_debug_metadata_index(debug_metadata_index);
  builder_.add_builtin_options_2(builtin_options_2);
  builder_.add_intermediates(intermediates);
  builder_.add_mutating_variable_inputs(mutating_variable_inputs);
  builder_.add_custom_options(custom_options);
  builder_.add_builtin_options(builtin_options);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_opcode_index(opcode_index);
  builder_.add_builtin_options_2_type(builtin_options_2_type);
  builder_.add_custom_options_format(custom_options_format);
  builder_.add_builtin_options_type(builtin_options_type);
  return builder_.Finish();
}

flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphT : public flatbuffers::NativeTable {
  typedef SubGraph TableType;
  std::vector<std::unique_ptr<TensorT>> tensors;
  std::vector<int32_t> inputs;
  std::vector<int32_t> outputs;
  std::vector<std::unique_ptr<OperatorT>> operators;
  std::string name;
  int32_t debug_metadata_index;
  SubGraphT()
      : debug_metadata_index(-1) {
  }
};

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGraphT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubGraphTypeTable();
  }
  const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *>(4);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Operator>> *operators() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Operator>> *>(10);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(12);
  }
  int32_t debug_metadata_index() const {
    return GetField<int32_t>(14, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, 14) &&
           verifier.EndTable();
  }
  SubGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> tensors) {
    fbb_.AddOffset(4, tensors);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(6, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(8, outputs);
  }
  void add_operators(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Operator>>> operators) {
    fbb_.AddOffset(10, operators);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(12, name);
  }
  void add_debug_metadata_index(int32_t debug_metadata_index) {
    fbb_.AddElement<int32_t>(14, debug_metadata_index, -1);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGraphBuilder &operator=(const SubGraphBuilder &);
  flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Operator>>> operators = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t debug_metadata_index = -1) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_debug_metadata_index(debug_metadata_index);
  builder_.add_name(name);
  builder_.add_operators(operators);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  return builder_.Finish();
}

flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BufferT : public flatbuffers::NativeTable {
  typedef Buffer TableType;
  std::vector<uint8_t> data;
  uint64_t offset;
  uint64_t size;
  BufferT()
      : offset(0),
        size(0) {
  }
};

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferTypeTable();
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(4);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(6, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(8, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint64_t>(verifier, 6) &&
           VerifyField<uint64_t>(verifier, 8) &&
           verifier.EndTable();
  }
  BufferT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Buffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(4, data);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(6, offset, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(8, size, 0);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferBuilder &operator=(const BufferBuilder &);
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    uint64_t offset = 0,
    uint64_t size = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_data(data);
  return builder_.Finish();
}

flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetadataT : public flatbuffers::NativeTable {
  typedef Metadata TableType;
  std::string name;
  uint32_t buffer;
  MetadataT()
      : buffer(0) {
  }
};

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MetadataTypeTable();
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  uint32_t buffer() const {
    return GetField<uint32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  MetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Metadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(4, name);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(6, buffer, 0);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetadataBuilder &operator=(const MetadataBuilder &);
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t buffer = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_name(name);
  return builder_.Finish();
}

flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorMapT : public flatbuffers::NativeTable {
  typedef TensorMap TableType;
  std::string name;
  uint32_t tensor_index;
  TensorMapT()
      : tensor_index(0) {
  }
};

struct TensorMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorMapT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorMapTypeTable();
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  uint32_t tensor_index() const {
    return GetField<uint32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  TensorMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(4, name);
  }
  void add_tensor_index(uint32_t tensor_index) {
    fbb_.AddElement<uint32_t>(6, tensor_index, 0);
  }
  explicit TensorMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorMapBuilder &operator=(const TensorMapBuilder &);
  flatbuffers::Offset<TensorMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorMap> CreateTensorMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t tensor_index = 0) {
  TensorMapBuilder builder_(_fbb);
  builder_.add_tensor_index(tensor_index);
  builder_.add_name(name);
  return builder_.Finish();
}

flatbuffers::Offset<TensorMap> CreateTensorMap(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignatureDefT : public flatbuffers::NativeTable {
  typedef SignatureDef TableType;
  std::vector<std::unique_ptr<TensorMapT>> inputs;
  std::vector<std::unique_ptr<TensorMapT>> outputs;
  std::string signature_key;
  uint32_t subgraph_index;
  SignatureDefT()
      : subgraph_index(0) {
  }
};

struct SignatureDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignatureDefT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignatureDefTypeTable();
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorMap>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorMap>> *>(4);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorMap>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorMap>> *>(6);
  }
  const flatbuffers::String *signature_key() const {
    return GetPointer<const flatbuffers::String *>(8);
  }
  uint32_t subgraph_index() const {
    return GetField<uint32_t>(12, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyString(signature_key()) &&
           VerifyField<uint32_t>(verifier, 12) &&
           verifier.EndTable();
  }
  SignatureDefT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignatureDefT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SignatureDef> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignatureDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorMap>>> inputs) {
    fbb_.AddOffset(4, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorMap>>> outputs) {
    fbb_.AddOffset(6, outputs);
  }
  void add_signature_key(flatbuffers::Offset<flatbuffers::String> signature_key) {
    fbb_.AddOffset(8, signature_key);
  }
  void add_subgraph_index(uint32_t subgraph_index) {
    fbb_.AddElement<uint32_t>(12, subgraph_index, 0);
  }
  explicit SignatureDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignatureDefBuilder &operator=(const SignatureDefBuilder &);
  flatbuffers::Offset<SignatureDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignatureDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignatureDef> CreateSignatureDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorMap>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorMap>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::String> signature_key = 0,
    uint32_t subgraph_index = 0) {
  SignatureDefBuilder builder_(_fbb);
  builder_.add_subgraph_index(subgraph_index);
  builder_.add_signature_key(signature_key);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

flatbuffers::Offset<SignatureDef> CreateSignatureDef(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelT : public flatbuffers::NativeTable {
  typedef Model TableType;
  uint32_t version;
  std::vector<std::unique_ptr<OperatorCodeT>> operator_codes;
  std::vector<std::unique_ptr<SubGraphT>> subgraphs;
  std::string description;
  std::vector<std::unique_ptr<BufferT>> buffers;
  std::vector<int32_t> metadata_buffer;
  std::vector<std::unique_ptr<MetadataT>> metadata;
  std::vector<std::unique_ptr<SignatureDefT>> signature_defs;
  ModelT()
      : version(0) {
  }
};

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ModelTypeTable();
  }
  uint32_t version() const {
    return GetField<uint32_t>(4, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OperatorCode>> *operator_codes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OperatorCode>> *>(6);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SubGraph>> *subgraphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SubGraph>> *>(8);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(10);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Buffer>> *buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Buffer>> *>(12);
  }
  const flatbuffers::Vector<int32_t> *metadata_buffer() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(14);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Metadata>> *metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Metadata>> *>(16);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SignatureDef>> *signature_defs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SignatureDef>> *>(18);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(operator_codes()) &&
           verifier.VerifyVectorOfTables(operator_codes()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyVector(metadata_buffer()) &&
           VerifyOffset(verifier, 16) &&
           verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyVector(signature_defs()) &&
           verifier.VerifyVectorOfTables(signature_defs()) &&
           verifier.EndTable();
  }
  ModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Model> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(4, version, 0);
  }
  void add_operator_codes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OperatorCode>>> operator_codes) {
    fbb_.AddOffset(6, operator_codes);
  }
  void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraph>>> subgraphs) {
    fbb_.AddOffset(8, subgraphs);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(10, description);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>> buffers) {
    fbb_.AddOffset(12, buffers);
  }
  void add_metadata_buffer(flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer) {
    fbb_.AddOffset(14, metadata_buffer);
  }
  void add_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Metadata>>> metadata) {
    fbb_.AddOffset(16, metadata);
  }
  void add_signature_defs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SignatureDef>>> signature_defs) {
    fbb_.AddOffset(18, signature_defs);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OperatorCode>>> operator_codes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraph>>> subgraphs = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>> buffers = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Metadata>>> metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SignatureDef>>> signature_defs = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_signature_defs(signature_defs);
  builder_.add_metadata(metadata);
  builder_.add_metadata_buffer(metadata_buffer);
  builder_.add_buffers(buffers);
  builder_.add_description(description);
  builder_.add_subgraphs(subgraphs);
  builder_.add_operator_codes(operator_codes);
  builder_.add_version(version);
  return builder_.Finish();
}

flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CustomQuantizationT *CustomQuantization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CustomQuantizationT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CustomQuantization::UnPackTo(CustomQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = custom(); if (_e) { _o->custom.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->custom[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<CustomQuantization> CustomQuantization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomQuantization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomQuantizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _custom = _o->custom.size() ? _fbb.CreateVector(_o->custom) : 0;
  return tflite::CreateCustomQuantization(
      _fbb,
      _custom);
}

inline BlockwiseQuantizationT *BlockwiseQuantization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BlockwiseQuantizationT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BlockwiseQuantization::UnPackTo(BlockwiseQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scales(); _o->scales = _e; };
  { auto _e = zero_points(); _o->zero_points = _e; };
  { auto _e = block_size(); _o->block_size = _e; };
}

inline flatbuffers::Offset<BlockwiseQuantization> BlockwiseQuantization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockwiseQuantizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlockwiseQuantization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlockwiseQuantization> CreateBlockwiseQuantization(flatbuffers::FlatBufferBuilder &_fbb, const BlockwiseQuantizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlockwiseQuantizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scales = _o->scales;
  auto _zero_points = _o->zero_points;
  auto _block_size = _o->block_size;
  return tflite::CreateBlockwiseQuantization(
      _fbb,
      _scales,
      _zero_points,
      _block_size);
}

inline QuantizationParametersT *QuantizationParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QuantizationParametersT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void QuantizationParameters::UnPackTo(QuantizationParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min(); if (_e) { _o->min.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->min[_i] = _e->Get(_i); } } };
  { auto _e = max(); if (_e) { _o->max.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->max[_i] = _e->Get(_i); } } };
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } };
  { auto _e = zero_point(); if (_e) { _o->zero_point.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->zero_point[_i] = _e->Get(_i); } } };
  { auto _e = details_type(); _o->details.type = _e; };
  { auto _e = details(); if (_e) _o->details.value = QuantizationDetailsUnion::UnPack(_e, details_type(), _resolver); };
  { auto _e = quantized_dimension(); _o->quantized_dimension = _e; };
}

inline flatbuffers::Offset<QuantizationParameters> QuantizationParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizationParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizationParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min = _o->min.size() ? _fbb.CreateVector(_o->min) : 0;
  auto _max = _o->max.size() ? _fbb.CreateVector(_o->max) : 0;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  auto _zero_point = _o->zero_point.size() ? _fbb.CreateVector(_o->zero_point) : 0;
  auto _details_type = _o->details.type;
  auto _details = _o->details.Pack(_fbb);
  auto _quantized_dimension = _o->quantized_dimension;
  return tflite::CreateQuantizationParameters(
      _fbb,
      _min,
      _max,
      _scale,
      _zero_point,
      _details_type,
      _details,
      _quantized_dimension);
}

inline Int32VectorT *Int32Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Int32VectorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Int32Vector::UnPackTo(Int32VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Int32Vector> Int32Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt32Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Int32Vector> CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Int32VectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return tflite::CreateInt32Vector(
      _fbb,
      _values);
}

inline Uint16VectorT *Uint16Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Uint16VectorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Uint16Vector::UnPackTo(Uint16VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Uint16Vector> Uint16Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUint16Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Uint16VectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return tflite::CreateUint16Vector(
      _fbb,
      _values);
}

inline Uint8VectorT *Uint8Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Uint8VectorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Uint8Vector::UnPackTo(Uint8VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Uint8Vector> Uint8Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUint8Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Uint8VectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return tflite::CreateUint8Vector(
      _fbb,
      _values);
}

inline DimensionMetadataT *DimensionMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DimensionMetadataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DimensionMetadata::UnPackTo(DimensionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; };
  { auto _e = dense_size(); _o->dense_size = _e; };
  { auto _e = array_segments_type(); _o->array_segments.type = _e; };
  { auto _e = array_segments(); if (_e) _o->array_segments.value = SparseIndexVectorUnion::UnPack(_e, array_segments_type(), _resolver); };
  { auto _e = array_indices_type(); _o->array_indices.type = _e; };
  { auto _e = array_indices(); if (_e) _o->array_indices.value = SparseIndexVectorUnion::UnPack(_e, array_indices_type(), _resolver); };
}

inline flatbuffers::Offset<DimensionMetadata> DimensionMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDimensionMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DimensionMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _dense_size = _o->dense_size;
  auto _array_segments_type = _o->array_segments.type;
  auto _array_segments = _o->array_segments.Pack(_fbb);
  auto _array_indices_type = _o->array_indices.type;
  auto _array_indices = _o->array_indices.Pack(_fbb);
  return tflite::CreateDimensionMetadata(
      _fbb,
      _format,
      _dense_size,
      _array_segments_type,
      _array_segments,
      _array_indices_type,
      _array_indices);
}

inline SparsityParametersT *SparsityParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SparsityParametersT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SparsityParameters::UnPackTo(SparsityParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = traversal_order(); if (_e) { _o->traversal_order.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->traversal_order[_i] = _e->Get(_i); } } };
  { auto _e = block_map(); if (_e) { _o->block_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_map[_i] = _e->Get(_i); } } };
  { auto _e = dim_metadata(); if (_e) { _o->dim_metadata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dim_metadata[_i] = std::unique_ptr<DimensionMetadataT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<SparsityParameters> SparsityParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparsityParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparsityParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _traversal_order = _o->traversal_order.size() ? _fbb.CreateVector(_o->traversal_order) : 0;
  auto _block_map = _o->block_map.size() ? _fbb.CreateVector(_o->block_map) : 0;
  auto _dim_metadata = _o->dim_metadata.size() ? _fbb.CreateVector<flatbuffers::Offset<DimensionMetadata>> (_o->dim_metadata.size(), [](size_t i, _VectorArgs *__va) { return CreateDimensionMetadata(*__va->__fbb, __va->__o->dim_metadata[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::CreateSparsityParameters(
      _fbb,
      _traversal_order,
      _block_map,
      _dim_metadata);
}

inline VariantSubTypeT *VariantSubType::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new VariantSubTypeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void VariantSubType::UnPackTo(VariantSubTypeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } };
  { auto _e = type(); _o->type = _e; };
  { auto _e = has_rank(); _o->has_rank = _e; };
}

inline flatbuffers::Offset<VariantSubType> VariantSubType::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVariantSubType(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VariantSubType> CreateVariantSubType(flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VariantSubTypeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  auto _type = _o->type;
  auto _has_rank = _o->has_rank;
  return tflite::CreateVariantSubType(
      _fbb,
      _shape,
      _type,
      _has_rank);
}

inline TensorT *Tensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Tensor::UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } };
  { auto _e = type(); _o->type = _e; };
  { auto _e = buffer(); _o->buffer = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = quantization(); if (_e) _o->quantization = std::unique_ptr<QuantizationParametersT>(_e->UnPack(_resolver)); };
  { auto _e = is_variable(); _o->is_variable = _e; };
  { auto _e = sparsity(); if (_e) _o->sparsity = std::unique_ptr<SparsityParametersT>(_e->UnPack(_resolver)); };
  { auto _e = shape_signature(); if (_e) { _o->shape_signature.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape_signature[_i] = _e->Get(_i); } } };
  { auto _e = has_rank(); _o->has_rank = _e; };
  { auto _e = variant_tensors(); if (_e) { _o->variant_tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variant_tensors[_i] = std::unique_ptr<VariantSubTypeT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Tensor> Tensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  auto _type = _o->type;
  auto _buffer = _o->buffer;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _quantization = _o->quantization ? CreateQuantizationParameters(_fbb, _o->quantization.get(), _rehasher) : 0;
  auto _is_variable = _o->is_variable;
  auto _sparsity = _o->sparsity ? CreateSparsityParameters(_fbb, _o->sparsity.get(), _rehasher) : 0;
  auto _shape_signature = _o->shape_signature.size() ? _fbb.CreateVector(_o->shape_signature) : 0;
  auto _has_rank = _o->has_rank;
  auto _variant_tensors = _o->variant_tensors.size() ? _fbb.CreateVector<flatbuffers::Offset<VariantSubType>> (_o->variant_tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateVariantSubType(*__va->__fbb, __va->__o->variant_tensors[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::CreateTensor(
      _fbb,
      _shape,
      _type,
      _buffer,
      _name,
      _quantization,
      _is_variable,
      _sparsity,
      _shape_signature,
      _has_rank,
      _variant_tensors);
}

inline StablehloGatherOptionsT *StablehloGatherOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloGatherOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloGatherOptions::UnPackTo(StablehloGatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = offset_dims(); if (_e) { _o->offset_dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->offset_dims[_i] = _e->Get(_i); } } };
  { auto _e = collapsed_slice_dims(); if (_e) { _o->collapsed_slice_dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->collapsed_slice_dims[_i] = _e->Get(_i); } } };
  { auto _e = start_index_map(); if (_e) { _o->start_index_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->start_index_map[_i] = _e->Get(_i); } } };
  { auto _e = index_vector_dim(); _o->index_vector_dim = _e; };
  { auto _e = slice_sizes(); if (_e) { _o->slice_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slice_sizes[_i] = _e->Get(_i); } } };
  { auto _e = indices_are_sorted(); _o->indices_are_sorted = _e; };
}

inline flatbuffers::Offset<StablehloGatherOptions> StablehloGatherOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloGatherOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloGatherOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloGatherOptions> CreateStablehloGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloGatherOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloGatherOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _offset_dims = _o->offset_dims.size() ? _fbb.CreateVector(_o->offset_dims) : 0;
  auto _collapsed_slice_dims = _o->collapsed_slice_dims.size() ? _fbb.CreateVector(_o->collapsed_slice_dims) : 0;
  auto _start_index_map = _o->start_index_map.size() ? _fbb.CreateVector(_o->start_index_map) : 0;
  auto _index_vector_dim = _o->index_vector_dim;
  auto _slice_sizes = _o->slice_sizes.size() ? _fbb.CreateVector(_o->slice_sizes) : 0;
  auto _indices_are_sorted = _o->indices_are_sorted;
  return tflite::CreateStablehloGatherOptions(
      _fbb,
      _offset_dims,
      _collapsed_slice_dims,
      _start_index_map,
      _index_vector_dim,
      _slice_sizes,
      _indices_are_sorted);
}

inline StablehloTransposeOptionsT *StablehloTransposeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloTransposeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloTransposeOptions::UnPackTo(StablehloTransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = permutation(); if (_e) { _o->permutation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->permutation[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<StablehloTransposeOptions> StablehloTransposeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloTransposeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloTransposeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloTransposeOptions> CreateStablehloTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloTransposeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloTransposeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _permutation = _o->permutation.size() ? _fbb.CreateVector(_o->permutation) : 0;
  return tflite::CreateStablehloTransposeOptions(
      _fbb,
      _permutation);
}

inline StablehloDotGeneralOptionsT *StablehloDotGeneralOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloDotGeneralOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloDotGeneralOptions::UnPackTo(StablehloDotGeneralOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lhs_batching_dimensions(); if (_e) { _o->lhs_batching_dimensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lhs_batching_dimensions[_i] = _e->Get(_i); } } };
  { auto _e = rhs_batching_dimensions(); if (_e) { _o->rhs_batching_dimensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rhs_batching_dimensions[_i] = _e->Get(_i); } } };
  { auto _e = lhs_contracting_dimensions(); if (_e) { _o->lhs_contracting_dimensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lhs_contracting_dimensions[_i] = _e->Get(_i); } } };
  { auto _e = rhs_contracting_dimensions(); if (_e) { _o->rhs_contracting_dimensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rhs_contracting_dimensions[_i] = _e->Get(_i); } } };
  { auto _e = precision_config(); if (_e) { _o->precision_config.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->precision_config[_i] = static_cast<StablehloPrecisionConfig>(_e->Get(_i)); } } };
}

inline flatbuffers::Offset<StablehloDotGeneralOptions> StablehloDotGeneralOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloDotGeneralOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloDotGeneralOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloDotGeneralOptions> CreateStablehloDotGeneralOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloDotGeneralOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloDotGeneralOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lhs_batching_dimensions = _o->lhs_batching_dimensions.size() ? _fbb.CreateVector(_o->lhs_batching_dimensions) : 0;
  auto _rhs_batching_dimensions = _o->rhs_batching_dimensions.size() ? _fbb.CreateVector(_o->rhs_batching_dimensions) : 0;
  auto _lhs_contracting_dimensions = _o->lhs_contracting_dimensions.size() ? _fbb.CreateVector(_o->lhs_contracting_dimensions) : 0;
  auto _rhs_contracting_dimensions = _o->rhs_contracting_dimensions.size() ? _fbb.CreateVector(_o->rhs_contracting_dimensions) : 0;
  auto _precision_config = _o->precision_config.size() ? _fbb.CreateVectorScalarCast<uint32_t>(flatbuffers::data(_o->precision_config), _o->precision_config.size()) : 0;
  return tflite::CreateStablehloDotGeneralOptions(
      _fbb,
      _lhs_batching_dimensions,
      _rhs_batching_dimensions,
      _lhs_contracting_dimensions,
      _rhs_contracting_dimensions,
      _precision_config);
}

inline StablehloReduceWindowOptionsT *StablehloReduceWindowOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloReduceWindowOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloReduceWindowOptions::UnPackTo(StablehloReduceWindowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = window_dimensions(); if (_e) { _o->window_dimensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->window_dimensions[_i] = _e->Get(_i); } } };
  { auto _e = window_strides(); if (_e) { _o->window_strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->window_strides[_i] = _e->Get(_i); } } };
  { auto _e = base_dilations(); if (_e) { _o->base_dilations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->base_dilations[_i] = _e->Get(_i); } } };
  { auto _e = window_dilations(); if (_e) { _o->window_dilations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->window_dilations[_i] = _e->Get(_i); } } };
  { auto _e = padding(); if (_e) { _o->padding.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->padding[_i] = _e->Get(_i); } } };
  { auto _e = body_subgraph_index(); _o->body_subgraph_index = _e; };
}

inline flatbuffers::Offset<StablehloReduceWindowOptions> StablehloReduceWindowOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceWindowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloReduceWindowOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloReduceWindowOptions> CreateStablehloReduceWindowOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceWindowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloReduceWindowOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _window_dimensions = _o->window_dimensions.size() ? _fbb.CreateVector(_o->window_dimensions) : 0;
  auto _window_strides = _o->window_strides.size() ? _fbb.CreateVector(_o->window_strides) : 0;
  auto _base_dilations = _o->base_dilations.size() ? _fbb.CreateVector(_o->base_dilations) : 0;
  auto _window_dilations = _o->window_dilations.size() ? _fbb.CreateVector(_o->window_dilations) : 0;
  auto _padding = _o->padding.size() ? _fbb.CreateVector(_o->padding) : 0;
  auto _body_subgraph_index = _o->body_subgraph_index;
  return tflite::CreateStablehloReduceWindowOptions(
      _fbb,
      _window_dimensions,
      _window_strides,
      _base_dilations,
      _window_dilations,
      _padding,
      _body_subgraph_index);
}

inline StablehloWhileOptionsT *StablehloWhileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloWhileOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloWhileOptions::UnPackTo(StablehloWhileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cond_subgraph_index(); _o->cond_subgraph_index = _e; };
  { auto _e = body_subgraph_index(); _o->body_subgraph_index = _e; };
}

inline flatbuffers::Offset<StablehloWhileOptions> StablehloWhileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloWhileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloWhileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloWhileOptions> CreateStablehloWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloWhileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloWhileOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cond_subgraph_index = _o->cond_subgraph_index;
  auto _body_subgraph_index = _o->body_subgraph_index;
  return tflite::CreateStablehloWhileOptions(
      _fbb,
      _cond_subgraph_index,
      _body_subgraph_index);
}

inline StablehloSortOptionsT *StablehloSortOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloSortOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloSortOptions::UnPackTo(StablehloSortOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dimension(); _o->dimension = _e; };
  { auto _e = is_stable(); _o->is_stable = _e; };
  { auto _e = comparator_subgraph_index(); _o->comparator_subgraph_index = _e; };
}

inline flatbuffers::Offset<StablehloSortOptions> StablehloSortOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloSortOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloSortOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloSortOptions> CreateStablehloSortOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloSortOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloSortOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dimension = _o->dimension;
  auto _is_stable = _o->is_stable;
  auto _comparator_subgraph_index = _o->comparator_subgraph_index;
  return tflite::CreateStablehloSortOptions(
      _fbb,
      _dimension,
      _is_stable,
      _comparator_subgraph_index);
}

inline StablehloConcatenateOptionsT *StablehloConcatenateOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloConcatenateOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloConcatenateOptions::UnPackTo(StablehloConcatenateOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dimension(); _o->dimension = _e; };
}

inline flatbuffers::Offset<StablehloConcatenateOptions> StablehloConcatenateOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloConcatenateOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloConcatenateOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloConcatenateOptions> CreateStablehloConcatenateOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloConcatenateOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloConcatenateOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dimension = _o->dimension;
  return tflite::CreateStablehloConcatenateOptions(
      _fbb,
      _dimension);
}

inline StablehloBroadcastInDimOptionsT *StablehloBroadcastInDimOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloBroadcastInDimOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloBroadcastInDimOptions::UnPackTo(StablehloBroadcastInDimOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = broadcast_dimensions(); if (_e) { _o->broadcast_dimensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->broadcast_dimensions[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<StablehloBroadcastInDimOptions> StablehloBroadcastInDimOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloBroadcastInDimOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloBroadcastInDimOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloBroadcastInDimOptions> CreateStablehloBroadcastInDimOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloBroadcastInDimOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloBroadcastInDimOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _broadcast_dimensions = _o->broadcast_dimensions.size() ? _fbb.CreateVector(_o->broadcast_dimensions) : 0;
  return tflite::CreateStablehloBroadcastInDimOptions(
      _fbb,
      _broadcast_dimensions);
}

inline StablehloCompareOptionsT *StablehloCompareOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloCompareOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloCompareOptions::UnPackTo(StablehloCompareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = comparison_direction(); _o->comparison_direction = _e; };
  { auto _e = compare_type(); _o->compare_type = _e; };
}

inline flatbuffers::Offset<StablehloCompareOptions> StablehloCompareOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCompareOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloCompareOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloCompareOptions> CreateStablehloCompareOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCompareOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloCompareOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _comparison_direction = _o->comparison_direction;
  auto _compare_type = _o->compare_type;
  return tflite::CreateStablehloCompareOptions(
      _fbb,
      _comparison_direction,
      _compare_type);
}

inline StablehloDynamicSliceOptionsT *StablehloDynamicSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloDynamicSliceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloDynamicSliceOptions::UnPackTo(StablehloDynamicSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slice_sizes(); if (_e) { _o->slice_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slice_sizes[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<StablehloDynamicSliceOptions> StablehloDynamicSliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloDynamicSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloDynamicSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloDynamicSliceOptions> CreateStablehloDynamicSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloDynamicSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloDynamicSliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slice_sizes = _o->slice_sizes.size() ? _fbb.CreateVector(_o->slice_sizes) : 0;
  return tflite::CreateStablehloDynamicSliceOptions(
      _fbb,
      _slice_sizes);
}

inline StablehloPadOptionsT *StablehloPadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloPadOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloPadOptions::UnPackTo(StablehloPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = edge_padding_low(); if (_e) { _o->edge_padding_low.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->edge_padding_low[_i] = _e->Get(_i); } } };
  { auto _e = edge_padding_high(); if (_e) { _o->edge_padding_high.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->edge_padding_high[_i] = _e->Get(_i); } } };
  { auto _e = interior_padding(); if (_e) { _o->interior_padding.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->interior_padding[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<StablehloPadOptions> StablehloPadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloPadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloPadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloPadOptions> CreateStablehloPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloPadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloPadOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _edge_padding_low = _o->edge_padding_low.size() ? _fbb.CreateVector(_o->edge_padding_low) : 0;
  auto _edge_padding_high = _o->edge_padding_high.size() ? _fbb.CreateVector(_o->edge_padding_high) : 0;
  auto _interior_padding = _o->interior_padding.size() ? _fbb.CreateVector(_o->interior_padding) : 0;
  return tflite::CreateStablehloPadOptions(
      _fbb,
      _edge_padding_low,
      _edge_padding_high,
      _interior_padding);
}

inline StablehloIotaOptionsT *StablehloIotaOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloIotaOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloIotaOptions::UnPackTo(StablehloIotaOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = iota_dimension(); _o->iota_dimension = _e; };
}

inline flatbuffers::Offset<StablehloIotaOptions> StablehloIotaOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloIotaOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloIotaOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloIotaOptions> CreateStablehloIotaOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloIotaOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloIotaOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _iota_dimension = _o->iota_dimension;
  return tflite::CreateStablehloIotaOptions(
      _fbb,
      _iota_dimension);
}

inline StablehloCustomCallOptionsT *StablehloCustomCallOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloCustomCallOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloCustomCallOptions::UnPackTo(StablehloCustomCallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = call_target_name(); if (_e) _o->call_target_name = _e->str(); };
  { auto _e = has_side_effect(); _o->has_side_effect = _e; };
  { auto _e = backend_config(); if (_e) _o->backend_config = _e->str(); };
  { auto _e = api_version(); _o->api_version = _e; };
  { auto _e = called_computations(); if (_e) { _o->called_computations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->called_computations[_i] = _e->Get(_i); } } };
  { auto _e = custom_attributes(); if (_e) { _o->custom_attributes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->custom_attributes[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<StablehloCustomCallOptions> StablehloCustomCallOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCustomCallOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloCustomCallOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloCustomCallOptions> CreateStablehloCustomCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCustomCallOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloCustomCallOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _call_target_name = _o->call_target_name.empty() ? 0 : _fbb.CreateString(_o->call_target_name);
  auto _has_side_effect = _o->has_side_effect;
  auto _backend_config = _o->backend_config.empty() ? 0 : _fbb.CreateString(_o->backend_config);
  auto _api_version = _o->api_version;
  auto _called_computations = _o->called_computations.size() ? _fbb.CreateVector(_o->called_computations) : 0;
  auto _custom_attributes = _o->custom_attributes.size() ? _fbb.CreateVector(_o->custom_attributes) : 0;
  return tflite::CreateStablehloCustomCallOptions(
      _fbb,
      _call_target_name,
      _has_side_effect,
      _backend_config,
      _api_version,
      _called_computations,
      _custom_attributes);
}

inline StablehloReduceOptionsT *StablehloReduceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloReduceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloReduceOptions::UnPackTo(StablehloReduceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dimensions(); if (_e) { _o->dimensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dimensions[_i] = _e->Get(_i); } } };
  { auto _e = body_subgraph_index(); _o->body_subgraph_index = _e; };
}

inline flatbuffers::Offset<StablehloReduceOptions> StablehloReduceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloReduceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloReduceOptions> CreateStablehloReduceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloReduceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dimensions = _o->dimensions.size() ? _fbb.CreateVector(_o->dimensions) : 0;
  auto _body_subgraph_index = _o->body_subgraph_index;
  return tflite::CreateStablehloReduceOptions(
      _fbb,
      _dimensions,
      _body_subgraph_index);
}

inline StablehloSliceOptionsT *StablehloSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloSliceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloSliceOptions::UnPackTo(StablehloSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start_indices(); if (_e) { _o->start_indices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->start_indices[_i] = _e->Get(_i); } } };
  { auto _e = limit_indices(); if (_e) { _o->limit_indices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->limit_indices[_i] = _e->Get(_i); } } };
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<StablehloSliceOptions> StablehloSliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloSliceOptions> CreateStablehloSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloSliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start_indices = _o->start_indices.size() ? _fbb.CreateVector(_o->start_indices) : 0;
  auto _limit_indices = _o->limit_indices.size() ? _fbb.CreateVector(_o->limit_indices) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  return tflite::CreateStablehloSliceOptions(
      _fbb,
      _start_indices,
      _limit_indices,
      _strides);
}

inline StablehloConvolutionOptionsT *StablehloConvolutionOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloConvolutionOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloConvolutionOptions::UnPackTo(StablehloConvolutionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = window_strides(); if (_e) { _o->window_strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->window_strides[_i] = _e->Get(_i); } } };
  { auto _e = padding(); if (_e) { _o->padding.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->padding[_i] = _e->Get(_i); } } };
  { auto _e = lhs_dilation(); if (_e) { _o->lhs_dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lhs_dilation[_i] = _e->Get(_i); } } };
  { auto _e = rhs_dilation(); if (_e) { _o->rhs_dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rhs_dilation[_i] = _e->Get(_i); } } };
  { auto _e = window_reversal(); if (_e) { _o->window_reversal.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->window_reversal[_i] = _e->Get(_i) != 0; } } };
  { auto _e = input_batch_dimension(); _o->input_batch_dimension = _e; };
  { auto _e = input_feature_dimension(); _o->input_feature_dimension = _e; };
  { auto _e = input_spatial_dimensions(); if (_e) { _o->input_spatial_dimensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_spatial_dimensions[_i] = _e->Get(_i); } } };
  { auto _e = kernel_input_feature_dimension(); _o->kernel_input_feature_dimension = _e; };
  { auto _e = kernel_output_feature_dimension(); _o->kernel_output_feature_dimension = _e; };
  { auto _e = kernel_spatial_dimensions(); if (_e) { _o->kernel_spatial_dimensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_spatial_dimensions[_i] = _e->Get(_i); } } };
  { auto _e = output_batch_dimension(); _o->output_batch_dimension = _e; };
  { auto _e = output_feature_dimension(); _o->output_feature_dimension = _e; };
  { auto _e = output_spatial_dimensions(); if (_e) { _o->output_spatial_dimensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_spatial_dimensions[_i] = _e->Get(_i); } } };
  { auto _e = feature_group_count(); _o->feature_group_count = _e; };
  { auto _e = batch_group_count(); _o->batch_group_count = _e; };
  { auto _e = precision_config(); if (_e) { _o->precision_config.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->precision_config[_i] = static_cast<StablehloPrecisionConfig>(_e->Get(_i)); } } };
}

inline flatbuffers::Offset<StablehloConvolutionOptions> StablehloConvolutionOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloConvolutionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloConvolutionOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloConvolutionOptions> CreateStablehloConvolutionOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloConvolutionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloConvolutionOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _window_strides = _o->window_strides.size() ? _fbb.CreateVector(_o->window_strides) : 0;
  auto _padding = _o->padding.size() ? _fbb.CreateVector(_o->padding) : 0;
  auto _lhs_dilation = _o->lhs_dilation.size() ? _fbb.CreateVector(_o->lhs_dilation) : 0;
  auto _rhs_dilation = _o->rhs_dilation.size() ? _fbb.CreateVector(_o->rhs_dilation) : 0;
  auto _window_reversal = _o->window_reversal.size() ? _fbb.CreateVector(_o->window_reversal) : 0;
  auto _input_batch_dimension = _o->input_batch_dimension;
  auto _input_feature_dimension = _o->input_feature_dimension;
  auto _input_spatial_dimensions = _o->input_spatial_dimensions.size() ? _fbb.CreateVector(_o->input_spatial_dimensions) : 0;
  auto _kernel_input_feature_dimension = _o->kernel_input_feature_dimension;
  auto _kernel_output_feature_dimension = _o->kernel_output_feature_dimension;
  auto _kernel_spatial_dimensions = _o->kernel_spatial_dimensions.size() ? _fbb.CreateVector(_o->kernel_spatial_dimensions) : 0;
  auto _output_batch_dimension = _o->output_batch_dimension;
  auto _output_feature_dimension = _o->output_feature_dimension;
  auto _output_spatial_dimensions = _o->output_spatial_dimensions.size() ? _fbb.CreateVector(_o->output_spatial_dimensions) : 0;
  auto _feature_group_count = _o->feature_group_count;
  auto _batch_group_count = _o->batch_group_count;
  auto _precision_config = _o->precision_config.size() ? _fbb.CreateVectorScalarCast<uint32_t>(flatbuffers::data(_o->precision_config), _o->precision_config.size()) : 0;
  return tflite::CreateStablehloConvolutionOptions(
      _fbb,
      _window_strides,
      _padding,
      _lhs_dilation,
      _rhs_dilation,
      _window_reversal,
      _input_batch_dimension,
      _input_feature_dimension,
      _input_spatial_dimensions,
      _kernel_input_feature_dimension,
      _kernel_output_feature_dimension,
      _kernel_spatial_dimensions,
      _output_batch_dimension,
      _output_feature_dimension,
      _output_spatial_dimensions,
      _feature_group_count,
      _batch_group_count,
      _precision_config);
}

inline StablehloScatterOptionsT *StablehloScatterOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloScatterOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloScatterOptions::UnPackTo(StablehloScatterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = indices_are_sorted(); _o->indices_are_sorted = _e; };
  { auto _e = update_window_dims(); if (_e) { _o->update_window_dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->update_window_dims[_i] = _e->Get(_i); } } };
  { auto _e = inserted_window_dims(); if (_e) { _o->inserted_window_dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inserted_window_dims[_i] = _e->Get(_i); } } };
  { auto _e = scatter_dims_to_operand_dims(); if (_e) { _o->scatter_dims_to_operand_dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scatter_dims_to_operand_dims[_i] = _e->Get(_i); } } };
  { auto _e = index_vector_dim(); _o->index_vector_dim = _e; };
  { auto _e = unique_indices(); _o->unique_indices = _e; };
  { auto _e = update_computation_subgraph_index(); _o->update_computation_subgraph_index = _e; };
}

inline flatbuffers::Offset<StablehloScatterOptions> StablehloScatterOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloScatterOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloScatterOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloScatterOptions> CreateStablehloScatterOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloScatterOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloScatterOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _indices_are_sorted = _o->indices_are_sorted;
  auto _update_window_dims = _o->update_window_dims.size() ? _fbb.CreateVector(_o->update_window_dims) : 0;
  auto _inserted_window_dims = _o->inserted_window_dims.size() ? _fbb.CreateVector(_o->inserted_window_dims) : 0;
  auto _scatter_dims_to_operand_dims = _o->scatter_dims_to_operand_dims.size() ? _fbb.CreateVector(_o->scatter_dims_to_operand_dims) : 0;
  auto _index_vector_dim = _o->index_vector_dim;
  auto _unique_indices = _o->unique_indices;
  auto _update_computation_subgraph_index = _o->update_computation_subgraph_index;
  return tflite::CreateStablehloScatterOptions(
      _fbb,
      _indices_are_sorted,
      _update_window_dims,
      _inserted_window_dims,
      _scatter_dims_to_operand_dims,
      _index_vector_dim,
      _unique_indices,
      _update_computation_subgraph_index);
}

inline StablehloCaseOptionsT *StablehloCaseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloCaseOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloCaseOptions::UnPackTo(StablehloCaseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = branch_subgraph_indices(); if (_e) { _o->branch_subgraph_indices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->branch_subgraph_indices[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<StablehloCaseOptions> StablehloCaseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCaseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloCaseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloCaseOptions> CreateStablehloCaseOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloCaseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloCaseOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _branch_subgraph_indices = _o->branch_subgraph_indices.size() ? _fbb.CreateVector(_o->branch_subgraph_indices) : 0;
  return tflite::CreateStablehloCaseOptions(
      _fbb,
      _branch_subgraph_indices);
}

inline StablehloRngBitGeneratorOptionsT *StablehloRngBitGeneratorOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloRngBitGeneratorOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloRngBitGeneratorOptions::UnPackTo(StablehloRngBitGeneratorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = algorithm(); _o->algorithm = _e; };
}

inline flatbuffers::Offset<StablehloRngBitGeneratorOptions> StablehloRngBitGeneratorOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloRngBitGeneratorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloRngBitGeneratorOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloRngBitGeneratorOptions> CreateStablehloRngBitGeneratorOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloRngBitGeneratorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloRngBitGeneratorOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _algorithm = _o->algorithm;
  return tflite::CreateStablehloRngBitGeneratorOptions(
      _fbb,
      _algorithm);
}

inline Conv2DOptionsT *Conv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Conv2DOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Conv2DOptions::UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; };
  { auto _e = stride_w(); _o->stride_w = _e; };
  { auto _e = stride_h(); _o->stride_h = _e; };
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; };
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; };
  { auto _e = quantized_bias_type(); _o->quantized_bias_type = _e; };
}

inline flatbuffers::Offset<Conv2DOptions> Conv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  auto _quantized_bias_type = _o->quantized_bias_type;
  return tflite::CreateConv2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _fused_activation_function,
      _dilation_w_factor,
      _dilation_h_factor,
      _quantized_bias_type);
}

inline Conv3DOptionsT *Conv3DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Conv3DOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Conv3DOptions::UnPackTo(Conv3DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; };
  { auto _e = stride_d(); _o->stride_d = _e; };
  { auto _e = stride_w(); _o->stride_w = _e; };
  { auto _e = stride_h(); _o->stride_h = _e; };
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = dilation_d_factor(); _o->dilation_d_factor = _e; };
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; };
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; };
}

inline flatbuffers::Offset<Conv3DOptions> Conv3DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv3DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv3DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_d = _o->stride_d;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_d_factor = _o->dilation_d_factor;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return tflite::CreateConv3DOptions(
      _fbb,
      _padding,
      _stride_d,
      _stride_w,
      _stride_h,
      _fused_activation_function,
      _dilation_d_factor,
      _dilation_w_factor,
      _dilation_h_factor);
}

inline Pool2DOptionsT *Pool2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Pool2DOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Pool2DOptions::UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; };
  { auto _e = stride_w(); _o->stride_w = _e; };
  { auto _e = stride_h(); _o->stride_h = _e; };
  { auto _e = filter_width(); _o->filter_width = _e; };
  { auto _e = filter_height(); _o->filter_height = _e; };
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
}

inline flatbuffers::Offset<Pool2DOptions> Pool2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _filter_width = _o->filter_width;
  auto _filter_height = _o->filter_height;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreatePool2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _filter_width,
      _filter_height,
      _fused_activation_function);
}

inline DepthwiseConv2DOptionsT *DepthwiseConv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DepthwiseConv2DOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DepthwiseConv2DOptions::UnPackTo(DepthwiseConv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; };
  { auto _e = stride_w(); _o->stride_w = _e; };
  { auto _e = stride_h(); _o->stride_h = _e; };
  { auto _e = depth_multiplier(); _o->depth_multiplier = _e; };
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; };
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; };
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> DepthwiseConv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthwiseConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthwiseConv2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _depth_multiplier = _o->depth_multiplier;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return tflite::CreateDepthwiseConv2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _depth_multiplier,
      _fused_activation_function,
      _dilation_w_factor,
      _dilation_h_factor);
}

inline ConcatEmbeddingsOptionsT *ConcatEmbeddingsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ConcatEmbeddingsOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ConcatEmbeddingsOptions::UnPackTo(ConcatEmbeddingsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_channels(); _o->num_channels = _e; };
  { auto _e = num_columns_per_channel(); if (_e) { _o->num_columns_per_channel.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->num_columns_per_channel[_i] = _e->Get(_i); } } };
  { auto _e = embedding_dim_per_channel(); if (_e) { _o->embedding_dim_per_channel.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->embedding_dim_per_channel[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> ConcatEmbeddingsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConcatEmbeddingsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatEmbeddingsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_channels = _o->num_channels;
  auto _num_columns_per_channel = _o->num_columns_per_channel.size() ? _fbb.CreateVector(_o->num_columns_per_channel) : 0;
  auto _embedding_dim_per_channel = _o->embedding_dim_per_channel.size() ? _fbb.CreateVector(_o->embedding_dim_per_channel) : 0;
  return tflite::CreateConcatEmbeddingsOptions(
      _fbb,
      _num_channels,
      _num_columns_per_channel,
      _embedding_dim_per_channel);
}

inline LSHProjectionOptionsT *LSHProjectionOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LSHProjectionOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LSHProjectionOptions::UnPackTo(LSHProjectionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
}

inline flatbuffers::Offset<LSHProjectionOptions> LSHProjectionOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSHProjectionOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSHProjectionOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  return tflite::CreateLSHProjectionOptions(
      _fbb,
      _type);
}

inline SVDFOptionsT *SVDFOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SVDFOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SVDFOptions::UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rank(); _o->rank = _e; };
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; };
}

inline flatbuffers::Offset<SVDFOptions> SVDFOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSVDFOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SVDFOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rank = _o->rank;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateSVDFOptions(
      _fbb,
      _rank,
      _fused_activation_function,
      _asymmetric_quantize_inputs);
}

inline RNNOptionsT *RNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RNNOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RNNOptions::UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; };
}

inline flatbuffers::Offset<RNNOptions> RNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateRNNOptions(
      _fbb,
      _fused_activation_function,
      _asymmetric_quantize_inputs);
}

inline SequenceRNNOptionsT *SequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SequenceRNNOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SequenceRNNOptions::UnPackTo(SequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time_major(); _o->time_major = _e; };
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; };
}

inline flatbuffers::Offset<SequenceRNNOptions> SequenceRNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SequenceRNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time_major = _o->time_major;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateSequenceRNNOptions(
      _fbb,
      _time_major,
      _fused_activation_function,
      _asymmetric_quantize_inputs);
}

inline BidirectionalSequenceRNNOptionsT *BidirectionalSequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BidirectionalSequenceRNNOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BidirectionalSequenceRNNOptions::UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time_major(); _o->time_major = _e; };
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = merge_outputs(); _o->merge_outputs = _e; };
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; };
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> BidirectionalSequenceRNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBidirectionalSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceRNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time_major = _o->time_major;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _merge_outputs = _o->merge_outputs;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateBidirectionalSequenceRNNOptions(
      _fbb,
      _time_major,
      _fused_activation_function,
      _merge_outputs,
      _asymmetric_quantize_inputs);
}

inline FullyConnectedOptionsT *FullyConnectedOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FullyConnectedOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FullyConnectedOptions::UnPackTo(FullyConnectedOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = weights_format(); _o->weights_format = _e; };
  { auto _e = keep_num_dims(); _o->keep_num_dims = _e; };
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; };
  { auto _e = quantized_bias_type(); _o->quantized_bias_type = _e; };
}

inline flatbuffers::Offset<FullyConnectedOptions> FullyConnectedOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFullyConnectedOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FullyConnectedOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _weights_format = _o->weights_format;
  auto _keep_num_dims = _o->keep_num_dims;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  auto _quantized_bias_type = _o->quantized_bias_type;
  return tflite::CreateFullyConnectedOptions(
      _fbb,
      _fused_activation_function,
      _weights_format,
      _keep_num_dims,
      _asymmetric_quantize_inputs,
      _quantized_bias_type);
}

inline SoftmaxOptionsT *SoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SoftmaxOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SoftmaxOptions::UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beta(); _o->beta = _e; };
}

inline flatbuffers::Offset<SoftmaxOptions> SoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beta = _o->beta;
  return tflite::CreateSoftmaxOptions(
      _fbb,
      _beta);
}

inline ConcatenationOptionsT *ConcatenationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ConcatenationOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ConcatenationOptions::UnPackTo(ConcatenationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
}

inline flatbuffers::Offset<ConcatenationOptions> ConcatenationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConcatenationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatenationOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateConcatenationOptions(
      _fbb,
      _axis,
      _fused_activation_function);
}

inline AddOptionsT *AddOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AddOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AddOptions::UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = pot_scale_int16(); _o->pot_scale_int16 = _e; };
}

inline flatbuffers::Offset<AddOptions> AddOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _pot_scale_int16 = _o->pot_scale_int16;
  return tflite::CreateAddOptions(
      _fbb,
      _fused_activation_function,
      _pot_scale_int16);
}

inline MulOptionsT *MulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MulOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MulOptions::UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
}

inline flatbuffers::Offset<MulOptions> MulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMulOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateMulOptions(
      _fbb,
      _fused_activation_function);
}

inline L2NormOptionsT *L2NormOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new L2NormOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void L2NormOptions::UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
}

inline flatbuffers::Offset<L2NormOptions> L2NormOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateL2NormOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const L2NormOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateL2NormOptions(
      _fbb,
      _fused_activation_function);
}

inline LocalResponseNormalizationOptionsT *LocalResponseNormalizationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LocalResponseNormalizationOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LocalResponseNormalizationOptions::UnPackTo(LocalResponseNormalizationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = radius(); _o->radius = _e; };
  { auto _e = bias(); _o->bias = _e; };
  { auto _e = alpha(); _o->alpha = _e; };
  { auto _e = beta(); _o->beta = _e; };
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions> LocalResponseNormalizationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLocalResponseNormalizationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LocalResponseNormalizationOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _radius = _o->radius;
  auto _bias = _o->bias;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  return tflite::CreateLocalResponseNormalizationOptions(
      _fbb,
      _radius,
      _bias,
      _alpha,
      _beta);
}

inline LSTMOptionsT *LSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LSTMOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LSTMOptions::UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = cell_clip(); _o->cell_clip = _e; };
  { auto _e = proj_clip(); _o->proj_clip = _e; };
  { auto _e = kernel_type(); _o->kernel_type = _e; };
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; };
}

inline flatbuffers::Offset<LSTMOptions> LSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _kernel_type = _o->kernel_type;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _kernel_type,
      _asymmetric_quantize_inputs);
}

inline UnidirectionalSequenceLSTMOptionsT *UnidirectionalSequenceLSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnidirectionalSequenceLSTMOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnidirectionalSequenceLSTMOptions::UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = cell_clip(); _o->cell_clip = _e; };
  { auto _e = proj_clip(); _o->proj_clip = _e; };
  { auto _e = time_major(); _o->time_major = _e; };
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; };
  { auto _e = diagonal_recurrent_tensors(); _o->diagonal_recurrent_tensors = _e; };
}

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> UnidirectionalSequenceLSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnidirectionalSequenceLSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _time_major = _o->time_major;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  auto _diagonal_recurrent_tensors = _o->diagonal_recurrent_tensors;
  return tflite::CreateUnidirectionalSequenceLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _time_major,
      _asymmetric_quantize_inputs,
      _diagonal_recurrent_tensors);
}

inline BidirectionalSequenceLSTMOptionsT *BidirectionalSequenceLSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BidirectionalSequenceLSTMOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BidirectionalSequenceLSTMOptions::UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = cell_clip(); _o->cell_clip = _e; };
  { auto _e = proj_clip(); _o->proj_clip = _e; };
  { auto _e = merge_outputs(); _o->merge_outputs = _e; };
  { auto _e = time_major(); _o->time_major = _e; };
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; };
}

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> BidirectionalSequenceLSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceLSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _merge_outputs = _o->merge_outputs;
  auto _time_major = _o->time_major;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateBidirectionalSequenceLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _merge_outputs,
      _time_major,
      _asymmetric_quantize_inputs);
}

inline ResizeBilinearOptionsT *ResizeBilinearOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResizeBilinearOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ResizeBilinearOptions::UnPackTo(ResizeBilinearOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = align_corners(); _o->align_corners = _e; };
  { auto _e = half_pixel_centers(); _o->half_pixel_centers = _e; };
}

inline flatbuffers::Offset<ResizeBilinearOptions> ResizeBilinearOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeBilinearOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeBilinearOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _align_corners = _o->align_corners;
  auto _half_pixel_centers = _o->half_pixel_centers;
  return tflite::CreateResizeBilinearOptions(
      _fbb,
      _align_corners,
      _half_pixel_centers);
}

inline ResizeNearestNeighborOptionsT *ResizeNearestNeighborOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResizeNearestNeighborOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ResizeNearestNeighborOptions::UnPackTo(ResizeNearestNeighborOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = align_corners(); _o->align_corners = _e; };
  { auto _e = half_pixel_centers(); _o->half_pixel_centers = _e; };
}

inline flatbuffers::Offset<ResizeNearestNeighborOptions> ResizeNearestNeighborOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeNearestNeighborOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeNearestNeighborOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _align_corners = _o->align_corners;
  auto _half_pixel_centers = _o->half_pixel_centers;
  return tflite::CreateResizeNearestNeighborOptions(
      _fbb,
      _align_corners,
      _half_pixel_centers);
}

inline CallOptionsT *CallOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CallOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CallOptions::UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = subgraph(); _o->subgraph = _e; };
}

inline flatbuffers::Offset<CallOptions> CallOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _subgraph = _o->subgraph;
  return tflite::CreateCallOptions(
      _fbb,
      _subgraph);
}

inline PadOptionsT *PadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PadOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PadOptions::UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PadOptions> PadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePadOptions(
      _fbb);
}

inline PadV2OptionsT *PadV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PadV2OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PadV2Options::UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PadV2Options> PadV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePadV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePadV2Options(
      _fbb);
}

inline ReshapeOptionsT *ReshapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReshapeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReshapeOptions::UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = new_shape(); if (_e) { _o->new_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->new_shape[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<ReshapeOptions> ReshapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _new_shape = _o->new_shape.size() ? _fbb.CreateVector(_o->new_shape) : 0;
  return tflite::CreateReshapeOptions(
      _fbb,
      _new_shape);
}

inline SpaceToBatchNDOptionsT *SpaceToBatchNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SpaceToBatchNDOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SpaceToBatchNDOptions::UnPackTo(SpaceToBatchNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SpaceToBatchNDOptions> SpaceToBatchNDOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToBatchNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchNDOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSpaceToBatchNDOptions(
      _fbb);
}

inline BatchToSpaceNDOptionsT *BatchToSpaceNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BatchToSpaceNDOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BatchToSpaceNDOptions::UnPackTo(BatchToSpaceNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BatchToSpaceNDOptions> BatchToSpaceNDOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchToSpaceNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceNDOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBatchToSpaceNDOptions(
      _fbb);
}

inline SkipGramOptionsT *SkipGramOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SkipGramOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SkipGramOptions::UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ngram_size(); _o->ngram_size = _e; };
  { auto _e = max_skip_size(); _o->max_skip_size = _e; };
  { auto _e = include_all_ngrams(); _o->include_all_ngrams = _e; };
}

inline flatbuffers::Offset<SkipGramOptions> SkipGramOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkipGramOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SkipGramOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ngram_size = _o->ngram_size;
  auto _max_skip_size = _o->max_skip_size;
  auto _include_all_ngrams = _o->include_all_ngrams;
  return tflite::CreateSkipGramOptions(
      _fbb,
      _ngram_size,
      _max_skip_size,
      _include_all_ngrams);
}

inline SpaceToDepthOptionsT *SpaceToDepthOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SpaceToDepthOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SpaceToDepthOptions::UnPackTo(SpaceToDepthOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); _o->block_size = _e; };
}

inline flatbuffers::Offset<SpaceToDepthOptions> SpaceToDepthOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToDepthOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToDepthOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size;
  return tflite::CreateSpaceToDepthOptions(
      _fbb,
      _block_size);
}

inline DepthToSpaceOptionsT *DepthToSpaceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DepthToSpaceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DepthToSpaceOptions::UnPackTo(DepthToSpaceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); _o->block_size = _e; };
}

inline flatbuffers::Offset<DepthToSpaceOptions> DepthToSpaceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthToSpaceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthToSpaceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size;
  return tflite::CreateDepthToSpaceOptions(
      _fbb,
      _block_size);
}

inline SubOptionsT *SubOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SubOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SubOptions::UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = pot_scale_int16(); _o->pot_scale_int16 = _e; };
}

inline flatbuffers::Offset<SubOptions> SubOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _pot_scale_int16 = _o->pot_scale_int16;
  return tflite::CreateSubOptions(
      _fbb,
      _fused_activation_function,
      _pot_scale_int16);
}

inline DivOptionsT *DivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DivOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DivOptions::UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
}

inline flatbuffers::Offset<DivOptions> DivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateDivOptions(
      _fbb,
      _fused_activation_function);
}

inline TopKV2OptionsT *TopKV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TopKV2OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TopKV2Options::UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TopKV2Options> TopKV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopKV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopKV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTopKV2Options(
      _fbb);
}

inline EmbeddingLookupSparseOptionsT *EmbeddingLookupSparseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EmbeddingLookupSparseOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EmbeddingLookupSparseOptions::UnPackTo(EmbeddingLookupSparseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = combiner(); _o->combiner = _e; };
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> EmbeddingLookupSparseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmbeddingLookupSparseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingLookupSparseOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _combiner = _o->combiner;
  return tflite::CreateEmbeddingLookupSparseOptions(
      _fbb,
      _combiner);
}

inline GatherOptionsT *GatherOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GatherOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GatherOptions::UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = batch_dims(); _o->batch_dims = _e; };
}

inline flatbuffers::Offset<GatherOptions> GatherOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _batch_dims = _o->batch_dims;
  return tflite::CreateGatherOptions(
      _fbb,
      _axis,
      _batch_dims);
}

inline TransposeOptionsT *TransposeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransposeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TransposeOptions::UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TransposeOptions> TransposeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransposeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTransposeOptions(
      _fbb);
}

inline ExpOptionsT *ExpOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ExpOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ExpOptions::UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpOptions> ExpOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateExpOptions(
      _fbb);
}

inline CosOptionsT *CosOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CosOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CosOptions::UnPackTo(CosOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<CosOptions> CosOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCosOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CosOptions> CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CosOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateCosOptions(
      _fbb);
}

inline ReducerOptionsT *ReducerOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReducerOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReducerOptions::UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keep_dims(); _o->keep_dims = _e; };
}

inline flatbuffers::Offset<ReducerOptions> ReducerOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReducerOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReducerOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keep_dims = _o->keep_dims;
  return tflite::CreateReducerOptions(
      _fbb,
      _keep_dims);
}

inline SqueezeOptionsT *SqueezeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SqueezeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SqueezeOptions::UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = squeeze_dims(); if (_e) { _o->squeeze_dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->squeeze_dims[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<SqueezeOptions> SqueezeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqueezeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqueezeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _squeeze_dims = _o->squeeze_dims.size() ? _fbb.CreateVector(_o->squeeze_dims) : 0;
  return tflite::CreateSqueezeOptions(
      _fbb,
      _squeeze_dims);
}

inline SplitOptionsT *SplitOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SplitOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SplitOptions::UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_splits(); _o->num_splits = _e; };
}

inline flatbuffers::Offset<SplitOptions> SplitOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplitOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_splits = _o->num_splits;
  return tflite::CreateSplitOptions(
      _fbb,
      _num_splits);
}

inline SplitVOptionsT *SplitVOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SplitVOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SplitVOptions::UnPackTo(SplitVOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_splits(); _o->num_splits = _e; };
}

inline flatbuffers::Offset<SplitVOptions> SplitVOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplitVOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitVOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_splits = _o->num_splits;
  return tflite::CreateSplitVOptions(
      _fbb,
      _num_splits);
}

inline StridedSliceOptionsT *StridedSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StridedSliceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StridedSliceOptions::UnPackTo(StridedSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = begin_mask(); _o->begin_mask = _e; };
  { auto _e = end_mask(); _o->end_mask = _e; };
  { auto _e = ellipsis_mask(); _o->ellipsis_mask = _e; };
  { auto _e = new_axis_mask(); _o->new_axis_mask = _e; };
  { auto _e = shrink_axis_mask(); _o->shrink_axis_mask = _e; };
  { auto _e = offset(); _o->offset = _e; };
}

inline flatbuffers::Offset<StridedSliceOptions> StridedSliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStridedSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _begin_mask = _o->begin_mask;
  auto _end_mask = _o->end_mask;
  auto _ellipsis_mask = _o->ellipsis_mask;
  auto _new_axis_mask = _o->new_axis_mask;
  auto _shrink_axis_mask = _o->shrink_axis_mask;
  auto _offset = _o->offset;
  return tflite::CreateStridedSliceOptions(
      _fbb,
      _begin_mask,
      _end_mask,
      _ellipsis_mask,
      _new_axis_mask,
      _shrink_axis_mask,
      _offset);
}

inline LogSoftmaxOptionsT *LogSoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogSoftmaxOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogSoftmaxOptions::UnPackTo(LogSoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogSoftmaxOptions> LogSoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogSoftmaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogSoftmaxOptions(
      _fbb);
}

inline CastOptionsT *CastOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CastOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CastOptions::UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = in_data_type(); _o->in_data_type = _e; };
  { auto _e = out_data_type(); _o->out_data_type = _e; };
}

inline flatbuffers::Offset<CastOptions> CastOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCastOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CastOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _in_data_type = _o->in_data_type;
  auto _out_data_type = _o->out_data_type;
  return tflite::CreateCastOptions(
      _fbb,
      _in_data_type,
      _out_data_type);
}

inline DequantizeOptionsT *DequantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DequantizeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DequantizeOptions::UnPackTo(DequantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DequantizeOptions> DequantizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDequantizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DequantizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDequantizeOptions(
      _fbb);
}

inline MaximumMinimumOptionsT *MaximumMinimumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MaximumMinimumOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MaximumMinimumOptions::UnPackTo(MaximumMinimumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MaximumMinimumOptions> MaximumMinimumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaximumMinimumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaximumMinimumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateMaximumMinimumOptions(
      _fbb);
}

inline TileOptionsT *TileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TileOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TileOptions::UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TileOptions> TileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TileOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTileOptions(
      _fbb);
}

inline ArgMaxOptionsT *ArgMaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ArgMaxOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ArgMaxOptions::UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_type(); _o->output_type = _e; };
}

inline flatbuffers::Offset<ArgMaxOptions> ArgMaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_type = _o->output_type;
  return tflite::CreateArgMaxOptions(
      _fbb,
      _output_type);
}

inline ArgMinOptionsT *ArgMinOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ArgMinOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ArgMinOptions::UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_type(); _o->output_type = _e; };
}

inline flatbuffers::Offset<ArgMinOptions> ArgMinOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMinOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMinOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_type = _o->output_type;
  return tflite::CreateArgMinOptions(
      _fbb,
      _output_type);
}

inline GreaterOptionsT *GreaterOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GreaterOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GreaterOptions::UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterOptions> GreaterOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGreaterOptions(
      _fbb);
}

inline GreaterEqualOptionsT *GreaterEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GreaterEqualOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GreaterEqualOptions::UnPackTo(GreaterEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterEqualOptions> GreaterEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGreaterEqualOptions(
      _fbb);
}

inline LessOptionsT *LessOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LessOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LessOptions::UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessOptions> LessOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLessOptions(
      _fbb);
}

inline LessEqualOptionsT *LessEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LessEqualOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LessEqualOptions::UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessEqualOptions> LessEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLessEqualOptions(
      _fbb);
}

inline NegOptionsT *NegOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NegOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NegOptions::UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NegOptions> NegOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNegOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NegOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNegOptions(
      _fbb);
}

inline SelectOptionsT *SelectOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SelectOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SelectOptions::UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SelectOptions> SelectOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSelectOptions(
      _fbb);
}

inline SliceOptionsT *SliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SliceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SliceOptions::UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SliceOptions> SliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSliceOptions(
      _fbb);
}

inline TransposeConvOptionsT *TransposeConvOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransposeConvOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TransposeConvOptions::UnPackTo(TransposeConvOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; };
  { auto _e = stride_w(); _o->stride_w = _e; };
  { auto _e = stride_h(); _o->stride_h = _e; };
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; };
  { auto _e = quantized_bias_type(); _o->quantized_bias_type = _e; };
}

inline flatbuffers::Offset<TransposeConvOptions> TransposeConvOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransposeConvOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeConvOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _quantized_bias_type = _o->quantized_bias_type;
  return tflite::CreateTransposeConvOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _fused_activation_function,
      _quantized_bias_type);
}

inline ExpandDimsOptionsT *ExpandDimsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ExpandDimsOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ExpandDimsOptions::UnPackTo(ExpandDimsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpandDimsOptions> ExpandDimsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpandDimsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateExpandDimsOptions(
      _fbb);
}

inline SparseToDenseOptionsT *SparseToDenseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SparseToDenseOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SparseToDenseOptions::UnPackTo(SparseToDenseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = validate_indices(); _o->validate_indices = _e; };
}

inline flatbuffers::Offset<SparseToDenseOptions> SparseToDenseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseToDenseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseToDenseOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _validate_indices = _o->validate_indices;
  return tflite::CreateSparseToDenseOptions(
      _fbb,
      _validate_indices);
}

inline EqualOptionsT *EqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EqualOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EqualOptions::UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<EqualOptions> EqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateEqualOptions(
      _fbb);
}

inline NotEqualOptionsT *NotEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NotEqualOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NotEqualOptions::UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NotEqualOptions> NotEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NotEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNotEqualOptions(
      _fbb);
}

inline ShapeOptionsT *ShapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShapeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ShapeOptions::UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = out_type(); _o->out_type = _e; };
}

inline flatbuffers::Offset<ShapeOptions> ShapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShapeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _out_type = _o->out_type;
  return tflite::CreateShapeOptions(
      _fbb,
      _out_type);
}

inline RankOptionsT *RankOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RankOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RankOptions::UnPackTo(RankOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RankOptions> RankOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRankOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RankOptions> CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RankOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRankOptions(
      _fbb);
}

inline PowOptionsT *PowOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PowOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PowOptions::UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PowOptions> PowOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePowOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePowOptions(
      _fbb);
}

inline FakeQuantOptionsT *FakeQuantOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FakeQuantOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FakeQuantOptions::UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min(); _o->min = _e; };
  { auto _e = max(); _o->max = _e; };
  { auto _e = num_bits(); _o->num_bits = _e; };
  { auto _e = narrow_range(); _o->narrow_range = _e; };
}

inline flatbuffers::Offset<FakeQuantOptions> FakeQuantOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFakeQuantOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min = _o->min;
  auto _max = _o->max;
  auto _num_bits = _o->num_bits;
  auto _narrow_range = _o->narrow_range;
  return tflite::CreateFakeQuantOptions(
      _fbb,
      _min,
      _max,
      _num_bits,
      _narrow_range);
}

inline PackOptionsT *PackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PackOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PackOptions::UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values_count(); _o->values_count = _e; };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<PackOptions> PackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PackOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values_count = _o->values_count;
  auto _axis = _o->axis;
  return tflite::CreatePackOptions(
      _fbb,
      _values_count,
      _axis);
}

inline LogicalOrOptionsT *LogicalOrOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogicalOrOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogicalOrOptions::UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalOrOptions> LogicalOrOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalOrOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalOrOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalOrOptions(
      _fbb);
}

inline OneHotOptionsT *OneHotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OneHotOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OneHotOptions::UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<OneHotOptions> OneHotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOneHotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OneHotOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return tflite::CreateOneHotOptions(
      _fbb,
      _axis);
}

inline AbsOptionsT *AbsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AbsOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AbsOptions::UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AbsOptions> AbsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateAbsOptions(
      _fbb);
}

inline HardSwishOptionsT *HardSwishOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HardSwishOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HardSwishOptions::UnPackTo(HardSwishOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HardSwishOptions> HardSwishOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHardSwishOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HardSwishOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHardSwishOptions(
      _fbb);
}

inline LogicalAndOptionsT *LogicalAndOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogicalAndOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogicalAndOptions::UnPackTo(LogicalAndOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalAndOptions> LogicalAndOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalAndOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalAndOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalAndOptions(
      _fbb);
}

inline LogicalNotOptionsT *LogicalNotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogicalNotOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogicalNotOptions::UnPackTo(LogicalNotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalNotOptions> LogicalNotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalNotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalNotOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalNotOptions(
      _fbb);
}

inline UnpackOptionsT *UnpackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnpackOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnpackOptions::UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num(); _o->num = _e; };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<UnpackOptions> UnpackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnpackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnpackOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num = _o->num;
  auto _axis = _o->axis;
  return tflite::CreateUnpackOptions(
      _fbb,
      _num,
      _axis);
}

inline FloorDivOptionsT *FloorDivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FloorDivOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FloorDivOptions::UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorDivOptions> FloorDivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorDivOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFloorDivOptions(
      _fbb);
}

inline SquareOptionsT *SquareOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SquareOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SquareOptions::UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SquareOptions> SquareOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquareOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquareOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSquareOptions(
      _fbb);
}

inline ZerosLikeOptionsT *ZerosLikeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ZerosLikeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ZerosLikeOptions::UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ZerosLikeOptions> ZerosLikeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateZerosLikeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ZerosLikeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateZerosLikeOptions(
      _fbb);
}

inline FillOptionsT *FillOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FillOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FillOptions::UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FillOptions> FillOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFillOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FillOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFillOptions(
      _fbb);
}

inline FloorModOptionsT *FloorModOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FloorModOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FloorModOptions::UnPackTo(FloorModOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorModOptions> FloorModOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorModOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorModOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFloorModOptions(
      _fbb);
}

inline RangeOptionsT *RangeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RangeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RangeOptions::UnPackTo(RangeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RangeOptions> RangeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRangeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RangeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRangeOptions(
      _fbb);
}

inline LeakyReluOptionsT *LeakyReluOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LeakyReluOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LeakyReluOptions::UnPackTo(LeakyReluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; };
}

inline flatbuffers::Offset<LeakyReluOptions> LeakyReluOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeakyReluOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return tflite::CreateLeakyReluOptions(
      _fbb,
      _alpha);
}

inline SquaredDifferenceOptionsT *SquaredDifferenceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SquaredDifferenceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SquaredDifferenceOptions::UnPackTo(SquaredDifferenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SquaredDifferenceOptions> SquaredDifferenceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquaredDifferenceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquaredDifferenceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSquaredDifferenceOptions(
      _fbb);
}

inline MirrorPadOptionsT *MirrorPadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MirrorPadOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MirrorPadOptions::UnPackTo(MirrorPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; };
}

inline flatbuffers::Offset<MirrorPadOptions> MirrorPadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMirrorPadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MirrorPadOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  return tflite::CreateMirrorPadOptions(
      _fbb,
      _mode);
}

inline UniqueOptionsT *UniqueOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UniqueOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UniqueOptions::UnPackTo(UniqueOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = idx_out_type(); _o->idx_out_type = _e; };
}

inline flatbuffers::Offset<UniqueOptions> UniqueOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UniqueOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _idx_out_type = _o->idx_out_type;
  return tflite::CreateUniqueOptions(
      _fbb,
      _idx_out_type);
}

inline ReverseV2OptionsT *ReverseV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReverseV2OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReverseV2Options::UnPackTo(ReverseV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReverseV2Options> ReverseV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverseV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateReverseV2Options(
      _fbb);
}

inline AddNOptionsT *AddNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AddNOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AddNOptions::UnPackTo(AddNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AddNOptions> AddNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateAddNOptions(
      _fbb);
}

inline GatherNdOptionsT *GatherNdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GatherNdOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GatherNdOptions::UnPackTo(GatherNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GatherNdOptions> GatherNdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherNdOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherNdOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGatherNdOptions(
      _fbb);
}

inline WhereOptionsT *WhereOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WhereOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WhereOptions::UnPackTo(WhereOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<WhereOptions> WhereOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhereOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhereOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateWhereOptions(
      _fbb);
}

inline ReverseSequenceOptionsT *ReverseSequenceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReverseSequenceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReverseSequenceOptions::UnPackTo(ReverseSequenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seq_dim(); _o->seq_dim = _e; };
  { auto _e = batch_dim(); _o->batch_dim = _e; };
}

inline flatbuffers::Offset<ReverseSequenceOptions> ReverseSequenceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverseSequenceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseSequenceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seq_dim = _o->seq_dim;
  auto _batch_dim = _o->batch_dim;
  return tflite::CreateReverseSequenceOptions(
      _fbb,
      _seq_dim,
      _batch_dim);
}

inline MatrixDiagOptionsT *MatrixDiagOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MatrixDiagOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MatrixDiagOptions::UnPackTo(MatrixDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MatrixDiagOptions> MatrixDiagOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatrixDiagOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatrixDiagOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateMatrixDiagOptions(
      _fbb);
}

inline QuantizeOptionsT *QuantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QuantizeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void QuantizeOptions::UnPackTo(QuantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<QuantizeOptions> QuantizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateQuantizeOptions(
      _fbb);
}

inline MatrixSetDiagOptionsT *MatrixSetDiagOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MatrixSetDiagOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MatrixSetDiagOptions::UnPackTo(MatrixSetDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MatrixSetDiagOptions> MatrixSetDiagOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatrixSetDiagOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatrixSetDiagOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateMatrixSetDiagOptions(
      _fbb);
}

inline IfOptionsT *IfOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IfOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IfOptions::UnPackTo(IfOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = then_subgraph_index(); _o->then_subgraph_index = _e; };
  { auto _e = else_subgraph_index(); _o->else_subgraph_index = _e; };
}

inline flatbuffers::Offset<IfOptions> IfOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIfOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IfOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _then_subgraph_index = _o->then_subgraph_index;
  auto _else_subgraph_index = _o->else_subgraph_index;
  return tflite::CreateIfOptions(
      _fbb,
      _then_subgraph_index,
      _else_subgraph_index);
}

inline CallOnceOptionsT *CallOnceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CallOnceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CallOnceOptions::UnPackTo(CallOnceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = init_subgraph_index(); _o->init_subgraph_index = _e; };
}

inline flatbuffers::Offset<CallOnceOptions> CallOnceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallOnceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallOnceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _init_subgraph_index = _o->init_subgraph_index;
  return tflite::CreateCallOnceOptions(
      _fbb,
      _init_subgraph_index);
}

inline WhileOptionsT *WhileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WhileOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WhileOptions::UnPackTo(WhileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cond_subgraph_index(); _o->cond_subgraph_index = _e; };
  { auto _e = body_subgraph_index(); _o->body_subgraph_index = _e; };
}

inline flatbuffers::Offset<WhileOptions> WhileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhileOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cond_subgraph_index = _o->cond_subgraph_index;
  auto _body_subgraph_index = _o->body_subgraph_index;
  return tflite::CreateWhileOptions(
      _fbb,
      _cond_subgraph_index,
      _body_subgraph_index);
}

inline NonMaxSuppressionV4OptionsT *NonMaxSuppressionV4Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NonMaxSuppressionV4OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NonMaxSuppressionV4Options::UnPackTo(NonMaxSuppressionV4OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NonMaxSuppressionV4Options> NonMaxSuppressionV4Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonMaxSuppressionV4Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV4OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNonMaxSuppressionV4Options(
      _fbb);
}

inline NonMaxSuppressionV5OptionsT *NonMaxSuppressionV5Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NonMaxSuppressionV5OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NonMaxSuppressionV5Options::UnPackTo(NonMaxSuppressionV5OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NonMaxSuppressionV5Options> NonMaxSuppressionV5Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonMaxSuppressionV5Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV5OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNonMaxSuppressionV5Options(
      _fbb);
}

inline ScatterNdOptionsT *ScatterNdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ScatterNdOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ScatterNdOptions::UnPackTo(ScatterNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ScatterNdOptions> ScatterNdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScatterNdOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScatterNdOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateScatterNdOptions(
      _fbb);
}

inline SelectV2OptionsT *SelectV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SelectV2OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SelectV2Options::UnPackTo(SelectV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SelectV2Options> SelectV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSelectV2Options(
      _fbb);
}

inline DensifyOptionsT *DensifyOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DensifyOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DensifyOptions::UnPackTo(DensifyOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DensifyOptions> DensifyOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDensifyOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DensifyOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDensifyOptions(
      _fbb);
}

inline SegmentSumOptionsT *SegmentSumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SegmentSumOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SegmentSumOptions::UnPackTo(SegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SegmentSumOptions> SegmentSumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSegmentSumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SegmentSumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSegmentSumOptions(
      _fbb);
}

inline BatchMatMulOptionsT *BatchMatMulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BatchMatMulOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BatchMatMulOptions::UnPackTo(BatchMatMulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = adj_x(); _o->adj_x = _e; };
  { auto _e = adj_y(); _o->adj_y = _e; };
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; };
}

inline flatbuffers::Offset<BatchMatMulOptions> BatchMatMulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchMatMulOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchMatMulOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _adj_x = _o->adj_x;
  auto _adj_y = _o->adj_y;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateBatchMatMulOptions(
      _fbb,
      _adj_x,
      _adj_y,
      _asymmetric_quantize_inputs);
}

inline CumsumOptionsT *CumsumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CumsumOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CumsumOptions::UnPackTo(CumsumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = exclusive(); _o->exclusive = _e; };
  { auto _e = reverse(); _o->reverse = _e; };
}

inline flatbuffers::Offset<CumsumOptions> CumsumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCumsumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CumsumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _exclusive = _o->exclusive;
  auto _reverse = _o->reverse;
  return tflite::CreateCumsumOptions(
      _fbb,
      _exclusive,
      _reverse);
}

inline BroadcastToOptionsT *BroadcastToOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BroadcastToOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BroadcastToOptions::UnPackTo(BroadcastToOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BroadcastToOptions> BroadcastToOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadcastToOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BroadcastToOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBroadcastToOptions(
      _fbb);
}

inline Rfft2dOptionsT *Rfft2dOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Rfft2dOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Rfft2dOptions::UnPackTo(Rfft2dOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rfft2dOptions> Rfft2dOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRfft2dOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Rfft2dOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRfft2dOptions(
      _fbb);
}

inline HashtableOptionsT *HashtableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HashtableOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HashtableOptions::UnPackTo(HashtableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = table_id(); _o->table_id = _e; };
  { auto _e = key_dtype(); _o->key_dtype = _e; };
  { auto _e = value_dtype(); _o->value_dtype = _e; };
}

inline flatbuffers::Offset<HashtableOptions> HashtableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _table_id = _o->table_id;
  auto _key_dtype = _o->key_dtype;
  auto _value_dtype = _o->value_dtype;
  return tflite::CreateHashtableOptions(
      _fbb,
      _table_id,
      _key_dtype,
      _value_dtype);
}

inline HashtableFindOptionsT *HashtableFindOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HashtableFindOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HashtableFindOptions::UnPackTo(HashtableFindOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableFindOptions> HashtableFindOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableFindOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableFindOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHashtableFindOptions(
      _fbb);
}

inline HashtableImportOptionsT *HashtableImportOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HashtableImportOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HashtableImportOptions::UnPackTo(HashtableImportOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableImportOptions> HashtableImportOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableImportOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableImportOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHashtableImportOptions(
      _fbb);
}

inline HashtableSizeOptionsT *HashtableSizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HashtableSizeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HashtableSizeOptions::UnPackTo(HashtableSizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableSizeOptions> HashtableSizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableSizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableSizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHashtableSizeOptions(
      _fbb);
}

inline VarHandleOptionsT *VarHandleOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new VarHandleOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void VarHandleOptions::UnPackTo(VarHandleOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = container(); if (_e) _o->container = _e->str(); };
  { auto _e = shared_name(); if (_e) _o->shared_name = _e->str(); };
}

inline flatbuffers::Offset<VarHandleOptions> VarHandleOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVarHandleOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VarHandleOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _container = _o->container.empty() ? 0 : _fbb.CreateString(_o->container);
  auto _shared_name = _o->shared_name.empty() ? 0 : _fbb.CreateString(_o->shared_name);
  return tflite::CreateVarHandleOptions(
      _fbb,
      _container,
      _shared_name);
}

inline ReadVariableOptionsT *ReadVariableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReadVariableOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReadVariableOptions::UnPackTo(ReadVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReadVariableOptions> ReadVariableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReadVariableOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReadVariableOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateReadVariableOptions(
      _fbb);
}

inline AssignVariableOptionsT *AssignVariableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AssignVariableOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AssignVariableOptions::UnPackTo(AssignVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AssignVariableOptions> AssignVariableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssignVariableOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssignVariableOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateAssignVariableOptions(
      _fbb);
}

inline RandomOptionsT *RandomOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RandomOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RandomOptions::UnPackTo(RandomOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seed(); _o->seed = _e; };
  { auto _e = seed2(); _o->seed2 = _e; };
}

inline flatbuffers::Offset<RandomOptions> RandomOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandomOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RandomOptions> CreateRandomOptions(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RandomOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seed = _o->seed;
  auto _seed2 = _o->seed2;
  return tflite::CreateRandomOptions(
      _fbb,
      _seed,
      _seed2);
}

inline BucketizeOptionsT *BucketizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BucketizeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BucketizeOptions::UnPackTo(BucketizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = boundaries(); if (_e) { _o->boundaries.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->boundaries[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<BucketizeOptions> BucketizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBucketizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BucketizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _boundaries = _o->boundaries.size() ? _fbb.CreateVector(_o->boundaries) : 0;
  return tflite::CreateBucketizeOptions(
      _fbb,
      _boundaries);
}

inline GeluOptionsT *GeluOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GeluOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GeluOptions::UnPackTo(GeluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = approximate(); _o->approximate = _e; };
}

inline flatbuffers::Offset<GeluOptions> GeluOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeluOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeluOptions> CreateGeluOptions(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeluOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _approximate = _o->approximate;
  return tflite::CreateGeluOptions(
      _fbb,
      _approximate);
}

inline DynamicUpdateSliceOptionsT *DynamicUpdateSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DynamicUpdateSliceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DynamicUpdateSliceOptions::UnPackTo(DynamicUpdateSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DynamicUpdateSliceOptions> DynamicUpdateSliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDynamicUpdateSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DynamicUpdateSliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDynamicUpdateSliceOptions(
      _fbb);
}

inline UnsortedSegmentProdOptionsT *UnsortedSegmentProdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnsortedSegmentProdOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnsortedSegmentProdOptions::UnPackTo(UnsortedSegmentProdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<UnsortedSegmentProdOptions> UnsortedSegmentProdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsortedSegmentProdOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentProdOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateUnsortedSegmentProdOptions(
      _fbb);
}

inline UnsortedSegmentMaxOptionsT *UnsortedSegmentMaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnsortedSegmentMaxOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnsortedSegmentMaxOptions::UnPackTo(UnsortedSegmentMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<UnsortedSegmentMaxOptions> UnsortedSegmentMaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsortedSegmentMaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentMaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateUnsortedSegmentMaxOptions(
      _fbb);
}

inline UnsortedSegmentSumOptionsT *UnsortedSegmentSumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnsortedSegmentSumOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnsortedSegmentSumOptions::UnPackTo(UnsortedSegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<UnsortedSegmentSumOptions> UnsortedSegmentSumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsortedSegmentSumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentSumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateUnsortedSegmentSumOptions(
      _fbb);
}

inline ATan2OptionsT *ATan2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ATan2OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ATan2Options::UnPackTo(ATan2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ATan2Options> ATan2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateATan2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ATan2Options> CreateATan2Options(flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ATan2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateATan2Options(
      _fbb);
}

inline UnsortedSegmentMinOptionsT *UnsortedSegmentMinOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnsortedSegmentMinOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnsortedSegmentMinOptions::UnPackTo(UnsortedSegmentMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<UnsortedSegmentMinOptions> UnsortedSegmentMinOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsortedSegmentMinOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentMinOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateUnsortedSegmentMinOptions(
      _fbb);
}

inline SignOptionsT *SignOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SignOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SignOptions::UnPackTo(SignOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SignOptions> SignOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SignOptions> CreateSignOptions(flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSignOptions(
      _fbb);
}

inline BitcastOptionsT *BitcastOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BitcastOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BitcastOptions::UnPackTo(BitcastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BitcastOptions> BitcastOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBitcastOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BitcastOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBitcastOptions(
      _fbb);
}

inline BitwiseXorOptionsT *BitwiseXorOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BitwiseXorOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BitwiseXorOptions::UnPackTo(BitwiseXorOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BitwiseXorOptions> BitwiseXorOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BitwiseXorOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBitwiseXorOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BitwiseXorOptions> CreateBitwiseXorOptions(flatbuffers::FlatBufferBuilder &_fbb, const BitwiseXorOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BitwiseXorOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBitwiseXorOptions(
      _fbb);
}

inline RightShiftOptionsT *RightShiftOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RightShiftOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RightShiftOptions::UnPackTo(RightShiftOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RightShiftOptions> RightShiftOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RightShiftOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRightShiftOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RightShiftOptions> CreateRightShiftOptions(flatbuffers::FlatBufferBuilder &_fbb, const RightShiftOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RightShiftOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRightShiftOptions(
      _fbb);
}

inline DilateOptionsT *DilateOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DilateOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DilateOptions::UnPackTo(DilateOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DilateOptions> DilateOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DilateOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDilateOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DilateOptions> CreateDilateOptions(flatbuffers::FlatBufferBuilder &_fbb, const DilateOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DilateOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDilateOptions(
      _fbb);
}

inline ReduceWindowOptionsT *ReduceWindowOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReduceWindowOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReduceWindowOptions::UnPackTo(ReduceWindowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = reduce_function(); _o->reduce_function = _e; };
}

inline flatbuffers::Offset<ReduceWindowOptions> ReduceWindowOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceWindowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceWindowOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceWindowOptions> CreateReduceWindowOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReduceWindowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceWindowOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _reduce_function = _o->reduce_function;
  return tflite::CreateReduceWindowOptions(
      _fbb,
      _reduce_function);
}

inline OperatorCodeT *OperatorCode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OperatorCodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OperatorCode::UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deprecated_builtin_code(); _o->deprecated_builtin_code = _e; };
  { auto _e = custom_code(); if (_e) _o->custom_code = _e->str(); };
  { auto _e = version(); _o->version = _e; };
  { auto _e = builtin_code(); _o->builtin_code = _e; };
}

inline flatbuffers::Offset<OperatorCode> OperatorCode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorCode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorCodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deprecated_builtin_code = _o->deprecated_builtin_code;
  auto _custom_code = _o->custom_code.empty() ? 0 : _fbb.CreateString(_o->custom_code);
  auto _version = _o->version;
  auto _builtin_code = _o->builtin_code;
  return tflite::CreateOperatorCode(
      _fbb,
      _deprecated_builtin_code,
      _custom_code,
      _version,
      _builtin_code);
}

inline StableHLOCompositeOptionsT *StableHLOCompositeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StableHLOCompositeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StableHLOCompositeOptions::UnPackTo(StableHLOCompositeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = decomposition_subgraph_index(); _o->decomposition_subgraph_index = _e; };
  { auto _e = composite_attributes(); if (_e) { _o->composite_attributes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->composite_attributes[_i] = _e->Get(_i); } } };
  { auto _e = composite_attributes_format(); _o->composite_attributes_format = _e; };
  { auto _e = version(); _o->version = _e; };
}

inline flatbuffers::Offset<StableHLOCompositeOptions> StableHLOCompositeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StableHLOCompositeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStableHLOCompositeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StableHLOCompositeOptions> CreateStableHLOCompositeOptions(flatbuffers::FlatBufferBuilder &_fbb, const StableHLOCompositeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StableHLOCompositeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _decomposition_subgraph_index = _o->decomposition_subgraph_index;
  auto _composite_attributes = _o->composite_attributes.size() ? _fbb.CreateVector(_o->composite_attributes) : 0;
  auto _composite_attributes_format = _o->composite_attributes_format;
  auto _version = _o->version;
  return tflite::CreateStableHLOCompositeOptions(
      _fbb,
      _name,
      _decomposition_subgraph_index,
      _composite_attributes,
      _composite_attributes_format,
      _version);
}

inline StablehloShiftLeftOptionsT *StablehloShiftLeftOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StablehloShiftLeftOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StablehloShiftLeftOptions::UnPackTo(StablehloShiftLeftOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<StablehloShiftLeftOptions> StablehloShiftLeftOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StablehloShiftLeftOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloShiftLeftOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StablehloShiftLeftOptions> CreateStablehloShiftLeftOptions(flatbuffers::FlatBufferBuilder &_fbb, const StablehloShiftLeftOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StablehloShiftLeftOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateStablehloShiftLeftOptions(
      _fbb);
}

inline OperatorT *Operator::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OperatorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Operator::UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = opcode_index(); _o->opcode_index = _e; };
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } };
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } };
  { auto _e = builtin_options_type(); _o->builtin_options.type = _e; };
  { auto _e = builtin_options(); if (_e) _o->builtin_options.value = BuiltinOptionsUnion::UnPack(_e, builtin_options_type(), _resolver); };
  { auto _e = custom_options(); if (_e) { _o->custom_options.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->custom_options[_i] = _e->Get(_i); } } };
  { auto _e = custom_options_format(); _o->custom_options_format = _e; };
  { auto _e = mutating_variable_inputs(); if (_e) { _o->mutating_variable_inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mutating_variable_inputs[_i] = _e->Get(_i) != 0; } } };
  { auto _e = intermediates(); if (_e) { _o->intermediates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intermediates[_i] = _e->Get(_i); } } };
  { auto _e = large_custom_options_offset(); _o->large_custom_options_offset = _e; };
  { auto _e = large_custom_options_size(); _o->large_custom_options_size = _e; };
  { auto _e = builtin_options_2_type(); _o->builtin_options_2.type = _e; };
  { auto _e = builtin_options_2(); if (_e) _o->builtin_options_2.value = BuiltinOptions2Union::UnPack(_e, builtin_options_2_type(), _resolver); };
  { auto _e = debug_metadata_index(); _o->debug_metadata_index = _e; };
}

inline flatbuffers::Offset<Operator> Operator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperator(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _opcode_index = _o->opcode_index;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _builtin_options_type = _o->builtin_options.type;
  auto _builtin_options = _o->builtin_options.Pack(_fbb);
  auto _custom_options = _o->custom_options.size() ? _fbb.CreateVector(_o->custom_options) : 0;
  auto _custom_options_format = _o->custom_options_format;
  auto _mutating_variable_inputs = _o->mutating_variable_inputs.size() ? _fbb.CreateVector(_o->mutating_variable_inputs) : 0;
  auto _intermediates = _o->intermediates.size() ? _fbb.CreateVector(_o->intermediates) : 0;
  auto _large_custom_options_offset = _o->large_custom_options_offset;
  auto _large_custom_options_size = _o->large_custom_options_size;
  auto _builtin_options_2_type = _o->builtin_options_2.type;
  auto _builtin_options_2 = _o->builtin_options_2.Pack(_fbb);
  auto _debug_metadata_index = _o->debug_metadata_index;
  return tflite::CreateOperator(
      _fbb,
      _opcode_index,
      _inputs,
      _outputs,
      _builtin_options_type,
      _builtin_options,
      _custom_options,
      _custom_options_format,
      _mutating_variable_inputs,
      _intermediates,
      _large_custom_options_offset,
      _large_custom_options_size,
      _builtin_options_2_type,
      _builtin_options_2,
      _debug_metadata_index);
}

inline SubGraphT *SubGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SubGraphT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SubGraph::UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensors[_i] = std::unique_ptr<TensorT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } };
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } };
  { auto _e = operators(); if (_e) { _o->operators.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->operators[_i] = std::unique_ptr<OperatorT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = debug_metadata_index(); _o->debug_metadata_index = _e; };
}

inline flatbuffers::Offset<SubGraph> SubGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensors = _o->tensors.size() ? _fbb.CreateVector<flatbuffers::Offset<Tensor>> (_o->tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateTensor(*__va->__fbb, __va->__o->tensors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _operators = _o->operators.size() ? _fbb.CreateVector<flatbuffers::Offset<Operator>> (_o->operators.size(), [](size_t i, _VectorArgs *__va) { return CreateOperator(*__va->__fbb, __va->__o->operators[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _debug_metadata_index = _o->debug_metadata_index;
  return tflite::CreateSubGraph(
      _fbb,
      _tensors,
      _inputs,
      _outputs,
      _operators,
      _name,
      _debug_metadata_index);
}

inline BufferT *Buffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BufferT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Buffer::UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
  { auto _e = offset(); _o->offset = _e; };
  { auto _e = size(); _o->size = _e; };
}

inline flatbuffers::Offset<Buffer> Buffer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBuffer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BufferT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  auto _offset = _o->offset;
  auto _size = _o->size;
  return tflite::CreateBuffer(
      _fbb,
      _data,
      _offset,
      _size);
}

inline MetadataT *Metadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MetadataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Metadata::UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = buffer(); _o->buffer = _e; };
}

inline flatbuffers::Offset<Metadata> Metadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _buffer = _o->buffer;
  return tflite::CreateMetadata(
      _fbb,
      _name,
      _buffer);
}

inline TensorMapT *TensorMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorMapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TensorMap::UnPackTo(TensorMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = tensor_index(); _o->tensor_index = _e; };
}

inline flatbuffers::Offset<TensorMap> TensorMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorMap> CreateTensorMap(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _tensor_index = _o->tensor_index;
  return tflite::CreateTensorMap(
      _fbb,
      _name,
      _tensor_index);
}

inline SignatureDefT *SignatureDef::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SignatureDefT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SignatureDef::UnPackTo(SignatureDefT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = std::unique_ptr<TensorMapT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = std::unique_ptr<TensorMapT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = signature_key(); if (_e) _o->signature_key = _e->str(); };
  { auto _e = subgraph_index(); _o->subgraph_index = _e; };
}

inline flatbuffers::Offset<SignatureDef> SignatureDef::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignatureDef(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SignatureDef> CreateSignatureDef(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignatureDefT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector<flatbuffers::Offset<TensorMap>> (_o->inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorMap(*__va->__fbb, __va->__o->inputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector<flatbuffers::Offset<TensorMap>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorMap(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _signature_key = _o->signature_key.empty() ? 0 : _fbb.CreateString(_o->signature_key);
  auto _subgraph_index = _o->subgraph_index;
  return tflite::CreateSignatureDef(
      _fbb,
      _inputs,
      _outputs,
      _signature_key,
      _subgraph_index);
}

inline ModelT *Model::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ModelT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Model::UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; };
  { auto _e = operator_codes(); if (_e) { _o->operator_codes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->operator_codes[_i] = std::unique_ptr<OperatorCodeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = subgraphs(); if (_e) { _o->subgraphs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->subgraphs[_i] = std::unique_ptr<SubGraphT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = description(); if (_e) _o->description = _e->str(); };
  { auto _e = buffers(); if (_e) { _o->buffers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buffers[_i] = std::unique_ptr<BufferT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = metadata_buffer(); if (_e) { _o->metadata_buffer.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metadata_buffer[_i] = _e->Get(_i); } } };
  { auto _e = metadata(); if (_e) { _o->metadata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metadata[_i] = std::unique_ptr<MetadataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = signature_defs(); if (_e) { _o->signature_defs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->signature_defs[_i] = std::unique_ptr<SignatureDefT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Model> Model::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  auto _operator_codes = _o->operator_codes.size() ? _fbb.CreateVector<flatbuffers::Offset<OperatorCode>> (_o->operator_codes.size(), [](size_t i, _VectorArgs *__va) { return CreateOperatorCode(*__va->__fbb, __va->__o->operator_codes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<flatbuffers::Offset<SubGraph>> (_o->subgraphs.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraph(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
  auto _buffers = _o->buffers.size() ? _fbb.CreateVector<flatbuffers::Offset<Buffer>> (_o->buffers.size(), [](size_t i, _VectorArgs *__va) { return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _metadata_buffer = _o->metadata_buffer.size() ? _fbb.CreateVector(_o->metadata_buffer) : 0;
  auto _metadata = _o->metadata.size() ? _fbb.CreateVector<flatbuffers::Offset<Metadata>> (_o->metadata.size(), [](size_t i, _VectorArgs *__va) { return CreateMetadata(*__va->__fbb, __va->__o->metadata[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _signature_defs = _o->signature_defs.size() ? _fbb.CreateVector<flatbuffers::Offset<SignatureDef>> (_o->signature_defs.size(), [](size_t i, _VectorArgs *__va) { return CreateSignatureDef(*__va->__fbb, __va->__o->signature_defs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::CreateModel(
      _fbb,
      _version,
      _operator_codes,
      _subgraphs,
      _description,
      _buffers,
      _metadata_buffer,
      _metadata,
      _signature_defs);
}

inline bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type) {
  switch (type) {
    case QuantizationDetails_NONE: {
      return true;
    }
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const CustomQuantization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case QuantizationDetails_BlockwiseQuantization: {
      auto ptr = reinterpret_cast<const BlockwiseQuantization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQuantizationDetails(
        verifier,  values->Get(i), types->GetEnum<QuantizationDetails>(i))) {
      return false;
    }
  }
  return true;
}

inline void *QuantizationDetailsUnion::UnPack(const void *obj, QuantizationDetails type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const CustomQuantization *>(obj);
      return ptr->UnPack(resolver);
    }
    case QuantizationDetails_BlockwiseQuantization: {
      auto ptr = reinterpret_cast<const BlockwiseQuantization *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> QuantizationDetailsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const CustomQuantizationT *>(value);
      return CreateCustomQuantization(_fbb, ptr, _rehasher).Union();
    }
    case QuantizationDetails_BlockwiseQuantization: {
      auto ptr = reinterpret_cast<const BlockwiseQuantizationT *>(value);
      return CreateBlockwiseQuantization(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline QuantizationDetailsUnion::QuantizationDetailsUnion(const QuantizationDetailsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      value = new CustomQuantizationT(*reinterpret_cast<CustomQuantizationT *>(u.value));
      break;
    }
    case QuantizationDetails_BlockwiseQuantization: {
      value = new BlockwiseQuantizationT(*reinterpret_cast<BlockwiseQuantizationT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void QuantizationDetailsUnion::Reset() {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<CustomQuantizationT *>(value);
      delete ptr;
      break;
    }
    case QuantizationDetails_BlockwiseQuantization: {
      auto ptr = reinterpret_cast<BlockwiseQuantizationT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = QuantizationDetails_NONE;
}

inline bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type) {
  switch (type) {
    case SparseIndexVector_NONE: {
      return true;
    }
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const Int32Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const Uint16Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const Uint8Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySparseIndexVector(
        verifier,  values->Get(i), types->GetEnum<SparseIndexVector>(i))) {
      return false;
    }
  }
  return true;
}

inline void *SparseIndexVectorUnion::UnPack(const void *obj, SparseIndexVector type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const Int32Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const Uint16Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const Uint8Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> SparseIndexVectorUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const Int32VectorT *>(value);
      return CreateInt32Vector(_fbb, ptr, _rehasher).Union();
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const Uint16VectorT *>(value);
      return CreateUint16Vector(_fbb, ptr, _rehasher).Union();
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const Uint8VectorT *>(value);
      return CreateUint8Vector(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline SparseIndexVectorUnion::SparseIndexVectorUnion(const SparseIndexVectorUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      value = new Int32VectorT(*reinterpret_cast<Int32VectorT *>(u.value));
      break;
    }
    case SparseIndexVector_Uint16Vector: {
      value = new Uint16VectorT(*reinterpret_cast<Uint16VectorT *>(u.value));
      break;
    }
    case SparseIndexVector_Uint8Vector: {
      value = new Uint8VectorT(*reinterpret_cast<Uint8VectorT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void SparseIndexVectorUnion::Reset() {
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<Int32VectorT *>(value);
      delete ptr;
      break;
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<Uint16VectorT *>(value);
      delete ptr;
      break;
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<Uint8VectorT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = SparseIndexVector_NONE;
}

inline bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type) {
  switch (type) {
    case BuiltinOptions_NONE: {
      return true;
    }
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const Conv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const DepthwiseConv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const ConcatEmbeddingsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const LSHProjectionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const Pool2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const SVDFOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const RNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const FullyConnectedOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const SoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const ConcatenationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const AddOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const L2NormOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const LocalResponseNormalizationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const LSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const ResizeBilinearOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const CallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const ReshapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const SkipGramOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const SpaceToDepthOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const EmbeddingLookupSparseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const MulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const PadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const GatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const BatchToSpaceNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const SpaceToBatchNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const TransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const ReducerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const SubOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const DivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const SqueezeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const SequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const StridedSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const ExpOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const TopKV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const SplitOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const LogSoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const CastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const DequantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const MaximumMinimumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const ArgMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const LessOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const NegOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const PadV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const GreaterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const GreaterEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const LessEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const SelectOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const SliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const TransposeConvOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const SparseToDenseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const TileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const ExpandDimsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const EqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const NotEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const ShapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const PowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const ArgMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const FakeQuantOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const PackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const LogicalOrOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const OneHotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const LogicalAndOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const LogicalNotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const UnpackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const FloorDivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const SquareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const ZerosLikeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const FillOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const BidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const BidirectionalSequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const UnidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const FloorModOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const RangeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const ResizeNearestNeighborOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const LeakyReluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const SquaredDifferenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const MirrorPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const AbsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const SplitVOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const UniqueOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const ReverseV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const AddNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const GatherNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const CosOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const WhereOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const RankOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const ReverseSequenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const MatrixDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const QuantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const MatrixSetDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const HardSwishOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const IfOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const WhileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const DepthToSpaceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV4Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV5Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const ScatterNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const SelectV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const DensifyOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const SegmentSumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const BatchMatMulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const CumsumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const CallOnceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const BroadcastToOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const Rfft2dOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const Conv3DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const HashtableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const HashtableFindOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const HashtableImportOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const HashtableSizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<const VarHandleOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<const ReadVariableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<const AssignVariableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<const RandomOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<const BucketizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<const GeluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<const DynamicUpdateSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentProdOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentProdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentMinOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentSumOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentSumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ATan2Options: {
      auto ptr = reinterpret_cast<const ATan2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SignOptions: {
      auto ptr = reinterpret_cast<const SignOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BitcastOptions: {
      auto ptr = reinterpret_cast<const BitcastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BitwiseXorOptions: {
      auto ptr = reinterpret_cast<const BitwiseXorOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RightShiftOptions: {
      auto ptr = reinterpret_cast<const RightShiftOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBuiltinOptions(
        verifier,  values->Get(i), types->GetEnum<BuiltinOptions>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BuiltinOptionsUnion::UnPack(const void *obj, BuiltinOptions type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const Conv2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const DepthwiseConv2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const ConcatEmbeddingsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const LSHProjectionOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const Pool2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const SVDFOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const RNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const FullyConnectedOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const SoftmaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const ConcatenationOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const AddOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const L2NormOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const LocalResponseNormalizationOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const LSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const ResizeBilinearOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const CallOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const ReshapeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const SkipGramOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const SpaceToDepthOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const EmbeddingLookupSparseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const MulOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const PadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const GatherOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const BatchToSpaceNDOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const SpaceToBatchNDOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const TransposeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const ReducerOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const SubOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const DivOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const SqueezeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const SequenceRNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const StridedSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const ExpOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const TopKV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const SplitOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const LogSoftmaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const CastOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const DequantizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const MaximumMinimumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const ArgMaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const LessOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const NegOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const PadV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const GreaterOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const GreaterEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const LessEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const SelectOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const SliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const TransposeConvOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const SparseToDenseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const TileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const ExpandDimsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const EqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const NotEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const ShapeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const PowOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const ArgMinOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const FakeQuantOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const PackOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const LogicalOrOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const OneHotOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const LogicalAndOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const LogicalNotOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const UnpackOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const FloorDivOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const SquareOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const ZerosLikeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const FillOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const BidirectionalSequenceLSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const BidirectionalSequenceRNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const UnidirectionalSequenceLSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const FloorModOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const RangeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const ResizeNearestNeighborOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const LeakyReluOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const SquaredDifferenceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const MirrorPadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const AbsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const SplitVOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const UniqueOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const ReverseV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const AddNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const GatherNdOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const CosOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const WhereOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const RankOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const ReverseSequenceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const MatrixDiagOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const QuantizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const MatrixSetDiagOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const HardSwishOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const IfOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const WhileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const DepthToSpaceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV4Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV5Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const ScatterNdOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const SelectV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const DensifyOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const SegmentSumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const BatchMatMulOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const CumsumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const CallOnceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const BroadcastToOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const Rfft2dOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const Conv3DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const HashtableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const HashtableFindOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const HashtableImportOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const HashtableSizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<const VarHandleOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<const ReadVariableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<const AssignVariableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<const RandomOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<const BucketizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<const GeluOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<const DynamicUpdateSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnsortedSegmentProdOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentProdOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentMaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnsortedSegmentMinOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentMinOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnsortedSegmentSumOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentSumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ATan2Options: {
      auto ptr = reinterpret_cast<const ATan2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SignOptions: {
      auto ptr = reinterpret_cast<const SignOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BitcastOptions: {
      auto ptr = reinterpret_cast<const BitcastOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BitwiseXorOptions: {
      auto ptr = reinterpret_cast<const BitwiseXorOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RightShiftOptions: {
      auto ptr = reinterpret_cast<const RightShiftOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> BuiltinOptionsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const Conv2DOptionsT *>(value);
      return CreateConv2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const DepthwiseConv2DOptionsT *>(value);
      return CreateDepthwiseConv2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const ConcatEmbeddingsOptionsT *>(value);
      return CreateConcatEmbeddingsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const LSHProjectionOptionsT *>(value);
      return CreateLSHProjectionOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const Pool2DOptionsT *>(value);
      return CreatePool2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const SVDFOptionsT *>(value);
      return CreateSVDFOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const RNNOptionsT *>(value);
      return CreateRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const FullyConnectedOptionsT *>(value);
      return CreateFullyConnectedOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const SoftmaxOptionsT *>(value);
      return CreateSoftmaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const ConcatenationOptionsT *>(value);
      return CreateConcatenationOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const AddOptionsT *>(value);
      return CreateAddOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const L2NormOptionsT *>(value);
      return CreateL2NormOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const LocalResponseNormalizationOptionsT *>(value);
      return CreateLocalResponseNormalizationOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const LSTMOptionsT *>(value);
      return CreateLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const ResizeBilinearOptionsT *>(value);
      return CreateResizeBilinearOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const CallOptionsT *>(value);
      return CreateCallOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const ReshapeOptionsT *>(value);
      return CreateReshapeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const SkipGramOptionsT *>(value);
      return CreateSkipGramOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const SpaceToDepthOptionsT *>(value);
      return CreateSpaceToDepthOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const EmbeddingLookupSparseOptionsT *>(value);
      return CreateEmbeddingLookupSparseOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const MulOptionsT *>(value);
      return CreateMulOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const PadOptionsT *>(value);
      return CreatePadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const GatherOptionsT *>(value);
      return CreateGatherOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const BatchToSpaceNDOptionsT *>(value);
      return CreateBatchToSpaceNDOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const SpaceToBatchNDOptionsT *>(value);
      return CreateSpaceToBatchNDOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const TransposeOptionsT *>(value);
      return CreateTransposeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const ReducerOptionsT *>(value);
      return CreateReducerOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const SubOptionsT *>(value);
      return CreateSubOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const DivOptionsT *>(value);
      return CreateDivOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const SqueezeOptionsT *>(value);
      return CreateSqueezeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const SequenceRNNOptionsT *>(value);
      return CreateSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const StridedSliceOptionsT *>(value);
      return CreateStridedSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const ExpOptionsT *>(value);
      return CreateExpOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const TopKV2OptionsT *>(value);
      return CreateTopKV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const SplitOptionsT *>(value);
      return CreateSplitOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const LogSoftmaxOptionsT *>(value);
      return CreateLogSoftmaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const CastOptionsT *>(value);
      return CreateCastOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const DequantizeOptionsT *>(value);
      return CreateDequantizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const MaximumMinimumOptionsT *>(value);
      return CreateMaximumMinimumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const ArgMaxOptionsT *>(value);
      return CreateArgMaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const LessOptionsT *>(value);
      return CreateLessOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const NegOptionsT *>(value);
      return CreateNegOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const PadV2OptionsT *>(value);
      return CreatePadV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const GreaterOptionsT *>(value);
      return CreateGreaterOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const GreaterEqualOptionsT *>(value);
      return CreateGreaterEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const LessEqualOptionsT *>(value);
      return CreateLessEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const SelectOptionsT *>(value);
      return CreateSelectOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const SliceOptionsT *>(value);
      return CreateSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const TransposeConvOptionsT *>(value);
      return CreateTransposeConvOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const SparseToDenseOptionsT *>(value);
      return CreateSparseToDenseOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const TileOptionsT *>(value);
      return CreateTileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const ExpandDimsOptionsT *>(value);
      return CreateExpandDimsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const EqualOptionsT *>(value);
      return CreateEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const NotEqualOptionsT *>(value);
      return CreateNotEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const ShapeOptionsT *>(value);
      return CreateShapeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const PowOptionsT *>(value);
      return CreatePowOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const ArgMinOptionsT *>(value);
      return CreateArgMinOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const FakeQuantOptionsT *>(value);
      return CreateFakeQuantOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const PackOptionsT *>(value);
      return CreatePackOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const LogicalOrOptionsT *>(value);
      return CreateLogicalOrOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const OneHotOptionsT *>(value);
      return CreateOneHotOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const LogicalAndOptionsT *>(value);
      return CreateLogicalAndOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const LogicalNotOptionsT *>(value);
      return CreateLogicalNotOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const UnpackOptionsT *>(value);
      return CreateUnpackOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const FloorDivOptionsT *>(value);
      return CreateFloorDivOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const SquareOptionsT *>(value);
      return CreateSquareOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const ZerosLikeOptionsT *>(value);
      return CreateZerosLikeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const FillOptionsT *>(value);
      return CreateFillOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const BidirectionalSequenceLSTMOptionsT *>(value);
      return CreateBidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const BidirectionalSequenceRNNOptionsT *>(value);
      return CreateBidirectionalSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const UnidirectionalSequenceLSTMOptionsT *>(value);
      return CreateUnidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const FloorModOptionsT *>(value);
      return CreateFloorModOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const RangeOptionsT *>(value);
      return CreateRangeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const ResizeNearestNeighborOptionsT *>(value);
      return CreateResizeNearestNeighborOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const LeakyReluOptionsT *>(value);
      return CreateLeakyReluOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const SquaredDifferenceOptionsT *>(value);
      return CreateSquaredDifferenceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const MirrorPadOptionsT *>(value);
      return CreateMirrorPadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const AbsOptionsT *>(value);
      return CreateAbsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const SplitVOptionsT *>(value);
      return CreateSplitVOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const UniqueOptionsT *>(value);
      return CreateUniqueOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const ReverseV2OptionsT *>(value);
      return CreateReverseV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const AddNOptionsT *>(value);
      return CreateAddNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const GatherNdOptionsT *>(value);
      return CreateGatherNdOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const CosOptionsT *>(value);
      return CreateCosOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const WhereOptionsT *>(value);
      return CreateWhereOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const RankOptionsT *>(value);
      return CreateRankOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const ReverseSequenceOptionsT *>(value);
      return CreateReverseSequenceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const MatrixDiagOptionsT *>(value);
      return CreateMatrixDiagOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const QuantizeOptionsT *>(value);
      return CreateQuantizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const MatrixSetDiagOptionsT *>(value);
      return CreateMatrixSetDiagOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const HardSwishOptionsT *>(value);
      return CreateHardSwishOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const IfOptionsT *>(value);
      return CreateIfOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const WhileOptionsT *>(value);
      return CreateWhileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const DepthToSpaceOptionsT *>(value);
      return CreateDepthToSpaceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV4OptionsT *>(value);
      return CreateNonMaxSuppressionV4Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV5OptionsT *>(value);
      return CreateNonMaxSuppressionV5Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const ScatterNdOptionsT *>(value);
      return CreateScatterNdOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const SelectV2OptionsT *>(value);
      return CreateSelectV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const DensifyOptionsT *>(value);
      return CreateDensifyOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const SegmentSumOptionsT *>(value);
      return CreateSegmentSumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const BatchMatMulOptionsT *>(value);
      return CreateBatchMatMulOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const CumsumOptionsT *>(value);
      return CreateCumsumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const CallOnceOptionsT *>(value);
      return CreateCallOnceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const BroadcastToOptionsT *>(value);
      return CreateBroadcastToOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const Rfft2dOptionsT *>(value);
      return CreateRfft2dOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const Conv3DOptionsT *>(value);
      return CreateConv3DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const HashtableOptionsT *>(value);
      return CreateHashtableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const HashtableFindOptionsT *>(value);
      return CreateHashtableFindOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const HashtableImportOptionsT *>(value);
      return CreateHashtableImportOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const HashtableSizeOptionsT *>(value);
      return CreateHashtableSizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<const VarHandleOptionsT *>(value);
      return CreateVarHandleOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<const ReadVariableOptionsT *>(value);
      return CreateReadVariableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<const AssignVariableOptionsT *>(value);
      return CreateAssignVariableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<const RandomOptionsT *>(value);
      return CreateRandomOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<const BucketizeOptionsT *>(value);
      return CreateBucketizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<const GeluOptionsT *>(value);
      return CreateGeluOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<const DynamicUpdateSliceOptionsT *>(value);
      return CreateDynamicUpdateSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnsortedSegmentProdOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentProdOptionsT *>(value);
      return CreateUnsortedSegmentProdOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentMaxOptionsT *>(value);
      return CreateUnsortedSegmentMaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnsortedSegmentMinOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentMinOptionsT *>(value);
      return CreateUnsortedSegmentMinOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnsortedSegmentSumOptions: {
      auto ptr = reinterpret_cast<const UnsortedSegmentSumOptionsT *>(value);
      return CreateUnsortedSegmentSumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ATan2Options: {
      auto ptr = reinterpret_cast<const ATan2OptionsT *>(value);
      return CreateATan2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SignOptions: {
      auto ptr = reinterpret_cast<const SignOptionsT *>(value);
      return CreateSignOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BitcastOptions: {
      auto ptr = reinterpret_cast<const BitcastOptionsT *>(value);
      return CreateBitcastOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BitwiseXorOptions: {
      auto ptr = reinterpret_cast<const BitwiseXorOptionsT *>(value);
      return CreateBitwiseXorOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RightShiftOptions: {
      auto ptr = reinterpret_cast<const RightShiftOptionsT *>(value);
      return CreateRightShiftOptions(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BuiltinOptionsUnion::BuiltinOptionsUnion(const BuiltinOptionsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      value = new Conv2DOptionsT(*reinterpret_cast<Conv2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      value = new DepthwiseConv2DOptionsT(*reinterpret_cast<DepthwiseConv2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      value = new ConcatEmbeddingsOptionsT(*reinterpret_cast<ConcatEmbeddingsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LSHProjectionOptions: {
      value = new LSHProjectionOptionsT(*reinterpret_cast<LSHProjectionOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Pool2DOptions: {
      value = new Pool2DOptionsT(*reinterpret_cast<Pool2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SVDFOptions: {
      value = new SVDFOptionsT(*reinterpret_cast<SVDFOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RNNOptions: {
      value = new RNNOptionsT(*reinterpret_cast<RNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FullyConnectedOptions: {
      value = new FullyConnectedOptionsT(*reinterpret_cast<FullyConnectedOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SoftmaxOptions: {
      value = new SoftmaxOptionsT(*reinterpret_cast<SoftmaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ConcatenationOptions: {
      value = new ConcatenationOptionsT(*reinterpret_cast<ConcatenationOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AddOptions: {
      value = new AddOptionsT(*reinterpret_cast<AddOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_L2NormOptions: {
      value = new L2NormOptionsT(*reinterpret_cast<L2NormOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      value = new LocalResponseNormalizationOptionsT(*reinterpret_cast<LocalResponseNormalizationOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LSTMOptions: {
      value = new LSTMOptionsT(*reinterpret_cast<LSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      value = new ResizeBilinearOptionsT(*reinterpret_cast<ResizeBilinearOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CallOptions: {
      value = new CallOptionsT(*reinterpret_cast<CallOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReshapeOptions: {
      value = new ReshapeOptionsT(*reinterpret_cast<ReshapeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SkipGramOptions: {
      value = new SkipGramOptionsT(*reinterpret_cast<SkipGramOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      value = new SpaceToDepthOptionsT(*reinterpret_cast<SpaceToDepthOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      value = new EmbeddingLookupSparseOptionsT(*reinterpret_cast<EmbeddingLookupSparseOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MulOptions: {
      value = new MulOptionsT(*reinterpret_cast<MulOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PadOptions: {
      value = new PadOptionsT(*reinterpret_cast<PadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GatherOptions: {
      value = new GatherOptionsT(*reinterpret_cast<GatherOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      value = new BatchToSpaceNDOptionsT(*reinterpret_cast<BatchToSpaceNDOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      value = new SpaceToBatchNDOptionsT(*reinterpret_cast<SpaceToBatchNDOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TransposeOptions: {
      value = new TransposeOptionsT(*reinterpret_cast<TransposeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReducerOptions: {
      value = new ReducerOptionsT(*reinterpret_cast<ReducerOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SubOptions: {
      value = new SubOptionsT(*reinterpret_cast<SubOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DivOptions: {
      value = new DivOptionsT(*reinterpret_cast<DivOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SqueezeOptions: {
      value = new SqueezeOptionsT(*reinterpret_cast<SqueezeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SequenceRNNOptions: {
      value = new SequenceRNNOptionsT(*reinterpret_cast<SequenceRNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_StridedSliceOptions: {
      value = new StridedSliceOptionsT(*reinterpret_cast<StridedSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ExpOptions: {
      value = new ExpOptionsT(*reinterpret_cast<ExpOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TopKV2Options: {
      value = new TopKV2OptionsT(*reinterpret_cast<TopKV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SplitOptions: {
      value = new SplitOptionsT(*reinterpret_cast<SplitOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      value = new LogSoftmaxOptionsT(*reinterpret_cast<LogSoftmaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CastOptions: {
      value = new CastOptionsT(*reinterpret_cast<CastOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DequantizeOptions: {
      value = new DequantizeOptionsT(*reinterpret_cast<DequantizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      value = new MaximumMinimumOptionsT(*reinterpret_cast<MaximumMinimumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ArgMaxOptions: {
      value = new ArgMaxOptionsT(*reinterpret_cast<ArgMaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LessOptions: {
      value = new LessOptionsT(*reinterpret_cast<LessOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NegOptions: {
      value = new NegOptionsT(*reinterpret_cast<NegOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PadV2Options: {
      value = new PadV2OptionsT(*reinterpret_cast<PadV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GreaterOptions: {
      value = new GreaterOptionsT(*reinterpret_cast<GreaterOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GreaterEqualOptions: {
      value = new GreaterEqualOptionsT(*reinterpret_cast<GreaterEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LessEqualOptions: {
      value = new LessEqualOptionsT(*reinterpret_cast<LessEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SelectOptions: {
      value = new SelectOptionsT(*reinterpret_cast<SelectOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SliceOptions: {
      value = new SliceOptionsT(*reinterpret_cast<SliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TransposeConvOptions: {
      value = new TransposeConvOptionsT(*reinterpret_cast<TransposeConvOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SparseToDenseOptions: {
      value = new SparseToDenseOptionsT(*reinterpret_cast<SparseToDenseOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TileOptions: {
      value = new TileOptionsT(*reinterpret_cast<TileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ExpandDimsOptions: {
      value = new ExpandDimsOptionsT(*reinterpret_cast<ExpandDimsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_EqualOptions: {
      value = new EqualOptionsT(*reinterpret_cast<EqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NotEqualOptions: {
      value = new NotEqualOptionsT(*reinterpret_cast<NotEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ShapeOptions: {
      value = new ShapeOptionsT(*reinterpret_cast<ShapeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PowOptions: {
      value = new PowOptionsT(*reinterpret_cast<PowOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ArgMinOptions: {
      value = new ArgMinOptionsT(*reinterpret_cast<ArgMinOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FakeQuantOptions: {
      value = new FakeQuantOptionsT(*reinterpret_cast<FakeQuantOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PackOptions: {
      value = new PackOptionsT(*reinterpret_cast<PackOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalOrOptions: {
      value = new LogicalOrOptionsT(*reinterpret_cast<LogicalOrOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_OneHotOptions: {
      value = new OneHotOptionsT(*reinterpret_cast<OneHotOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalAndOptions: {
      value = new LogicalAndOptionsT(*reinterpret_cast<LogicalAndOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalNotOptions: {
      value = new LogicalNotOptionsT(*reinterpret_cast<LogicalNotOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnpackOptions: {
      value = new UnpackOptionsT(*reinterpret_cast<UnpackOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FloorDivOptions: {
      value = new FloorDivOptionsT(*reinterpret_cast<FloorDivOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SquareOptions: {
      value = new SquareOptionsT(*reinterpret_cast<SquareOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ZerosLikeOptions: {
      value = new ZerosLikeOptionsT(*reinterpret_cast<ZerosLikeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FillOptions: {
      value = new FillOptionsT(*reinterpret_cast<FillOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      value = new BidirectionalSequenceLSTMOptionsT(*reinterpret_cast<BidirectionalSequenceLSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      value = new BidirectionalSequenceRNNOptionsT(*reinterpret_cast<BidirectionalSequenceRNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      value = new UnidirectionalSequenceLSTMOptionsT(*reinterpret_cast<UnidirectionalSequenceLSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FloorModOptions: {
      value = new FloorModOptionsT(*reinterpret_cast<FloorModOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RangeOptions: {
      value = new RangeOptionsT(*reinterpret_cast<RangeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      value = new ResizeNearestNeighborOptionsT(*reinterpret_cast<ResizeNearestNeighborOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LeakyReluOptions: {
      value = new LeakyReluOptionsT(*reinterpret_cast<LeakyReluOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      value = new SquaredDifferenceOptionsT(*reinterpret_cast<SquaredDifferenceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MirrorPadOptions: {
      value = new MirrorPadOptionsT(*reinterpret_cast<MirrorPadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AbsOptions: {
      value = new AbsOptionsT(*reinterpret_cast<AbsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SplitVOptions: {
      value = new SplitVOptionsT(*reinterpret_cast<SplitVOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UniqueOptions: {
      value = new UniqueOptionsT(*reinterpret_cast<UniqueOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReverseV2Options: {
      value = new ReverseV2OptionsT(*reinterpret_cast<ReverseV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AddNOptions: {
      value = new AddNOptionsT(*reinterpret_cast<AddNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GatherNdOptions: {
      value = new GatherNdOptionsT(*reinterpret_cast<GatherNdOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CosOptions: {
      value = new CosOptionsT(*reinterpret_cast<CosOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_WhereOptions: {
      value = new WhereOptionsT(*reinterpret_cast<WhereOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RankOptions: {
      value = new RankOptionsT(*reinterpret_cast<RankOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      value = new ReverseSequenceOptionsT(*reinterpret_cast<ReverseSequenceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MatrixDiagOptions: {
      value = new MatrixDiagOptionsT(*reinterpret_cast<MatrixDiagOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_QuantizeOptions: {
      value = new QuantizeOptionsT(*reinterpret_cast<QuantizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      value = new MatrixSetDiagOptionsT(*reinterpret_cast<MatrixSetDiagOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HardSwishOptions: {
      value = new HardSwishOptionsT(*reinterpret_cast<HardSwishOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_IfOptions: {
      value = new IfOptionsT(*reinterpret_cast<IfOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_WhileOptions: {
      value = new WhileOptionsT(*reinterpret_cast<WhileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      value = new DepthToSpaceOptionsT(*reinterpret_cast<DepthToSpaceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      value = new NonMaxSuppressionV4OptionsT(*reinterpret_cast<NonMaxSuppressionV4OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      value = new NonMaxSuppressionV5OptionsT(*reinterpret_cast<NonMaxSuppressionV5OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ScatterNdOptions: {
      value = new ScatterNdOptionsT(*reinterpret_cast<ScatterNdOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SelectV2Options: {
      value = new SelectV2OptionsT(*reinterpret_cast<SelectV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DensifyOptions: {
      value = new DensifyOptionsT(*reinterpret_cast<DensifyOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SegmentSumOptions: {
      value = new SegmentSumOptionsT(*reinterpret_cast<SegmentSumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BatchMatMulOptions: {
      value = new BatchMatMulOptionsT(*reinterpret_cast<BatchMatMulOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CumsumOptions: {
      value = new CumsumOptionsT(*reinterpret_cast<CumsumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CallOnceOptions: {
      value = new CallOnceOptionsT(*reinterpret_cast<CallOnceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BroadcastToOptions: {
      value = new BroadcastToOptionsT(*reinterpret_cast<BroadcastToOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Rfft2dOptions: {
      value = new Rfft2dOptionsT(*reinterpret_cast<Rfft2dOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Conv3DOptions: {
      value = new Conv3DOptionsT(*reinterpret_cast<Conv3DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableOptions: {
      value = new HashtableOptionsT(*reinterpret_cast<HashtableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableFindOptions: {
      value = new HashtableFindOptionsT(*reinterpret_cast<HashtableFindOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableImportOptions: {
      value = new HashtableImportOptionsT(*reinterpret_cast<HashtableImportOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableSizeOptions: {
      value = new HashtableSizeOptionsT(*reinterpret_cast<HashtableSizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_VarHandleOptions: {
      value = new VarHandleOptionsT(*reinterpret_cast<VarHandleOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReadVariableOptions: {
      value = new ReadVariableOptionsT(*reinterpret_cast<ReadVariableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AssignVariableOptions: {
      value = new AssignVariableOptionsT(*reinterpret_cast<AssignVariableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RandomOptions: {
      value = new RandomOptionsT(*reinterpret_cast<RandomOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BucketizeOptions: {
      value = new BucketizeOptionsT(*reinterpret_cast<BucketizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GeluOptions: {
      value = new GeluOptionsT(*reinterpret_cast<GeluOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      value = new DynamicUpdateSliceOptionsT(*reinterpret_cast<DynamicUpdateSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnsortedSegmentProdOptions: {
      value = new UnsortedSegmentProdOptionsT(*reinterpret_cast<UnsortedSegmentProdOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions: {
      value = new UnsortedSegmentMaxOptionsT(*reinterpret_cast<UnsortedSegmentMaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnsortedSegmentMinOptions: {
      value = new UnsortedSegmentMinOptionsT(*reinterpret_cast<UnsortedSegmentMinOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnsortedSegmentSumOptions: {
      value = new UnsortedSegmentSumOptionsT(*reinterpret_cast<UnsortedSegmentSumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ATan2Options: {
      value = new ATan2OptionsT(*reinterpret_cast<ATan2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SignOptions: {
      value = new SignOptionsT(*reinterpret_cast<SignOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BitcastOptions: {
      value = new BitcastOptionsT(*reinterpret_cast<BitcastOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BitwiseXorOptions: {
      value = new BitwiseXorOptionsT(*reinterpret_cast<BitwiseXorOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RightShiftOptions: {
      value = new RightShiftOptionsT(*reinterpret_cast<RightShiftOptionsT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BuiltinOptionsUnion::Reset() {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<Conv2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<DepthwiseConv2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<ConcatEmbeddingsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<LSHProjectionOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<Pool2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<SVDFOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<RNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<FullyConnectedOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<SoftmaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<ConcatenationOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<AddOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<L2NormOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<LocalResponseNormalizationOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<LSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<ResizeBilinearOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<CallOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<ReshapeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<SkipGramOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<SpaceToDepthOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<EmbeddingLookupSparseOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<MulOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<PadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<GatherOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<BatchToSpaceNDOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<SpaceToBatchNDOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<TransposeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<ReducerOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<SubOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<DivOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<SqueezeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<SequenceRNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<StridedSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<ExpOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<TopKV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<SplitOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<LogSoftmaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<CastOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<DequantizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<MaximumMinimumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<ArgMaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<LessOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<NegOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<PadV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<GreaterOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<GreaterEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<LessEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<SelectOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<SliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<TransposeConvOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<SparseToDenseOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<TileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<ExpandDimsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<EqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<NotEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<ShapeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<PowOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<ArgMinOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<FakeQuantOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<PackOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<LogicalOrOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<OneHotOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<LogicalAndOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<LogicalNotOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<UnpackOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<FloorDivOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<SquareOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<ZerosLikeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<FillOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<BidirectionalSequenceLSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<BidirectionalSequenceRNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<UnidirectionalSequenceLSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<FloorModOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<RangeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<ResizeNearestNeighborOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<LeakyReluOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<SquaredDifferenceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<MirrorPadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<AbsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<SplitVOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<UniqueOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<ReverseV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<AddNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<GatherNdOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<CosOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<WhereOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<RankOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<ReverseSequenceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<MatrixDiagOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<QuantizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<MatrixSetDiagOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<HardSwishOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<IfOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<WhileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<DepthToSpaceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<NonMaxSuppressionV4OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<NonMaxSuppressionV5OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<ScatterNdOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<SelectV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<DensifyOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<SegmentSumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<BatchMatMulOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<CumsumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<CallOnceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<BroadcastToOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<Rfft2dOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<Conv3DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<HashtableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<HashtableFindOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<HashtableImportOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<HashtableSizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<VarHandleOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<ReadVariableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<AssignVariableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<RandomOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<BucketizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<GeluOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<DynamicUpdateSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnsortedSegmentProdOptions: {
      auto ptr = reinterpret_cast<UnsortedSegmentProdOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions: {
      auto ptr = reinterpret_cast<UnsortedSegmentMaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnsortedSegmentMinOptions: {
      auto ptr = reinterpret_cast<UnsortedSegmentMinOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnsortedSegmentSumOptions: {
      auto ptr = reinterpret_cast<UnsortedSegmentSumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ATan2Options: {
      auto ptr = reinterpret_cast<ATan2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SignOptions: {
      auto ptr = reinterpret_cast<SignOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BitcastOptions: {
      auto ptr = reinterpret_cast<BitcastOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BitwiseXorOptions: {
      auto ptr = reinterpret_cast<BitwiseXorOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RightShiftOptions: {
      auto ptr = reinterpret_cast<RightShiftOptionsT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BuiltinOptions_NONE;
}

inline bool VerifyBuiltinOptions2(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions2 type) {
  switch (type) {
    case BuiltinOptions2_NONE: {
      return true;
    }
    case BuiltinOptions2_StablehloConcatenateOptions: {
      auto ptr = reinterpret_cast<const StablehloConcatenateOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions: {
      auto ptr = reinterpret_cast<const StablehloBroadcastInDimOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloSliceOptions: {
      auto ptr = reinterpret_cast<const StablehloSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloConvolutionOptions: {
      auto ptr = reinterpret_cast<const StablehloConvolutionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloCustomCallOptions: {
      auto ptr = reinterpret_cast<const StablehloCustomCallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloReduceOptions: {
      auto ptr = reinterpret_cast<const StablehloReduceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloScatterOptions: {
      auto ptr = reinterpret_cast<const StablehloScatterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloCompareOptions: {
      auto ptr = reinterpret_cast<const StablehloCompareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions: {
      auto ptr = reinterpret_cast<const StablehloDynamicSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloPadOptions: {
      auto ptr = reinterpret_cast<const StablehloPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloIotaOptions: {
      auto ptr = reinterpret_cast<const StablehloIotaOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloDotGeneralOptions: {
      auto ptr = reinterpret_cast<const StablehloDotGeneralOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloReduceWindowOptions: {
      auto ptr = reinterpret_cast<const StablehloReduceWindowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloSortOptions: {
      auto ptr = reinterpret_cast<const StablehloSortOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloWhileOptions: {
      auto ptr = reinterpret_cast<const StablehloWhileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloGatherOptions: {
      auto ptr = reinterpret_cast<const StablehloGatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloTransposeOptions: {
      auto ptr = reinterpret_cast<const StablehloTransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_DilateOptions: {
      auto ptr = reinterpret_cast<const DilateOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions: {
      auto ptr = reinterpret_cast<const StablehloRngBitGeneratorOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_ReduceWindowOptions: {
      auto ptr = reinterpret_cast<const ReduceWindowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StableHLOCompositeOptions: {
      auto ptr = reinterpret_cast<const StableHLOCompositeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloShiftLeftOptions: {
      auto ptr = reinterpret_cast<const StablehloShiftLeftOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloCaseOptions: {
      auto ptr = reinterpret_cast<const StablehloCaseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyBuiltinOptions2Vector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBuiltinOptions2(
        verifier,  values->Get(i), types->GetEnum<BuiltinOptions2>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BuiltinOptions2Union::UnPack(const void *obj, BuiltinOptions2 type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case BuiltinOptions2_StablehloConcatenateOptions: {
      auto ptr = reinterpret_cast<const StablehloConcatenateOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions: {
      auto ptr = reinterpret_cast<const StablehloBroadcastInDimOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloSliceOptions: {
      auto ptr = reinterpret_cast<const StablehloSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloConvolutionOptions: {
      auto ptr = reinterpret_cast<const StablehloConvolutionOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloCustomCallOptions: {
      auto ptr = reinterpret_cast<const StablehloCustomCallOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloReduceOptions: {
      auto ptr = reinterpret_cast<const StablehloReduceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloScatterOptions: {
      auto ptr = reinterpret_cast<const StablehloScatterOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloCompareOptions: {
      auto ptr = reinterpret_cast<const StablehloCompareOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions: {
      auto ptr = reinterpret_cast<const StablehloDynamicSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloPadOptions: {
      auto ptr = reinterpret_cast<const StablehloPadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloIotaOptions: {
      auto ptr = reinterpret_cast<const StablehloIotaOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloDotGeneralOptions: {
      auto ptr = reinterpret_cast<const StablehloDotGeneralOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloReduceWindowOptions: {
      auto ptr = reinterpret_cast<const StablehloReduceWindowOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloSortOptions: {
      auto ptr = reinterpret_cast<const StablehloSortOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloWhileOptions: {
      auto ptr = reinterpret_cast<const StablehloWhileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloGatherOptions: {
      auto ptr = reinterpret_cast<const StablehloGatherOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloTransposeOptions: {
      auto ptr = reinterpret_cast<const StablehloTransposeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_DilateOptions: {
      auto ptr = reinterpret_cast<const DilateOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions: {
      auto ptr = reinterpret_cast<const StablehloRngBitGeneratorOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_ReduceWindowOptions: {
      auto ptr = reinterpret_cast<const ReduceWindowOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StableHLOCompositeOptions: {
      auto ptr = reinterpret_cast<const StableHLOCompositeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloShiftLeftOptions: {
      auto ptr = reinterpret_cast<const StablehloShiftLeftOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloCaseOptions: {
      auto ptr = reinterpret_cast<const StablehloCaseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> BuiltinOptions2Union::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case BuiltinOptions2_StablehloConcatenateOptions: {
      auto ptr = reinterpret_cast<const StablehloConcatenateOptionsT *>(value);
      return CreateStablehloConcatenateOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions: {
      auto ptr = reinterpret_cast<const StablehloBroadcastInDimOptionsT *>(value);
      return CreateStablehloBroadcastInDimOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloSliceOptions: {
      auto ptr = reinterpret_cast<const StablehloSliceOptionsT *>(value);
      return CreateStablehloSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloConvolutionOptions: {
      auto ptr = reinterpret_cast<const StablehloConvolutionOptionsT *>(value);
      return CreateStablehloConvolutionOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloCustomCallOptions: {
      auto ptr = reinterpret_cast<const StablehloCustomCallOptionsT *>(value);
      return CreateStablehloCustomCallOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloReduceOptions: {
      auto ptr = reinterpret_cast<const StablehloReduceOptionsT *>(value);
      return CreateStablehloReduceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloScatterOptions: {
      auto ptr = reinterpret_cast<const StablehloScatterOptionsT *>(value);
      return CreateStablehloScatterOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloCompareOptions: {
      auto ptr = reinterpret_cast<const StablehloCompareOptionsT *>(value);
      return CreateStablehloCompareOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions: {
      auto ptr = reinterpret_cast<const StablehloDynamicSliceOptionsT *>(value);
      return CreateStablehloDynamicSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloPadOptions: {
      auto ptr = reinterpret_cast<const StablehloPadOptionsT *>(value);
      return CreateStablehloPadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloIotaOptions: {
      auto ptr = reinterpret_cast<const StablehloIotaOptionsT *>(value);
      return CreateStablehloIotaOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloDotGeneralOptions: {
      auto ptr = reinterpret_cast<const StablehloDotGeneralOptionsT *>(value);
      return CreateStablehloDotGeneralOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloReduceWindowOptions: {
      auto ptr = reinterpret_cast<const StablehloReduceWindowOptionsT *>(value);
      return CreateStablehloReduceWindowOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloSortOptions: {
      auto ptr = reinterpret_cast<const StablehloSortOptionsT *>(value);
      return CreateStablehloSortOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloWhileOptions: {
      auto ptr = reinterpret_cast<const StablehloWhileOptionsT *>(value);
      return CreateStablehloWhileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloGatherOptions: {
      auto ptr = reinterpret_cast<const StablehloGatherOptionsT *>(value);
      return CreateStablehloGatherOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloTransposeOptions: {
      auto ptr = reinterpret_cast<const StablehloTransposeOptionsT *>(value);
      return CreateStablehloTransposeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_DilateOptions: {
      auto ptr = reinterpret_cast<const DilateOptionsT *>(value);
      return CreateDilateOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions: {
      auto ptr = reinterpret_cast<const StablehloRngBitGeneratorOptionsT *>(value);
      return CreateStablehloRngBitGeneratorOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_ReduceWindowOptions: {
      auto ptr = reinterpret_cast<const ReduceWindowOptionsT *>(value);
      return CreateReduceWindowOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StableHLOCompositeOptions: {
      auto ptr = reinterpret_cast<const StableHLOCompositeOptionsT *>(value);
      return CreateStableHLOCompositeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloShiftLeftOptions: {
      auto ptr = reinterpret_cast<const StablehloShiftLeftOptionsT *>(value);
      return CreateStablehloShiftLeftOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloCaseOptions: {
      auto ptr = reinterpret_cast<const StablehloCaseOptionsT *>(value);
      return CreateStablehloCaseOptions(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BuiltinOptions2Union::BuiltinOptions2Union(const BuiltinOptions2Union &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case BuiltinOptions2_StablehloConcatenateOptions: {
      value = new StablehloConcatenateOptionsT(*reinterpret_cast<StablehloConcatenateOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions: {
      value = new StablehloBroadcastInDimOptionsT(*reinterpret_cast<StablehloBroadcastInDimOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloSliceOptions: {
      value = new StablehloSliceOptionsT(*reinterpret_cast<StablehloSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloConvolutionOptions: {
      value = new StablehloConvolutionOptionsT(*reinterpret_cast<StablehloConvolutionOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloCustomCallOptions: {
      value = new StablehloCustomCallOptionsT(*reinterpret_cast<StablehloCustomCallOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloReduceOptions: {
      value = new StablehloReduceOptionsT(*reinterpret_cast<StablehloReduceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloScatterOptions: {
      value = new StablehloScatterOptionsT(*reinterpret_cast<StablehloScatterOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloCompareOptions: {
      value = new StablehloCompareOptionsT(*reinterpret_cast<StablehloCompareOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions: {
      value = new StablehloDynamicSliceOptionsT(*reinterpret_cast<StablehloDynamicSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloPadOptions: {
      value = new StablehloPadOptionsT(*reinterpret_cast<StablehloPadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloIotaOptions: {
      value = new StablehloIotaOptionsT(*reinterpret_cast<StablehloIotaOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloDotGeneralOptions: {
      value = new StablehloDotGeneralOptionsT(*reinterpret_cast<StablehloDotGeneralOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloReduceWindowOptions: {
      value = new StablehloReduceWindowOptionsT(*reinterpret_cast<StablehloReduceWindowOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloSortOptions: {
      value = new StablehloSortOptionsT(*reinterpret_cast<StablehloSortOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloWhileOptions: {
      value = new StablehloWhileOptionsT(*reinterpret_cast<StablehloWhileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloGatherOptions: {
      value = new StablehloGatherOptionsT(*reinterpret_cast<StablehloGatherOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloTransposeOptions: {
      value = new StablehloTransposeOptionsT(*reinterpret_cast<StablehloTransposeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_DilateOptions: {
      value = new DilateOptionsT(*reinterpret_cast<DilateOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions: {
      value = new StablehloRngBitGeneratorOptionsT(*reinterpret_cast<StablehloRngBitGeneratorOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_ReduceWindowOptions: {
      value = new ReduceWindowOptionsT(*reinterpret_cast<ReduceWindowOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StableHLOCompositeOptions: {
      value = new StableHLOCompositeOptionsT(*reinterpret_cast<StableHLOCompositeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloShiftLeftOptions: {
      value = new StablehloShiftLeftOptionsT(*reinterpret_cast<StablehloShiftLeftOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloCaseOptions: {
      value = new StablehloCaseOptionsT(*reinterpret_cast<StablehloCaseOptionsT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BuiltinOptions2Union::Reset() {
  switch (type) {
    case BuiltinOptions2_StablehloConcatenateOptions: {
      auto ptr = reinterpret_cast<StablehloConcatenateOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions: {
      auto ptr = reinterpret_cast<StablehloBroadcastInDimOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloSliceOptions: {
      auto ptr = reinterpret_cast<StablehloSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloConvolutionOptions: {
      auto ptr = reinterpret_cast<StablehloConvolutionOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloCustomCallOptions: {
      auto ptr = reinterpret_cast<StablehloCustomCallOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloReduceOptions: {
      auto ptr = reinterpret_cast<StablehloReduceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloScatterOptions: {
      auto ptr = reinterpret_cast<StablehloScatterOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloCompareOptions: {
      auto ptr = reinterpret_cast<StablehloCompareOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions: {
      auto ptr = reinterpret_cast<StablehloDynamicSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloPadOptions: {
      auto ptr = reinterpret_cast<StablehloPadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloIotaOptions: {
      auto ptr = reinterpret_cast<StablehloIotaOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloDotGeneralOptions: {
      auto ptr = reinterpret_cast<StablehloDotGeneralOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloReduceWindowOptions: {
      auto ptr = reinterpret_cast<StablehloReduceWindowOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloSortOptions: {
      auto ptr = reinterpret_cast<StablehloSortOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloWhileOptions: {
      auto ptr = reinterpret_cast<StablehloWhileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloGatherOptions: {
      auto ptr = reinterpret_cast<StablehloGatherOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloTransposeOptions: {
      auto ptr = reinterpret_cast<StablehloTransposeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_DilateOptions: {
      auto ptr = reinterpret_cast<DilateOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions: {
      auto ptr = reinterpret_cast<StablehloRngBitGeneratorOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_ReduceWindowOptions: {
      auto ptr = reinterpret_cast<ReduceWindowOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StableHLOCompositeOptions: {
      auto ptr = reinterpret_cast<StableHLOCompositeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloShiftLeftOptions: {
      auto ptr = reinterpret_cast<StablehloShiftLeftOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloCaseOptions: {
      auto ptr = reinterpret_cast<StablehloCaseOptionsT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BuiltinOptions2_NONE;
}

inline const flatbuffers::TypeTable *TensorTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "FLOAT32",
    "FLOAT16",
    "INT32",
    "UINT8",
    "INT64",
    "STRING",
    "BOOL",
    "INT16",
    "COMPLEX64",
    "INT8",
    "FLOAT64",
    "COMPLEX128",
    "UINT64",
    "RESOURCE",
    "VARIANT",
    "UINT32",
    "UINT16",
    "INT4",
    "BFLOAT16"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 19, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantizationDetailsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CustomQuantizationTypeTable,
    BlockwiseQuantizationTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "CustomQuantization",
    "BlockwiseQuantization"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DimensionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DimensionTypeTypeTable
  };
  static const char * const names[] = {
    "DENSE",
    "SPARSE_CSR"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparseIndexVectorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Int32VectorTypeTable,
    Uint16VectorTypeTable,
    Uint8VectorTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Int32Vector",
    "Uint16Vector",
    "Uint8Vector"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BuiltinOperatorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BuiltinOperatorTypeTable
  };
  static const char * const names[] = {
    "ADD",
    "AVERAGE_POOL_2D",
    "CONCATENATION",
    "CONV_2D",
    "DEPTHWISE_CONV_2D",
    "DEPTH_TO_SPACE",
    "DEQUANTIZE",
    "EMBEDDING_LOOKUP",
    "FLOOR",
    "FULLY_CONNECTED",
    "HASHTABLE_LOOKUP",
    "L2_NORMALIZATION",
    "L2_POOL_2D",
    "LOCAL_RESPONSE_NORMALIZATION",
    "LOGISTIC",
    "LSH_PROJECTION",
    "LSTM",
    "MAX_POOL_2D",
    "MUL",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "RESHAPE",
    "RESIZE_BILINEAR",
    "RNN",
    "SOFTMAX",
    "SPACE_TO_DEPTH",
    "SVDF",
    "TANH",
    "CONCAT_EMBEDDINGS",
    "SKIP_GRAM",
    "CALL",
    "CUSTOM",
    "EMBEDDING_LOOKUP_SPARSE",
    "PAD",
    "UNIDIRECTIONAL_SEQUENCE_RNN",
    "GATHER",
    "BATCH_TO_SPACE_ND",
    "SPACE_TO_BATCH_ND",
    "TRANSPOSE",
    "MEAN",
    "SUB",
    "DIV",
    "SQUEEZE",
    "UNIDIRECTIONAL_SEQUENCE_LSTM",
    "STRIDED_SLICE",
    "BIDIRECTIONAL_SEQUENCE_RNN",
    "EXP",
    "TOPK_V2",
    "SPLIT",
    "LOG_SOFTMAX",
    "DELEGATE",
    "BIDIRECTIONAL_SEQUENCE_LSTM",
    "CAST",
    "PRELU",
    "MAXIMUM",
    "ARG_MAX",
    "MINIMUM",
    "LESS",
    "NEG",
    "PADV2",
    "GREATER",
    "GREATER_EQUAL",
    "LESS_EQUAL",
    "SELECT",
    "SLICE",
    "SIN",
    "TRANSPOSE_CONV",
    "SPARSE_TO_DENSE",
    "TILE",
    "EXPAND_DIMS",
    "EQUAL",
    "NOT_EQUAL",
    "LOG",
    "SUM",
    "SQRT",
    "RSQRT",
    "SHAPE",
    "POW",
    "ARG_MIN",
    "FAKE_QUANT",
    "REDUCE_PROD",
    "REDUCE_MAX",
    "PACK",
    "LOGICAL_OR",
    "ONE_HOT",
    "LOGICAL_AND",
    "LOGICAL_NOT",
    "UNPACK",
    "REDUCE_MIN",
    "FLOOR_DIV",
    "REDUCE_ANY",
    "SQUARE",
    "ZEROS_LIKE",
    "FILL",
    "FLOOR_MOD",
    "RANGE",
    "RESIZE_NEAREST_NEIGHBOR",
    "LEAKY_RELU",
    "SQUARED_DIFFERENCE",
    "MIRROR_PAD",
    "ABS",
    "SPLIT_V",
    "UNIQUE",
    "CEIL",
    "REVERSE_V2",
    "ADD_N",
    "GATHER_ND",
    "COS",
    "WHERE",
    "RANK",
    "ELU",
    "REVERSE_SEQUENCE",
    "MATRIX_DIAG",
    "QUANTIZE",
    "MATRIX_SET_DIAG",
    "ROUND",
    "HARD_SWISH",
    "IF",
    "WHILE",
    "NON_MAX_SUPPRESSION_V4",
    "NON_MAX_SUPPRESSION_V5",
    "SCATTER_ND",
    "SELECT_V2",
    "DENSIFY",
    "SEGMENT_SUM",
    "BATCH_MATMUL",
    "PLACEHOLDER_FOR_GREATER_OP_CODES",
    "CUMSUM",
    "CALL_ONCE",
    "BROADCAST_TO",
    "RFFT2D",
    "CONV_3D",
    "IMAG",
    "REAL",
    "COMPLEX_ABS",
    "HASHTABLE",
    "HASHTABLE_FIND",
    "HASHTABLE_IMPORT",
    "HASHTABLE_SIZE",
    "REDUCE_ALL",
    "CONV_3D_TRANSPOSE",
    "VAR_HANDLE",
    "READ_VARIABLE",
    "ASSIGN_VARIABLE",
    "BROADCAST_ARGS",
    "RANDOM_STANDARD_NORMAL",
    "BUCKETIZE",
    "RANDOM_UNIFORM",
    "MULTINOMIAL",
    "GELU",
    "DYNAMIC_UPDATE_SLICE",
    "RELU_0_TO_1",
    "UNSORTED_SEGMENT_PROD",
    "UNSORTED_SEGMENT_MAX",
    "UNSORTED_SEGMENT_SUM",
    "ATAN2",
    "UNSORTED_SEGMENT_MIN",
    "SIGN",
    "BITCAST",
    "BITWISE_XOR",
    "RIGHT_SHIFT",
    "STABLEHLO_LOGISTIC",
    "STABLEHLO_ADD",
    "STABLEHLO_DIVIDE",
    "STABLEHLO_MULTIPLY",
    "STABLEHLO_MAXIMUM",
    "STABLEHLO_RESHAPE",
    "STABLEHLO_CLAMP",
    "STABLEHLO_CONCATENATE",
    "STABLEHLO_BROADCAST_IN_DIM",
    "STABLEHLO_CONVOLUTION",
    "STABLEHLO_SLICE",
    "STABLEHLO_CUSTOM_CALL",
    "STABLEHLO_REDUCE",
    "STABLEHLO_ABS",
    "STABLEHLO_AND",
    "STABLEHLO_COSINE",
    "STABLEHLO_EXPONENTIAL",
    "STABLEHLO_FLOOR",
    "STABLEHLO_LOG",
    "STABLEHLO_MINIMUM",
    "STABLEHLO_NEGATE",
    "STABLEHLO_OR",
    "STABLEHLO_POWER",
    "STABLEHLO_REMAINDER",
    "STABLEHLO_RSQRT",
    "STABLEHLO_SELECT",
    "STABLEHLO_SUBTRACT",
    "STABLEHLO_TANH",
    "STABLEHLO_SCATTER",
    "STABLEHLO_COMPARE",
    "STABLEHLO_CONVERT",
    "STABLEHLO_DYNAMIC_SLICE",
    "STABLEHLO_DYNAMIC_UPDATE_SLICE",
    "STABLEHLO_PAD",
    "STABLEHLO_IOTA",
    "STABLEHLO_DOT_GENERAL",
    "STABLEHLO_REDUCE_WINDOW",
    "STABLEHLO_SORT",
    "STABLEHLO_WHILE",
    "STABLEHLO_GATHER",
    "STABLEHLO_TRANSPOSE",
    "DILATE",
    "STABLEHLO_RNG_BIT_GENERATOR",
    "REDUCE_WINDOW",
    "STABLEHLO_COMPOSITE",
    "STABLEHLO_SHIFT_LEFT",
    "STABLEHLO_CBRT",
    "STABLEHLO_CASE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 210, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BuiltinOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 },
    { flatbuffers::ET_SEQUENCE, 0, 29 },
    { flatbuffers::ET_SEQUENCE, 0, 30 },
    { flatbuffers::ET_SEQUENCE, 0, 31 },
    { flatbuffers::ET_SEQUENCE, 0, 32 },
    { flatbuffers::ET_SEQUENCE, 0, 33 },
    { flatbuffers::ET_SEQUENCE, 0, 34 },
    { flatbuffers::ET_SEQUENCE, 0, 35 },
    { flatbuffers::ET_SEQUENCE, 0, 36 },
    { flatbuffers::ET_SEQUENCE, 0, 37 },
    { flatbuffers::ET_SEQUENCE, 0, 38 },
    { flatbuffers::ET_SEQUENCE, 0, 39 },
    { flatbuffers::ET_SEQUENCE, 0, 40 },
    { flatbuffers::ET_SEQUENCE, 0, 41 },
    { flatbuffers::ET_SEQUENCE, 0, 42 },
    { flatbuffers::ET_SEQUENCE, 0, 43 },
    { flatbuffers::ET_SEQUENCE, 0, 44 },
    { flatbuffers::ET_SEQUENCE, 0, 45 },
    { flatbuffers::ET_SEQUENCE, 0, 46 },
    { flatbuffers::ET_SEQUENCE, 0, 47 },
    { flatbuffers::ET_SEQUENCE, 0, 48 },
    { flatbuffers::ET_SEQUENCE, 0, 49 },
    { flatbuffers::ET_SEQUENCE, 0, 50 },
    { flatbuffers::ET_SEQUENCE, 0, 51 },
    { flatbuffers::ET_SEQUENCE, 0, 52 },
    { flatbuffers::ET_SEQUENCE, 0, 53 },
    { flatbuffers::ET_SEQUENCE, 0, 54 },
    { flatbuffers::ET_SEQUENCE, 0, 55 },
    { flatbuffers::ET_SEQUENCE, 0, 56 },
    { flatbuffers::ET_SEQUENCE, 0, 57 },
    { flatbuffers::ET_SEQUENCE, 0, 58 },
    { flatbuffers::ET_SEQUENCE, 0, 59 },
    { flatbuffers::ET_SEQUENCE, 0, 60 },
    { flatbuffers::ET_SEQUENCE, 0, 61 },
    { flatbuffers::ET_SEQUENCE, 0, 62 },
    { flatbuffers::ET_SEQUENCE, 0, 63 },
    { flatbuffers::ET_SEQUENCE, 0, 64 },
    { flatbuffers::ET_SEQUENCE, 0, 65 },
    { flatbuffers::ET_SEQUENCE, 0, 66 },
    { flatbuffers::ET_SEQUENCE, 0, 67 },
    { flatbuffers::ET_SEQUENCE, 0, 68 },
    { flatbuffers::ET_SEQUENCE, 0, 69 },
    { flatbuffers::ET_SEQUENCE, 0, 70 },
    { flatbuffers::ET_SEQUENCE, 0, 71 },
    { flatbuffers::ET_SEQUENCE, 0, 72 },
    { flatbuffers::ET_SEQUENCE, 0, 73 },
    { flatbuffers::ET_SEQUENCE, 0, 74 },
    { flatbuffers::ET_SEQUENCE, 0, 75 },
    { flatbuffers::ET_SEQUENCE, 0, 76 },
    { flatbuffers::ET_SEQUENCE, 0, 77 },
    { flatbuffers::ET_SEQUENCE, 0, 78 },
    { flatbuffers::ET_SEQUENCE, 0, 79 },
    { flatbuffers::ET_SEQUENCE, 0, 80 },
    { flatbuffers::ET_SEQUENCE, 0, 81 },
    { flatbuffers::ET_SEQUENCE, 0, 82 },
    { flatbuffers::ET_SEQUENCE, 0, 83 },
    { flatbuffers::ET_SEQUENCE, 0, 84 },
    { flatbuffers::ET_SEQUENCE, 0, 85 },
    { flatbuffers::ET_SEQUENCE, 0, 86 },
    { flatbuffers::ET_SEQUENCE, 0, 87 },
    { flatbuffers::ET_SEQUENCE, 0, 88 },
    { flatbuffers::ET_SEQUENCE, 0, 89 },
    { flatbuffers::ET_SEQUENCE, 0, 90 },
    { flatbuffers::ET_SEQUENCE, 0, 91 },
    { flatbuffers::ET_SEQUENCE, 0, 92 },
    { flatbuffers::ET_SEQUENCE, 0, 93 },
    { flatbuffers::ET_SEQUENCE, 0, 94 },
    { flatbuffers::ET_SEQUENCE, 0, 95 },
    { flatbuffers::ET_SEQUENCE, 0, 96 },
    { flatbuffers::ET_SEQUENCE, 0, 97 },
    { flatbuffers::ET_SEQUENCE, 0, 98 },
    { flatbuffers::ET_SEQUENCE, 0, 99 },
    { flatbuffers::ET_SEQUENCE, 0, 100 },
    { flatbuffers::ET_SEQUENCE, 0, 101 },
    { flatbuffers::ET_SEQUENCE, 0, 102 },
    { flatbuffers::ET_SEQUENCE, 0, 103 },
    { flatbuffers::ET_SEQUENCE, 0, 104 },
    { flatbuffers::ET_SEQUENCE, 0, 105 },
    { flatbuffers::ET_SEQUENCE, 0, 106 },
    { flatbuffers::ET_SEQUENCE, 0, 107 },
    { flatbuffers::ET_SEQUENCE, 0, 108 },
    { flatbuffers::ET_SEQUENCE, 0, 109 },
    { flatbuffers::ET_SEQUENCE, 0, 110 },
    { flatbuffers::ET_SEQUENCE, 0, 111 },
    { flatbuffers::ET_SEQUENCE, 0, 112 },
    { flatbuffers::ET_SEQUENCE, 0, 113 },
    { flatbuffers::ET_SEQUENCE, 0, 114 },
    { flatbuffers::ET_SEQUENCE, 0, 115 },
    { flatbuffers::ET_SEQUENCE, 0, 116 },
    { flatbuffers::ET_SEQUENCE, 0, 117 },
    { flatbuffers::ET_SEQUENCE, 0, 118 },
    { flatbuffers::ET_SEQUENCE, 0, 119 },
    { flatbuffers::ET_SEQUENCE, 0, 120 },
    { flatbuffers::ET_SEQUENCE, 0, 121 },
    { flatbuffers::ET_SEQUENCE, 0, 122 },
    { flatbuffers::ET_SEQUENCE, 0, 123 },
    { flatbuffers::ET_SEQUENCE, 0, 124 },
    { flatbuffers::ET_SEQUENCE, 0, 125 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Conv2DOptionsTypeTable,
    DepthwiseConv2DOptionsTypeTable,
    ConcatEmbeddingsOptionsTypeTable,
    LSHProjectionOptionsTypeTable,
    Pool2DOptionsTypeTable,
    SVDFOptionsTypeTable,
    RNNOptionsTypeTable,
    FullyConnectedOptionsTypeTable,
    SoftmaxOptionsTypeTable,
    ConcatenationOptionsTypeTable,
    AddOptionsTypeTable,
    L2NormOptionsTypeTable,
    LocalResponseNormalizationOptionsTypeTable,
    LSTMOptionsTypeTable,
    ResizeBilinearOptionsTypeTable,
    CallOptionsTypeTable,
    ReshapeOptionsTypeTable,
    SkipGramOptionsTypeTable,
    SpaceToDepthOptionsTypeTable,
    EmbeddingLookupSparseOptionsTypeTable,
    MulOptionsTypeTable,
    PadOptionsTypeTable,
    GatherOptionsTypeTable,
    BatchToSpaceNDOptionsTypeTable,
    SpaceToBatchNDOptionsTypeTable,
    TransposeOptionsTypeTable,
    ReducerOptionsTypeTable,
    SubOptionsTypeTable,
    DivOptionsTypeTable,
    SqueezeOptionsTypeTable,
    SequenceRNNOptionsTypeTable,
    StridedSliceOptionsTypeTable,
    ExpOptionsTypeTable,
    TopKV2OptionsTypeTable,
    SplitOptionsTypeTable,
    LogSoftmaxOptionsTypeTable,
    CastOptionsTypeTable,
    DequantizeOptionsTypeTable,
    MaximumMinimumOptionsTypeTable,
    ArgMaxOptionsTypeTable,
    LessOptionsTypeTable,
    NegOptionsTypeTable,
    PadV2OptionsTypeTable,
    GreaterOptionsTypeTable,
    GreaterEqualOptionsTypeTable,
    LessEqualOptionsTypeTable,
    SelectOptionsTypeTable,
    SliceOptionsTypeTable,
    TransposeConvOptionsTypeTable,
    SparseToDenseOptionsTypeTable,
    TileOptionsTypeTable,
    ExpandDimsOptionsTypeTable,
    EqualOptionsTypeTable,
    NotEqualOptionsTypeTable,
    ShapeOptionsTypeTable,
    PowOptionsTypeTable,
    ArgMinOptionsTypeTable,
    FakeQuantOptionsTypeTable,
    PackOptionsTypeTable,
    LogicalOrOptionsTypeTable,
    OneHotOptionsTypeTable,
    LogicalAndOptionsTypeTable,
    LogicalNotOptionsTypeTable,
    UnpackOptionsTypeTable,
    FloorDivOptionsTypeTable,
    SquareOptionsTypeTable,
    ZerosLikeOptionsTypeTable,
    FillOptionsTypeTable,
    BidirectionalSequenceLSTMOptionsTypeTable,
    BidirectionalSequenceRNNOptionsTypeTable,
    UnidirectionalSequenceLSTMOptionsTypeTable,
    FloorModOptionsTypeTable,
    RangeOptionsTypeTable,
    ResizeNearestNeighborOptionsTypeTable,
    LeakyReluOptionsTypeTable,
    SquaredDifferenceOptionsTypeTable,
    MirrorPadOptionsTypeTable,
    AbsOptionsTypeTable,
    SplitVOptionsTypeTable,
    UniqueOptionsTypeTable,
    ReverseV2OptionsTypeTable,
    AddNOptionsTypeTable,
    GatherNdOptionsTypeTable,
    CosOptionsTypeTable,
    WhereOptionsTypeTable,
    RankOptionsTypeTable,
    ReverseSequenceOptionsTypeTable,
    MatrixDiagOptionsTypeTable,
    QuantizeOptionsTypeTable,
    MatrixSetDiagOptionsTypeTable,
    HardSwishOptionsTypeTable,
    IfOptionsTypeTable,
    WhileOptionsTypeTable,
    DepthToSpaceOptionsTypeTable,
    NonMaxSuppressionV4OptionsTypeTable,
    NonMaxSuppressionV5OptionsTypeTable,
    ScatterNdOptionsTypeTable,
    SelectV2OptionsTypeTable,
    DensifyOptionsTypeTable,
    SegmentSumOptionsTypeTable,
    BatchMatMulOptionsTypeTable,
    CumsumOptionsTypeTable,
    CallOnceOptionsTypeTable,
    BroadcastToOptionsTypeTable,
    Rfft2dOptionsTypeTable,
    Conv3DOptionsTypeTable,
    HashtableOptionsTypeTable,
    HashtableFindOptionsTypeTable,
    HashtableImportOptionsTypeTable,
    HashtableSizeOptionsTypeTable,
    VarHandleOptionsTypeTable,
    ReadVariableOptionsTypeTable,
    AssignVariableOptionsTypeTable,
    RandomOptionsTypeTable,
    BucketizeOptionsTypeTable,
    GeluOptionsTypeTable,
    DynamicUpdateSliceOptionsTypeTable,
    UnsortedSegmentProdOptionsTypeTable,
    UnsortedSegmentMaxOptionsTypeTable,
    UnsortedSegmentMinOptionsTypeTable,
    UnsortedSegmentSumOptionsTypeTable,
    ATan2OptionsTypeTable,
    SignOptionsTypeTable,
    BitcastOptionsTypeTable,
    BitwiseXorOptionsTypeTable,
    RightShiftOptionsTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Conv2DOptions",
    "DepthwiseConv2DOptions",
    "ConcatEmbeddingsOptions",
    "LSHProjectionOptions",
    "Pool2DOptions",
    "SVDFOptions",
    "RNNOptions",
    "FullyConnectedOptions",
    "SoftmaxOptions",
    "ConcatenationOptions",
    "AddOptions",
    "L2NormOptions",
    "LocalResponseNormalizationOptions",
    "LSTMOptions",
    "ResizeBilinearOptions",
    "CallOptions",
    "ReshapeOptions",
    "SkipGramOptions",
    "SpaceToDepthOptions",
    "EmbeddingLookupSparseOptions",
    "MulOptions",
    "PadOptions",
    "GatherOptions",
    "BatchToSpaceNDOptions",
    "SpaceToBatchNDOptions",
    "TransposeOptions",
    "ReducerOptions",
    "SubOptions",
    "DivOptions",
    "SqueezeOptions",
    "SequenceRNNOptions",
    "StridedSliceOptions",
    "ExpOptions",
    "TopKV2Options",
    "SplitOptions",
    "LogSoftmaxOptions",
    "CastOptions",
    "DequantizeOptions",
    "MaximumMinimumOptions",
    "ArgMaxOptions",
    "LessOptions",
    "NegOptions",
    "PadV2Options",
    "GreaterOptions",
    "GreaterEqualOptions",
    "LessEqualOptions",
    "SelectOptions",
    "SliceOptions",
    "TransposeConvOptions",
    "SparseToDenseOptions",
    "TileOptions",
    "ExpandDimsOptions",
    "EqualOptions",
    "NotEqualOptions",
    "ShapeOptions",
    "PowOptions",
    "ArgMinOptions",
    "FakeQuantOptions",
    "PackOptions",
    "LogicalOrOptions",
    "OneHotOptions",
    "LogicalAndOptions",
    "LogicalNotOptions",
    "UnpackOptions",
    "FloorDivOptions",
    "SquareOptions",
    "ZerosLikeOptions",
    "FillOptions",
    "BidirectionalSequenceLSTMOptions",
    "BidirectionalSequenceRNNOptions",
    "UnidirectionalSequenceLSTMOptions",
    "FloorModOptions",
    "RangeOptions",
    "ResizeNearestNeighborOptions",
    "LeakyReluOptions",
    "SquaredDifferenceOptions",
    "MirrorPadOptions",
    "AbsOptions",
    "SplitVOptions",
    "UniqueOptions",
    "ReverseV2Options",
    "AddNOptions",
    "GatherNdOptions",
    "CosOptions",
    "WhereOptions",
    "RankOptions",
    "ReverseSequenceOptions",
    "MatrixDiagOptions",
    "QuantizeOptions",
    "MatrixSetDiagOptions",
    "HardSwishOptions",
    "IfOptions",
    "WhileOptions",
    "DepthToSpaceOptions",
    "NonMaxSuppressionV4Options",
    "NonMaxSuppressionV5Options",
    "ScatterNdOptions",
    "SelectV2Options",
    "DensifyOptions",
    "SegmentSumOptions",
    "BatchMatMulOptions",
    "CumsumOptions",
    "CallOnceOptions",
    "BroadcastToOptions",
    "Rfft2dOptions",
    "Conv3DOptions",
    "HashtableOptions",
    "HashtableFindOptions",
    "HashtableImportOptions",
    "HashtableSizeOptions",
    "VarHandleOptions",
    "ReadVariableOptions",
    "AssignVariableOptions",
    "RandomOptions",
    "BucketizeOptions",
    "GeluOptions",
    "DynamicUpdateSliceOptions",
    "UnsortedSegmentProdOptions",
    "UnsortedSegmentMaxOptions",
    "UnsortedSegmentMinOptions",
    "UnsortedSegmentSumOptions",
    "ATan2Options",
    "SignOptions",
    "BitcastOptions",
    "BitwiseXorOptions",
    "RightShiftOptions"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 127, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BuiltinOptions2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StablehloConcatenateOptionsTypeTable,
    StablehloBroadcastInDimOptionsTypeTable,
    StablehloSliceOptionsTypeTable,
    StablehloConvolutionOptionsTypeTable,
    StablehloCustomCallOptionsTypeTable,
    StablehloReduceOptionsTypeTable,
    StablehloScatterOptionsTypeTable,
    StablehloCompareOptionsTypeTable,
    StablehloDynamicSliceOptionsTypeTable,
    StablehloPadOptionsTypeTable,
    StablehloIotaOptionsTypeTable,
    StablehloDotGeneralOptionsTypeTable,
    StablehloReduceWindowOptionsTypeTable,
    StablehloSortOptionsTypeTable,
    StablehloWhileOptionsTypeTable,
    StablehloGatherOptionsTypeTable,
    StablehloTransposeOptionsTypeTable,
    DilateOptionsTypeTable,
    StablehloRngBitGeneratorOptionsTypeTable,
    ReduceWindowOptionsTypeTable,
    StableHLOCompositeOptionsTypeTable,
    StablehloShiftLeftOptionsTypeTable,
    StablehloCaseOptionsTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "StablehloConcatenateOptions",
    "StablehloBroadcastInDimOptions",
    "StablehloSliceOptions",
    "StablehloConvolutionOptions",
    "StablehloCustomCallOptions",
    "StablehloReduceOptions",
    "StablehloScatterOptions",
    "StablehloCompareOptions",
    "StablehloDynamicSliceOptions",
    "StablehloPadOptions",
    "StablehloIotaOptions",
    "StablehloDotGeneralOptions",
    "StablehloReduceWindowOptions",
    "StablehloSortOptions",
    "StablehloWhileOptions",
    "StablehloGatherOptions",
    "StablehloTransposeOptions",
    "DilateOptions",
    "StablehloRngBitGeneratorOptions",
    "ReduceWindowOptions",
    "StableHLOCompositeOptions",
    "StablehloShiftLeftOptions",
    "StablehloCaseOptions"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 24, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloPrecisionConfigTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StablehloPrecisionConfigTypeTable
  };
  static const char * const names[] = {
    "DEFAULT",
    "HIGH",
    "HIGHEST"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloComparisonDirectionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StablehloComparisonDirectionTypeTable
  };
  static const char * const names[] = {
    "STABLEHLO_COMPARISON_DIRECTION_EQ",
    "STABLEHLO_COMPARISON_DIRECTION_NE",
    "STABLEHLO_COMPARISON_DIRECTION_GE",
    "STABLEHLO_COMPARISON_DIRECTION_GT",
    "STABLEHLO_COMPARISON_DIRECTION_LE",
    "STABLEHLO_COMPARISON_DIRECTION_LT"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloComparisonTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StablehloComparisonTypeTypeTable
  };
  static const char * const names[] = {
    "STABLEHLO_COMPARISON_TYPE_NOTYPE",
    "STABLEHLO_COMPARISON_TYPE_FLOAT",
    "STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER",
    "STABLEHLO_COMPARISON_TYPE_SIGNED",
    "STABLEHLO_COMPARISON_TYPE_UNSIGNED"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RngAlgorithmTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RngAlgorithmTypeTable
  };
  static const char * const names[] = {
    "DEFAULT",
    "PHILOX",
    "THREEFRY"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PaddingTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PaddingTypeTable
  };
  static const char * const names[] = {
    "SAME",
    "VALID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ActivationFunctionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "TANH",
    "SIGN_BIT"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LSHProjectionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    LSHProjectionTypeTypeTable
  };
  static const char * const names[] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FullyConnectedOptionsWeightsFormatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FullyConnectedOptionsWeightsFormatTypeTable
  };
  static const char * const names[] = {
    "DEFAULT",
    "SHUFFLED4x16INT8"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LSTMKernelTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    LSTMKernelTypeTypeTable
  };
  static const char * const names[] = {
    "FULL",
    "BASIC"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CombinerTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CombinerTypeTypeTable
  };
  static const char * const names[] = {
    "SUM",
    "MEAN",
    "SQRTN"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MirrorPadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MirrorPadModeTypeTable
  };
  static const char * const names[] = {
    "REFLECT",
    "SYMMETRIC"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceWindowFunctionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ReduceWindowFunctionTypeTable
  };
  static const char * const names[] = {
    "UNSUPPORTED",
    "ADD",
    "MUL",
    "MINIMUM",
    "MAXIMUM",
    "ALL",
    "ANY"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CustomOptionsFormatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CustomOptionsFormatTypeTable
  };
  static const char * const names[] = {
    "FLEXBUFFERS"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CustomQuantizationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "custom"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlockwiseQuantizationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "scales",
    "zero_points",
    "block_size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantizationParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    QuantizationDetailsTypeTable
  };
  static const char * const names[] = {
    "min",
    "max",
    "scale",
    "zero_point",
    "details_type",
    "details",
    "quantized_dimension"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Int32VectorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "values"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Uint16VectorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 1, -1 }
  };
  static const char * const names[] = {
    "values"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Uint8VectorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "values"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DimensionMetadataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DimensionTypeTypeTable,
    SparseIndexVectorTypeTable
  };
  static const char * const names[] = {
    "format",
    "dense_size",
    "array_segments_type",
    "array_segments",
    "array_indices_type",
    "array_indices"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparsityParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DimensionMetadataTypeTable
  };
  static const char * const names[] = {
    "traversal_order",
    "block_map",
    "dim_metadata"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VariantSubTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "shape",
    "type",
    "has_rank"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTypeTable,
    QuantizationParametersTypeTable,
    SparsityParametersTypeTable,
    VariantSubTypeTypeTable
  };
  static const char * const names[] = {
    "shape",
    "type",
    "buffer",
    "name",
    "quantization",
    "is_variable",
    "sparsity",
    "shape_signature",
    "has_rank",
    "variant_tensors"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloGatherOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "offset_dims",
    "collapsed_slice_dims",
    "start_index_map",
    "index_vector_dim",
    "slice_sizes",
    "indices_are_sorted"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloTransposeOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "permutation"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloDotGeneralOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_UINT, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StablehloPrecisionConfigTypeTable
  };
  static const char * const names[] = {
    "lhs_batching_dimensions",
    "rhs_batching_dimensions",
    "lhs_contracting_dimensions",
    "rhs_contracting_dimensions",
    "precision_config"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloReduceWindowOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "window_dimensions",
    "window_strides",
    "base_dilations",
    "window_dilations",
    "padding",
    "body_subgraph_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloWhileOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "cond_subgraph_index",
    "body_subgraph_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloSortOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "dimension",
    "is_stable",
    "comparator_subgraph_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloConcatenateOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "dimension"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloBroadcastInDimOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "broadcast_dimensions"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloCompareOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StablehloComparisonDirectionTypeTable,
    StablehloComparisonTypeTypeTable
  };
  static const char * const names[] = {
    "comparison_direction",
    "compare_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloDynamicSliceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "slice_sizes"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloPadOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "edge_padding_low",
    "edge_padding_high",
    "interior_padding"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloIotaOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "iota_dimension"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloCustomCallOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "call_target_name",
    "has_side_effect",
    "backend_config",
    "api_version",
    "called_computations",
    "custom_attributes"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloReduceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "dimensions",
    "body_subgraph_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloSliceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "start_indices",
    "limit_indices",
    "strides"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloConvolutionOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_BOOL, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_UINT, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StablehloPrecisionConfigTypeTable
  };
  static const char * const names[] = {
    "window_strides",
    "padding",
    "lhs_dilation",
    "rhs_dilation",
    "window_reversal",
    "input_batch_dimension",
    "input_feature_dimension",
    "input_spatial_dimensions",
    "kernel_input_feature_dimension",
    "kernel_output_feature_dimension",
    "kernel_spatial_dimensions",
    "output_batch_dimension",
    "output_feature_dimension",
    "output_spatial_dimensions",
    "feature_group_count",
    "batch_group_count",
    "precision_config"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 17, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloScatterOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "indices_are_sorted",
    "update_window_dims",
    "inserted_window_dims",
    "scatter_dims_to_operand_dims",
    "index_vector_dim",
    "unique_indices",
    "update_computation_subgraph_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloCaseOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "branch_subgraph_indices"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloRngBitGeneratorOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RngAlgorithmTypeTable
  };
  static const char * const names[] = {
    "algorithm"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PaddingTypeTable,
    ActivationFunctionTypeTypeTable,
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "padding",
    "stride_w",
    "stride_h",
    "fused_activation_function",
    "dilation_w_factor",
    "dilation_h_factor",
    "quantized_bias_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv3DOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PaddingTypeTable,
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "padding",
    "stride_d",
    "stride_w",
    "stride_h",
    "fused_activation_function",
    "dilation_d_factor",
    "dilation_w_factor",
    "dilation_h_factor"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pool2DOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PaddingTypeTable,
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "padding",
    "stride_w",
    "stride_h",
    "filter_width",
    "filter_height",
    "fused_activation_function"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthwiseConv2DOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PaddingTypeTable,
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "padding",
    "stride_w",
    "stride_h",
    "depth_multiplier",
    "fused_activation_function",
    "dilation_w_factor",
    "dilation_h_factor"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConcatEmbeddingsOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "num_channels",
    "num_columns_per_channel",
    "embedding_dim_per_channel"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LSHProjectionOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    LSHProjectionTypeTypeTable
  };
  static const char * const names[] = {
    "type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SVDFOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "rank",
    "fused_activation_function",
    "asymmetric_quantize_inputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RNNOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "fused_activation_function",
    "asymmetric_quantize_inputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SequenceRNNOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "time_major",
    "fused_activation_function",
    "asymmetric_quantize_inputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BidirectionalSequenceRNNOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "time_major",
    "fused_activation_function",
    "merge_outputs",
    "asymmetric_quantize_inputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FullyConnectedOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable,
    FullyConnectedOptionsWeightsFormatTypeTable,
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "fused_activation_function",
    "weights_format",
    "keep_num_dims",
    "asymmetric_quantize_inputs",
    "quantized_bias_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftmaxOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "beta"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConcatenationOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "axis",
    "fused_activation_function"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "fused_activation_function",
    "pot_scale_int16"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MulOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "fused_activation_function"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *L2NormOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "fused_activation_function"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LocalResponseNormalizationOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "radius",
    "bias",
    "alpha",
    "beta"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LSTMOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable,
    LSTMKernelTypeTypeTable
  };
  static const char * const names[] = {
    "fused_activation_function",
    "cell_clip",
    "proj_clip",
    "kernel_type",
    "asymmetric_quantize_inputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnidirectionalSequenceLSTMOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "fused_activation_function",
    "cell_clip",
    "proj_clip",
    "time_major",
    "asymmetric_quantize_inputs",
    "diagonal_recurrent_tensors"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BidirectionalSequenceLSTMOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "fused_activation_function",
    "cell_clip",
    "proj_clip",
    "merge_outputs",
    "time_major",
    "asymmetric_quantize_inputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResizeBilinearOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "new_height",
    "new_width",
    "align_corners",
    "half_pixel_centers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResizeNearestNeighborOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "align_corners",
    "half_pixel_centers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CallOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "subgraph"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadV2OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReshapeOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "new_shape"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpaceToBatchNDOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchToSpaceNDOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SkipGramOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "ngram_size",
    "max_skip_size",
    "include_all_ngrams"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpaceToDepthOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "block_size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthToSpaceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "block_size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "fused_activation_function",
    "pot_scale_int16"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DivOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ActivationFunctionTypeTypeTable
  };
  static const char * const names[] = {
    "fused_activation_function"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopKV2OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EmbeddingLookupSparseOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CombinerTypeTypeTable
  };
  static const char * const names[] = {
    "combiner"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis",
    "batch_dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TransposeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CosOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReducerOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "keep_dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqueezeOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "squeeze_dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SplitOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "num_splits"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SplitVOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "num_splits"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StridedSliceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "begin_mask",
    "end_mask",
    "ellipsis_mask",
    "new_axis_mask",
    "shrink_axis_mask",
    "offset"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogSoftmaxOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CastOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "in_data_type",
    "out_data_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DequantizeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaximumMinimumOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TileOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "output_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMinOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "output_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GreaterOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GreaterEqualOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LessOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LessEqualOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NegOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SelectOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SliceOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TransposeConvOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PaddingTypeTable,
    ActivationFunctionTypeTypeTable,
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "padding",
    "stride_w",
    "stride_h",
    "fused_activation_function",
    "quantized_bias_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpandDimsOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparseToDenseOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "validate_indices"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EqualOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NotEqualOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ShapeOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "out_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RankOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PowOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FakeQuantOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "min",
    "max",
    "num_bits",
    "narrow_range"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PackOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "values_count",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicalOrOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OneHotOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AbsOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HardSwishOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicalAndOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicalNotOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnpackOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "num",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FloorDivOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SquareOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ZerosLikeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FillOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FloorModOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RangeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LeakyReluOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SquaredDifferenceOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MirrorPadOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MirrorPadModeTypeTable
  };
  static const char * const names[] = {
    "mode"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UniqueOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "idx_out_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReverseV2OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddNOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherNdOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WhereOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReverseSequenceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "seq_dim",
    "batch_dim"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MatrixDiagOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantizeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MatrixSetDiagOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IfOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "then_subgraph_index",
    "else_subgraph_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CallOnceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "init_subgraph_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WhileOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "cond_subgraph_index",
    "body_subgraph_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NonMaxSuppressionV4OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NonMaxSuppressionV5OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScatterNdOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SelectV2OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DensifyOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SegmentSumOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchMatMulOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "adj_x",
    "adj_y",
    "asymmetric_quantize_inputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CumsumOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "exclusive",
    "reverse"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BroadcastToOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Rfft2dOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HashtableOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTypeTable
  };
  static const char * const names[] = {
    "table_id",
    "key_dtype",
    "value_dtype"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HashtableFindOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HashtableImportOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HashtableSizeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VarHandleOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "container",
    "shared_name"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReadVariableOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssignVariableOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RandomOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "seed",
    "seed2"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BucketizeOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "boundaries"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeluOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "approximate"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DynamicUpdateSliceOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnsortedSegmentProdOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnsortedSegmentMaxOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnsortedSegmentSumOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ATan2OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnsortedSegmentMinOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BitcastOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BitwiseXorOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RightShiftOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DilateOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceWindowOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ReduceWindowFunctionTypeTable
  };
  static const char * const names[] = {
    "reduce_function"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OperatorCodeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BuiltinOperatorTypeTable
  };
  static const char * const names[] = {
    "deprecated_builtin_code",
    "custom_code",
    "version",
    "builtin_code"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StableHLOCompositeOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CustomOptionsFormatTypeTable
  };
  static const char * const names[] = {
    "name",
    "decomposition_subgraph_index",
    "composite_attributes",
    "composite_attributes_format",
    "version"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StablehloShiftLeftOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OperatorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BuiltinOptionsTypeTable,
    CustomOptionsFormatTypeTable,
    BuiltinOptions2TypeTable
  };
  static const char * const names[] = {
    "opcode_index",
    "inputs",
    "outputs",
    "builtin_options_type",
    "builtin_options",
    "custom_options",
    "custom_options_format",
    "mutating_variable_inputs",
    "intermediates",
    "large_custom_options_offset",
    "large_custom_options_size",
    "builtin_options_2_type",
    "builtin_options_2",
    "debug_metadata_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubGraphTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTable,
    OperatorTypeTable
  };
  static const char * const names[] = {
    "tensors",
    "inputs",
    "outputs",
    "operators",
    "name",
    "debug_metadata_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "data",
    "offset",
    "size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MetadataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "buffer"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorMapTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "tensor_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignatureDefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorMapTypeTable
  };
  static const char * const names[] = {
    "inputs",
    "outputs",
    "signature_key",
    "deprecated_tag",
    "subgraph_index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ModelTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    OperatorCodeTypeTable,
    SubGraphTypeTable,
    BufferTypeTable,
    MetadataTypeTable,
    SignatureDefTypeTable
  };
  static const char * const names[] = {
    "version",
    "operator_codes",
    "subgraphs",
    "description",
    "buffers",
    "metadata_buffer",
    "metadata",
    "signature_defs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const tflite::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<tflite::Model>(buf);
}

inline const tflite::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<tflite::Model>(buf);
}

inline const char *ModelIdentifier() {
  return "TFL3";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::Model>(ModelIdentifier());
}

inline const char *ModelExtension() {
  return "tflite";
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::Model> root) {
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::Model> root) {
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

inline std::unique_ptr<ModelT> UnPackModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ModelT>(GetModel(buf)->UnPack(res));
}

}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
