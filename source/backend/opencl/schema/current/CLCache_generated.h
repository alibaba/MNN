// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CLCACHE_CLCACHE_H_
#define FLATBUFFERS_GENERATED_CLCACHE_CLCACHE_H_

#include "flatbuffers/flatbuffers.h"

namespace CLCache {

struct TensorInfo;
struct TensorInfoT;

struct OpInfo;
struct OpInfoT;

struct Shader;
struct ShaderT;

struct Autotuning;
struct AutotuningT;

struct GemmInfo;
struct GemmInfoT;

struct Cache;
struct CacheT;

inline const flatbuffers::TypeTable *TensorInfoTypeTable();

inline const flatbuffers::TypeTable *OpInfoTypeTable();

inline const flatbuffers::TypeTable *ShaderTypeTable();

inline const flatbuffers::TypeTable *AutotuningTypeTable();

inline const flatbuffers::TypeTable *GemmInfoTypeTable();

inline const flatbuffers::TypeTable *CacheTypeTable();

struct TensorInfoT : public flatbuffers::NativeTable {
  typedef TensorInfo TableType;
  std::vector<int32_t> shape;
  TensorInfoT() {
  }
};

struct TensorInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorInfoTypeTable();
  }
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(shape()) &&
           verifier.EndTable();
  }
  TensorInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(4, shape);
  }
  explicit TensorInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorInfoBuilder &operator=(const TensorInfoBuilder &);
  flatbuffers::Offset<TensorInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorInfo> CreateTensorInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0) {
  TensorInfoBuilder builder_(_fbb);
  builder_.add_shape(shape);
  return builder_.Finish();
}

flatbuffers::Offset<TensorInfo> CreateTensorInfo(flatbuffers::FlatBufferBuilder &_fbb, const TensorInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpInfoT : public flatbuffers::NativeTable {
  typedef OpInfo TableType;
  std::string name;
  int32_t type;
  std::vector<std::unique_ptr<TensorInfoT>> inputs;
  std::vector<std::unique_ptr<TensorInfoT>> outputs;
  OpInfoT()
      : type(0) {
  }
};

struct OpInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpInfoTypeTable();
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  int32_t type() const {
    return GetField<int32_t>(6, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorInfo>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorInfo>> *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorInfo>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorInfo>> *>(10);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           verifier.EndTable();
  }
  OpInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OpInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(4, name);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(6, type, 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorInfo>>> inputs) {
    fbb_.AddOffset(8, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorInfo>>> outputs) {
    fbb_.AddOffset(10, outputs);
  }
  explicit OpInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpInfoBuilder &operator=(const OpInfoBuilder &);
  flatbuffers::Offset<OpInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpInfo> CreateOpInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorInfo>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorInfo>>> outputs = 0) {
  OpInfoBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_type(type);
  builder_.add_name(name);
  return builder_.Finish();
}

flatbuffers::Offset<OpInfo> CreateOpInfo(flatbuffers::FlatBufferBuilder &_fbb, const OpInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShaderT : public flatbuffers::NativeTable {
  typedef Shader TableType;
  std::vector<int8_t> buffer;
  std::string program;
  std::string kernel;
  std::string buildInfo;
  ShaderT() {
  }
};

struct Shader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShaderTypeTable();
  }
  const flatbuffers::Vector<int8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(4);
  }
  const flatbuffers::String *program() const {
    return GetPointer<const flatbuffers::String *>(6);
  }
  const flatbuffers::String *kernel() const {
    return GetPointer<const flatbuffers::String *>(8);
  }
  const flatbuffers::String *buildInfo() const {
    return GetPointer<const flatbuffers::String *>(10);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(buffer()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyString(program()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyString(kernel()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyString(buildInfo()) &&
           verifier.EndTable();
  }
  ShaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Shader> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer) {
    fbb_.AddOffset(4, buffer);
  }
  void add_program(flatbuffers::Offset<flatbuffers::String> program) {
    fbb_.AddOffset(6, program);
  }
  void add_kernel(flatbuffers::Offset<flatbuffers::String> kernel) {
    fbb_.AddOffset(8, kernel);
  }
  void add_buildInfo(flatbuffers::Offset<flatbuffers::String> buildInfo) {
    fbb_.AddOffset(10, buildInfo);
  }
  explicit ShaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderBuilder &operator=(const ShaderBuilder &);
  flatbuffers::Offset<Shader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shader>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shader> CreateShader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer = 0,
    flatbuffers::Offset<flatbuffers::String> program = 0,
    flatbuffers::Offset<flatbuffers::String> kernel = 0,
    flatbuffers::Offset<flatbuffers::String> buildInfo = 0) {
  ShaderBuilder builder_(_fbb);
  builder_.add_buildInfo(buildInfo);
  builder_.add_kernel(kernel);
  builder_.add_program(program);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

flatbuffers::Offset<Shader> CreateShader(flatbuffers::FlatBufferBuilder &_fbb, const ShaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AutotuningT : public flatbuffers::NativeTable {
  typedef Autotuning TableType;
  std::string key;
  std::vector<uint32_t> gloablSize;
  std::vector<uint32_t> localSize;
  uint32_t timeCost;
  AutotuningT()
      : timeCost(0) {
  }
};

struct Autotuning FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutotuningT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AutotuningTypeTable();
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::Vector<uint32_t> *gloablSize() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(6);
  }
  const flatbuffers::Vector<uint32_t> *localSize() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(8);
  }
  uint32_t timeCost() const {
    return GetField<uint32_t>(10, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(gloablSize()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(localSize()) &&
           VerifyField<uint32_t>(verifier, 10) &&
           verifier.EndTable();
  }
  AutotuningT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AutotuningT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Autotuning> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AutotuningT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AutotuningBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(4, key);
  }
  void add_gloablSize(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> gloablSize) {
    fbb_.AddOffset(6, gloablSize);
  }
  void add_localSize(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> localSize) {
    fbb_.AddOffset(8, localSize);
  }
  void add_timeCost(uint32_t timeCost) {
    fbb_.AddElement<uint32_t>(10, timeCost, 0);
  }
  explicit AutotuningBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AutotuningBuilder &operator=(const AutotuningBuilder &);
  flatbuffers::Offset<Autotuning> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Autotuning>(end);
    return o;
  }
};

inline flatbuffers::Offset<Autotuning> CreateAutotuning(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> gloablSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> localSize = 0,
    uint32_t timeCost = 0) {
  AutotuningBuilder builder_(_fbb);
  builder_.add_timeCost(timeCost);
  builder_.add_localSize(localSize);
  builder_.add_gloablSize(gloablSize);
  builder_.add_key(key);
  return builder_.Finish();
}

flatbuffers::Offset<Autotuning> CreateAutotuning(flatbuffers::FlatBufferBuilder &_fbb, const AutotuningT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GemmInfoT : public flatbuffers::NativeTable {
  typedef GemmInfo TableType;
  std::vector<uint32_t> gemmSize;
  std::vector<uint32_t> paramInfo;
  GemmInfoT() {
  }
};

struct GemmInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GemmInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GemmInfoTypeTable();
  }
  const flatbuffers::Vector<uint32_t> *gemmSize() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(4);
  }
  const flatbuffers::Vector<uint32_t> *paramInfo() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(gemmSize()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(paramInfo()) &&
           verifier.EndTable();
  }
  GemmInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GemmInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GemmInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GemmInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GemmInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gemmSize(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> gemmSize) {
    fbb_.AddOffset(4, gemmSize);
  }
  void add_paramInfo(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> paramInfo) {
    fbb_.AddOffset(6, paramInfo);
  }
  explicit GemmInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GemmInfoBuilder &operator=(const GemmInfoBuilder &);
  flatbuffers::Offset<GemmInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GemmInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GemmInfo> CreateGemmInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> gemmSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> paramInfo = 0) {
  GemmInfoBuilder builder_(_fbb);
  builder_.add_paramInfo(paramInfo);
  builder_.add_gemmSize(gemmSize);
  return builder_.Finish();
}

flatbuffers::Offset<GemmInfo> CreateGemmInfo(flatbuffers::FlatBufferBuilder &_fbb, const GemmInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CacheT : public flatbuffers::NativeTable {
  typedef Cache TableType;
  std::vector<std::unique_ptr<ShaderT>> programs;
  std::vector<std::unique_ptr<AutotuningT>> tunings;
  std::vector<std::unique_ptr<OpInfoT>> tuned;
  std::vector<std::unique_ptr<GemmInfoT>> gemm;
  CacheT() {
  }
};

struct Cache FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CacheT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CacheTypeTable();
  }
  const flatbuffers::Vector<flatbuffers::Offset<Shader>> *programs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Shader>> *>(4);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Autotuning>> *tunings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Autotuning>> *>(6);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OpInfo>> *tuned() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OpInfo>> *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GemmInfo>> *gemm() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GemmInfo>> *>(10);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(programs()) &&
           verifier.VerifyVectorOfTables(programs()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(tunings()) &&
           verifier.VerifyVectorOfTables(tunings()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(tuned()) &&
           verifier.VerifyVectorOfTables(tuned()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(gemm()) &&
           verifier.VerifyVectorOfTables(gemm()) &&
           verifier.EndTable();
  }
  CacheT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CacheT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Cache> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CacheT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CacheBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_programs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Shader>>> programs) {
    fbb_.AddOffset(4, programs);
  }
  void add_tunings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Autotuning>>> tunings) {
    fbb_.AddOffset(6, tunings);
  }
  void add_tuned(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OpInfo>>> tuned) {
    fbb_.AddOffset(8, tuned);
  }
  void add_gemm(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GemmInfo>>> gemm) {
    fbb_.AddOffset(10, gemm);
  }
  explicit CacheBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CacheBuilder &operator=(const CacheBuilder &);
  flatbuffers::Offset<Cache> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cache>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cache> CreateCache(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Shader>>> programs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Autotuning>>> tunings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OpInfo>>> tuned = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GemmInfo>>> gemm = 0) {
  CacheBuilder builder_(_fbb);
  builder_.add_gemm(gemm);
  builder_.add_tuned(tuned);
  builder_.add_tunings(tunings);
  builder_.add_programs(programs);
  return builder_.Finish();
}

flatbuffers::Offset<Cache> CreateCache(flatbuffers::FlatBufferBuilder &_fbb, const CacheT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TensorInfoT *TensorInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TensorInfo::UnPackTo(TensorInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<TensorInfo> TensorInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorInfo> CreateTensorInfo(flatbuffers::FlatBufferBuilder &_fbb, const TensorInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  return CLCache::CreateTensorInfo(
      _fbb,
      _shape);
}

inline OpInfoT *OpInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OpInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OpInfo::UnPackTo(OpInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = type(); _o->type = _e; };
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = std::unique_ptr<TensorInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = std::unique_ptr<TensorInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<OpInfo> OpInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OpInfo> CreateOpInfo(flatbuffers::FlatBufferBuilder &_fbb, const OpInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector<flatbuffers::Offset<TensorInfo>> (_o->inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorInfo(*__va->__fbb, __va->__o->inputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector<flatbuffers::Offset<TensorInfo>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorInfo(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CLCache::CreateOpInfo(
      _fbb,
      _name,
      _type,
      _inputs,
      _outputs);
}

inline ShaderT *Shader::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShaderT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Shader::UnPackTo(ShaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = buffer(); if (_e) { _o->buffer.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buffer[_i] = _e->Get(_i); } } };
  { auto _e = program(); if (_e) _o->program = _e->str(); };
  { auto _e = kernel(); if (_e) _o->kernel = _e->str(); };
  { auto _e = buildInfo(); if (_e) _o->buildInfo = _e->str(); };
}

inline flatbuffers::Offset<Shader> Shader::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Shader> CreateShader(flatbuffers::FlatBufferBuilder &_fbb, const ShaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _buffer = _o->buffer.size() ? _fbb.CreateVector(_o->buffer) : 0;
  auto _program = _o->program.empty() ? 0 : _fbb.CreateString(_o->program);
  auto _kernel = _o->kernel.empty() ? 0 : _fbb.CreateString(_o->kernel);
  auto _buildInfo = _o->buildInfo.empty() ? 0 : _fbb.CreateString(_o->buildInfo);
  return CLCache::CreateShader(
      _fbb,
      _buffer,
      _program,
      _kernel,
      _buildInfo);
}

inline AutotuningT *Autotuning::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AutotuningT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Autotuning::UnPackTo(AutotuningT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); };
  { auto _e = gloablSize(); if (_e) { _o->gloablSize.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->gloablSize[_i] = _e->Get(_i); } } };
  { auto _e = localSize(); if (_e) { _o->localSize.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->localSize[_i] = _e->Get(_i); } } };
  { auto _e = timeCost(); _o->timeCost = _e; };
}

inline flatbuffers::Offset<Autotuning> Autotuning::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AutotuningT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAutotuning(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Autotuning> CreateAutotuning(flatbuffers::FlatBufferBuilder &_fbb, const AutotuningT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AutotuningT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _o->key.empty() ? 0 : _fbb.CreateString(_o->key);
  auto _gloablSize = _o->gloablSize.size() ? _fbb.CreateVector(_o->gloablSize) : 0;
  auto _localSize = _o->localSize.size() ? _fbb.CreateVector(_o->localSize) : 0;
  auto _timeCost = _o->timeCost;
  return CLCache::CreateAutotuning(
      _fbb,
      _key,
      _gloablSize,
      _localSize,
      _timeCost);
}

inline GemmInfoT *GemmInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GemmInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GemmInfo::UnPackTo(GemmInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = gemmSize(); if (_e) { _o->gemmSize.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->gemmSize[_i] = _e->Get(_i); } } };
  { auto _e = paramInfo(); if (_e) { _o->paramInfo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->paramInfo[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<GemmInfo> GemmInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GemmInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGemmInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GemmInfo> CreateGemmInfo(flatbuffers::FlatBufferBuilder &_fbb, const GemmInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GemmInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _gemmSize = _o->gemmSize.size() ? _fbb.CreateVector(_o->gemmSize) : 0;
  auto _paramInfo = _o->paramInfo.size() ? _fbb.CreateVector(_o->paramInfo) : 0;
  return CLCache::CreateGemmInfo(
      _fbb,
      _gemmSize,
      _paramInfo);
}

inline CacheT *Cache::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CacheT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Cache::UnPackTo(CacheT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = programs(); if (_e) { _o->programs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->programs[_i] = std::unique_ptr<ShaderT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = tunings(); if (_e) { _o->tunings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tunings[_i] = std::unique_ptr<AutotuningT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = tuned(); if (_e) { _o->tuned.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tuned[_i] = std::unique_ptr<OpInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = gemm(); if (_e) { _o->gemm.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->gemm[_i] = std::unique_ptr<GemmInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Cache> Cache::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CacheT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCache(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Cache> CreateCache(flatbuffers::FlatBufferBuilder &_fbb, const CacheT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CacheT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _programs = _o->programs.size() ? _fbb.CreateVector<flatbuffers::Offset<Shader>> (_o->programs.size(), [](size_t i, _VectorArgs *__va) { return CreateShader(*__va->__fbb, __va->__o->programs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _tunings = _o->tunings.size() ? _fbb.CreateVector<flatbuffers::Offset<Autotuning>> (_o->tunings.size(), [](size_t i, _VectorArgs *__va) { return CreateAutotuning(*__va->__fbb, __va->__o->tunings[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _tuned = _o->tuned.size() ? _fbb.CreateVector<flatbuffers::Offset<OpInfo>> (_o->tuned.size(), [](size_t i, _VectorArgs *__va) { return CreateOpInfo(*__va->__fbb, __va->__o->tuned[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _gemm = _o->gemm.size() ? _fbb.CreateVector<flatbuffers::Offset<GemmInfo>> (_o->gemm.size(), [](size_t i, _VectorArgs *__va) { return CreateGemmInfo(*__va->__fbb, __va->__o->gemm[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CLCache::CreateCache(
      _fbb,
      _programs,
      _tunings,
      _tuned,
      _gemm);
}

inline const flatbuffers::TypeTable *TensorInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "shape"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorInfoTypeTable
  };
  static const char * const names[] = {
    "name",
    "type",
    "inputs",
    "outputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ShaderTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "buffer",
    "program",
    "kernel",
    "buildInfo"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AutotuningTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "key",
    "gloablSize",
    "localSize",
    "timeCost"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GemmInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_UINT, 1, -1 }
  };
  static const char * const names[] = {
    "gemmSize",
    "paramInfo"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CacheTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ShaderTypeTable,
    AutotuningTypeTable,
    OpInfoTypeTable,
    GemmInfoTypeTable
  };
  static const char * const names[] = {
    "programs",
    "tunings",
    "tuned",
    "gemm"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const CLCache::Cache *GetCache(const void *buf) {
  return flatbuffers::GetRoot<CLCache::Cache>(buf);
}

inline const CLCache::Cache *GetSizePrefixedCache(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<CLCache::Cache>(buf);
}

inline bool VerifyCacheBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CLCache::Cache>(nullptr);
}

inline bool VerifySizePrefixedCacheBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CLCache::Cache>(nullptr);
}

inline void FinishCacheBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<CLCache::Cache> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCacheBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<CLCache::Cache> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<CacheT> UnPackCache(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<CacheT>(GetCache(buf)->UnPack(res));
}

}  // namespace CLCache

#endif  // FLATBUFFERS_GENERATED_CLCACHE_CLCACHE_H_
