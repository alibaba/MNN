#include "opencl_source_map.hpp" 
namespace MNN { 
#ifndef MNN_OPENCL_BUFFER_CLOSED
const char* gemv_conv1x1_buf = 
"#ifdef MNN_SUPPORT_FP16\n"
"#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n"
"#endif\n"
"__constant sampler_t SAMPLER=CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST;\n"
"#define GLOBAL_SIZE_DIM_2 "" __private int global_size_dim0,__private int global_size_dim1,\n"
"#define UNIFORM_BOUNDRY_CHECK_2(index0, index1) "" if(index0 >= global_size_dim0 || index1 >= global_size_dim1) { "" return; "" }\n"
"#define UCHAR4_TO_CHAR8(b, scale, offset) "" wei.s0 = (COMPUTE_FLOAT)((b.s0 >> 4) - 8); "" wei.s1 = (COMPUTE_FLOAT)((b.s0 & 15) - 8); "" wei.s2 = (COMPUTE_FLOAT)((b.s1 >> 4) - 8); "" wei.s3 = (COMPUTE_FLOAT)((b.s1 & 15) - 8); "" wei.s4 = (COMPUTE_FLOAT)((b.s2 >> 4) - 8); "" wei.s5 = (COMPUTE_FLOAT)((b.s2 & 15) - 8); "" wei.s6 = (COMPUTE_FLOAT)((b.s3 >> 4) - 8); "" wei.s7 = (COMPUTE_FLOAT)((b.s3 & 15) - 8); "" wei=wei*scale+offset;\n"
"#define UCHAR8_TO_CHAR16(b, scale, offset)"" wei.s0 = (COMPUTE_FLOAT)((b.s0 >> 4) - 8); "" wei.s1 = (COMPUTE_FLOAT)((b.s0 & 15) - 8); "" wei.s2 = (COMPUTE_FLOAT)((b.s1 >> 4) - 8); "" wei.s3 = (COMPUTE_FLOAT)((b.s1 & 15) - 8); "" wei.s4 = (COMPUTE_FLOAT)((b.s2 >> 4) - 8); "" wei.s5 = (COMPUTE_FLOAT)((b.s2 & 15) - 8); "" wei.s6 = (COMPUTE_FLOAT)((b.s3 >> 4) - 8); "" wei.s7 = (COMPUTE_FLOAT)((b.s3 & 15) - 8); "" wei.s8 = (COMPUTE_FLOAT)((b.s4 >> 4) - 8); "" wei.s9 = (COMPUTE_FLOAT)((b.s4 & 15) - 8); "" wei.sa = (COMPUTE_FLOAT)((b.s5 >> 4) - 8);"" wei.sb = (COMPUTE_FLOAT)((b.s5 & 15) - 8);"" wei.sc = (COMPUTE_FLOAT)((b.s6 >> 4) - 8);"" wei.sd = (COMPUTE_FLOAT)((b.s6 & 15) - 8);"" wei.se = (COMPUTE_FLOAT)((b.s7 >> 4) - 8);"" wei.sf = (COMPUTE_FLOAT)((b.s7 & 15) - 8);"" wei=wei*scale+offset; \n"
" // wei.s11=(COMPUTE_FLOAT)((b.s5 & 15)-8); \n"
" \n"
" //wei.s13 = (COMPUTE_FLOAT)((b.s6 & 15) - 8); "" //wei.s14 = (COMPUTE_FLOAT)((b.s7 >> 4) - 8); "" //wei.s15 = (COMPUTE_FLOAT)((b.s7 & 15) - 8); "" \n"
"#define UCHAR4_TO_CHAR8_FIRST(b, scale, offset, wei_result) "" wei_result.s0 = (COMPUTE_FLOAT)((b.s0 >> 4) - 8); "" wei_result.s1 = (COMPUTE_FLOAT)((b.s0 & 15) - 8); "" wei_result.s2 = (COMPUTE_FLOAT)((b.s1 >> 4) - 8); "" wei_result.s3 = (COMPUTE_FLOAT)((b.s1 & 15) - 8); "" wei_result.s4 = (COMPUTE_FLOAT)((b.s2 >> 4) - 8); "" wei_result.s5 = (COMPUTE_FLOAT)((b.s2 & 15) - 8); "" wei_result.s6 = (COMPUTE_FLOAT)((b.s3 >> 4) - 8); "" wei_result.s7 = (COMPUTE_FLOAT)((b.s3 & 15) - 8); "" wei_result=wei_result*scale+offset;\n"
"#define UCHAR4_TO_CHAR8_SECOND(b, scale, offset, wei_result) "" wei_result.s0 = (COMPUTE_FLOAT)((b.s4 >> 4) - 8); "" wei_result.s1 = (COMPUTE_FLOAT)((b.s4 & 15) - 8); "" wei_result.s2 = (COMPUTE_FLOAT)((b.s5 >> 4) - 8); "" wei_result.s3 = (COMPUTE_FLOAT)((b.s5 & 15) - 8); "" wei_result.s4 = (COMPUTE_FLOAT)((b.s6 >> 4) - 8); "" wei_result.s5 = (COMPUTE_FLOAT)((b.s6 & 15) - 8); "" wei_result.s6 = (COMPUTE_FLOAT)((b.s7 >> 4) - 8); "" wei_result.s7 = (COMPUTE_FLOAT)((b.s7 & 15) - 8); "" wei_result=wei_result*scale+offset;\n"
"#if WGS >= 8\n"
"__kernel void gemv_conv_c8_int4_buf(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
"#ifdef USE_IMAGE\n"
" __read_only image2d_t weight,\n"
"#else\n"
" __global const uchar *weight,\n"
"#endif\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" const int oc8=oc << 3;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop=max((srcChannel+4-1)/4-1,0);\n"
"#else\n"
" const int loop=(srcChannel+4-1)/4;\n"
"#endif\n"
" __local COMPUTE_FLOAT8 sum[WGS];\n"
" COMPUTE_FLOAT8 out0=0;\n"
"#ifndef USE_IMAGE\n"
" const int weight_offset=oc*srcChannelC4*16;\n"
"#endif\n"
" \n"
" for(int j=lid; j<loop; j+=WGS){\n"
" int k4=j << 2;\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale=scaleOffset.s02468ace;\n"
" offset=scaleOffset.s13579bdf;\n"
" }\n"
"#else\n"
" COMPUTE_FLOAT8 scale=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" COMPUTE_FLOAT8 offset=0;\n"
"#endif\n"
" COMPUTE_FLOAT8 wei;\n"
" COMPUTE_FLOAT4 in=CONVERT_COMPUTE_FLOAT4(vload4(0,input+k4));\n"
" #ifdef USE_IMAGE\n"
" uchar16 charWeightsInt40=as_uchar16(read_imagei(weight,SAMPLER,(int2)(j,oc)));\n"
" #else\n"
" uchar16 charWeightsInt40=vload16(j,weight+weight_offset);\n"
" #endif\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s0,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s1,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s2,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.scdef,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s3,wei,out0);\n"
" }\n"
" }\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k4=loop << 2;\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale=scaleOffset.s02468ace;\n"
" offset=scaleOffset.s13579bdf;\n"
" }\n"
"#else\n"
" COMPUTE_FLOAT8 scale=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" COMPUTE_FLOAT8 offset=0;\n"
"#endif\n"
" COMPUTE_FLOAT8 wei;\n"
" #ifdef USE_IMAGE\n"
" uchar16 charWeightsInt40=as_uchar16(read_imagei(weight,SAMPLER,(int2)(loop,oc)));\n"
" #else\n"
" uchar16 charWeightsInt40=vload16(j,weight+weight_offset);\n"
" #endif\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4],wei,out0);\n"
" }\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 2\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+1],wei,out0);\n"
" }\n"
" #endif\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 3\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+2],wei,out0);\n"
" }\n"
" #endif\n"
" }\n"
"#endif\n"
" sum[lid]=out0;\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" for(int i=WGS/2; i>0; i /= 2){\n"
" if (lid<i)\n"
" sum[lid]=sum[lid]+sum[lid+i];\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" if(lid == 0){\n"
" out0=sum[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
" #ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" #endif\n"
" }\n"
"}\n"
"__kernel void gemv_conv_c8_int8_buf(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
"#ifdef USE_IMAGE\n"
" __read_only image2d_t weight,\n"
"#else\n"
" __global const char *weight,\n"
"#endif\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" const int oc8=oc << 3;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop=max((srcChannel+2-1)/2-1,0);\n"
"#else\n"
" const int loop=(srcChannel+2-1)/2;\n"
"#endif\n"
" __local COMPUTE_FLOAT8 sum[WGS];\n"
"#ifndef USE_IMAGE\n"
" const int weight_offset=oc*srcChannelC4*32;\n"
"#endif\n"
" COMPUTE_FLOAT8 out0=0;\n"
" for(int j=lid; j<loop; j+=WGS){\n"
" int k2=j << 1;\n"
" COMPUTE_FLOAT16 scale,offset;\n"
" {\n"
" #ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k2/blockDim)*dstChannelC4*8))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset.s02468ace,scaleOffset.s02468ace);\n"
" offset=(COMPUTE_FLOAT16)(scaleOffset.s13579bdf,scaleOffset.s13579bdf);\n"
" #else\n"
" COMPUTE_FLOAT8 scaleOffset=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k2/blockDim)*dstChannelC4*4))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset,scaleOffset);\n"
" offset=0;\n"
" #endif\n"
" }\n"
" COMPUTE_FLOAT2 in=CONVERT_COMPUTE_FLOAT2(vload2(0,input+k2));\n"
" #ifdef USE_IMAGE\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)(j,oc))))*scale+offset;\n"
" #else\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(vload16(j,weight+weight_offset))*scale+offset;\n"
" #endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)in.s0,wei.s01234567,out0);\n"
" }\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)in.s1,wei.s89abcdef,out0);\n"
" }\n"
" }\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k2=loop << 1;\n"
" COMPUTE_FLOAT16 scale,offset;\n"
" {\n"
" #ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k2/blockDim)*dstChannelC4*8))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset.s02468ace,scaleOffset.s02468ace);\n"
" offset=(COMPUTE_FLOAT16)(scaleOffset.s13579bdf,scaleOffset.s13579bdf);\n"
" #else\n"
" COMPUTE_FLOAT8 scaleOffset=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k2/blockDim)*dstChannelC4*4))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset,scaleOffset);\n"
" offset=0;\n"
" #endif\n"
" }\n"
" #ifdef USE_IMAGE\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)(loop,oc))))*scale+offset;\n"
" #else\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(vload16(j,weight+weight_offset))*scale+offset;\n"
" #endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)input[k2],wei.s01234567,out0);\n"
" }\n"
" }\n"
"#endif\n"
" sum[lid]=out0;\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" for(int i=WGS/2; i>0; i /= 2){\n"
" if (lid<i)\n"
" sum[lid]=sum[lid]+sum[lid+i];\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" if(lid == 0){\n"
" out0=sum[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
" #ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" #endif\n"
" }\n"
"}\n"
"#else\n"
"__kernel void gemv_conv_c8_int4_buf(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
"#ifdef USE_IMAGE\n"
" __read_only image2d_t weight,\n"
"#else\n"
" __global const uchar *weight,\n"
"#endif\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef) {\n"
" const int ic=get_global_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" \n"
" UNIFORM_BOUNDRY_CHECK_2(ic,oc);\n"
" const int oc8=oc << 3;\n"
" \n"
" const int loop=(blockDim+4-1)/4;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop_end=max(loop-1,0);\n"
"#else\n"
" const int loop_end=loop;\n"
"#endif\n"
" COMPUTE_FLOAT8 out0=CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
"#ifndef USE_IMAGE\n"
" const int weight_offset=oc*srcChannelC4*16;\n"
"#endif\n"
" for (int i=0; i<blockNum; i++){\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+i*dstChannelC4*8))/coef);\n"
" scale=scaleOffset.s02468ace;\n"
" offset=scaleOffset.s13579bdf;\n"
" }\n"
"#else\n"
" COMPUTE_FLOAT8 scale=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+i*dstChannelC4*4))/coef);\n"
" COMPUTE_FLOAT8 offset=0;\n"
"#endif\n"
" for (int j=0; j<loop_end; j++) {\n"
" int k=i*loop+j;\n"
" COMPUTE_FLOAT8 wei;\n"
" COMPUTE_FLOAT4 in=CONVERT_COMPUTE_FLOAT4(vload4(0,input+(k << 2)));\n"
" #ifdef USE_IMAGE\n"
" uchar16 charWeightsInt40=as_uchar16(read_imagei(weight,SAMPLER,(int2)(k,oc)));\n"
" #else\n"
" uchar16 charWeightsInt40=vload16(k,weight+weight_offset);\n"
" #endif\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s0,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s1,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s2,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.scdef,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s3,wei,out0);\n"
" }\n"
" }\n"
" #if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k=i*loop+loop_end;\n"
" int k4=k << 2;\n"
" COMPUTE_FLOAT8 wei;\n"
" #ifdef USE_IMAGE\n"
" uchar16 charWeightsInt40=as_uchar16(read_imagei(weight,SAMPLER,(int2)(k,oc)));\n"
" #else\n"
" uchar16 charWeightsInt40=vload16(k,weight+weight_offset);\n"
" #endif\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4],wei,out0);\n"
" }\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 2\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+1],wei,out0);\n"
" }\n"
" #endif\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 3\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+2],wei,out0);\n"
" }\n"
" #endif\n"
" }\n"
" #endif\n"
"}\n"
"#ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
"#endif\n"
"#ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
"#endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" #endif\n"
"}\n"
"__kernel void gemv_conv_c8_int8_buf(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
"#ifdef USE_IMAGE\n"
" __read_only image2d_t weight,\n"
"#else\n"
" __global const char *weight,\n"
"#endif\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef) {\n"
" const int ic=get_global_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" UNIFORM_BOUNDRY_CHECK_2(ic,oc);\n"
" const int oc8=oc << 3;\n"
" const int loop=(blockDim+2-1)/2;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop_end=max(loop-1,0);\n"
"#else\n"
" const int loop_end=loop;\n"
"#endif\n"
"#ifndef USE_IMAGE\n"
" const int weight_offset=oc*srcChannelC4*32;\n"
"#endif\n"
" COMPUTE_FLOAT8 out0=CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
" for (int i=0; i<blockNum; i++){\n"
" COMPUTE_FLOAT16 scale,offset;\n"
" {\n"
" #ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+i*dstChannelC4*8))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset.s02468ace,scaleOffset.s02468ace);\n"
" offset=(COMPUTE_FLOAT16)(scaleOffset.s13579bdf,scaleOffset.s13579bdf);\n"
" #else\n"
" COMPUTE_FLOAT8 scaleOffset=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+i*dstChannelC4*4))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset,scaleOffset);\n"
" offset=0;\n"
" #endif\n"
" }\n"
" for (int j=0; j<loop_end; j++) {\n"
" int k=i*loop+j;\n"
" COMPUTE_FLOAT2 in=CONVERT_COMPUTE_FLOAT2(vload2(0,input+(k << 1)));\n"
" #ifdef USE_IMAGE\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)(k,oc))))*scale+offset;\n"
" #else\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(vload16(k,weight+weight_offset))*scale+offset;\n"
" #endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)in.s0,wei.s01234567,out0);\n"
" }\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)in.s1,wei.s89abcdef,out0);\n"
" }\n"
" }\n"
" #if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k=i*loop+loop_end;\n"
" #ifdef USE_IMAGE\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)(k,oc))))*scale+offset;\n"
" #else\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(vload16(k,weight+weight_offset))*scale+offset;\n"
" #endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)input[k << 1],wei.s01234567,out0);\n"
" }\n"
" }\n"
" #endif\n"
" }\n"
"#ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
"#endif\n"
"#ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
"#endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" #endif\n"
"}\n"
"#endif\n"
"__kernel void gemv_conv_c8_int8_buf_sparse_simple(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
"#ifdef USE_IMAGE\n"
" __read_only image2d_t weight,\n"
"#else\n"
" __global const char *weight,\n"
"#endif\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef,\n"
" __private const float threshold) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" const int oc8=oc << 3;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop=max((srcChannel+2-1)/2-1,0);\n"
"#else\n"
" const int loop=(srcChannel+2-1)/2;\n"
"#endif\n"
" __local COMPUTE_FLOAT8 sum[WGS];\n"
"#ifndef USE_IMAGE\n"
" const int weight_offset=oc*srcChannelC4*32;\n"
"#endif\n"
" COMPUTE_FLOAT8 out0=0;\n"
" for(int j=lid; j<loop; j+=WGS){\n"
" int k2=j << 1;\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" {\n"
" #ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k2/blockDim)*dstChannelC4*8))/coef);\n"
" scale=(COMPUTE_FLOAT8)scaleOffset.s02468ace;\n"
" offset=(COMPUTE_FLOAT8)scaleOffset.s13579bdf;\n"
" #else\n"
" COMPUTE_FLOAT8 scaleOffset=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k2/blockDim)*dstChannelC4*4))/coef);\n"
" scale=(COMPUTE_FLOAT8)scaleOffset;\n"
" offset=0;\n"
" #endif\n"
" }\n"
" COMPUTE_FLOAT2 in=CONVERT_COMPUTE_FLOAT2(vload2(0,input+k2));\n"
" \n"
" if (fabs(in.s0) >= threshold){\n"
" COMPUTE_FLOAT8 wei=CONVERT_COMPUTE_FLOAT8(vload8(0,weight+weight_offset+k2*8))*scale+offset;\n"
" out0=mad((COMPUTE_FLOAT8)in.s0,wei.s01234567,out0);\n"
" } \n"
" if (fabs(in.s1) >= threshold){\n"
" COMPUTE_FLOAT8 wei=CONVERT_COMPUTE_FLOAT8(vload8(0,weight+weight_offset+(k2+1)*8))*scale+offset;\n"
" out0=mad((COMPUTE_FLOAT8)in.s1,wei.s01234567,out0);\n"
" }\n"
" }\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k2=loop << 1;\n"
" COMPUTE_FLOAT16 scale,offset;\n"
" {\n"
" #ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k2/blockDim)*dstChannelC4*8))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset.s02468ace,scaleOffset.s02468ace);\n"
" offset=(COMPUTE_FLOAT16)(scaleOffset.s13579bdf,scaleOffset.s13579bdf);\n"
" #else\n"
" COMPUTE_FLOAT8 scaleOffset=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k2/blockDim)*dstChannelC4*4))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset,scaleOffset);\n"
" offset=0;\n"
" #endif\n"
" }\n"
" #ifdef USE_IMAGE\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)(loop,oc))))*scale+offset;\n"
" #else\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(vload16(j,weight+weight_offset))*scale+offset;\n"
" #endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)input[k2],wei.s01234567,out0);\n"
" }\n"
" }\n"
"#endif\n"
" sum[lid]=out0;\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" for(int i=WGS/2; i>0; i /= 2){\n"
" if (lid<i)\n"
" sum[lid]=sum[lid]+sum[lid+i];\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" if(lid == 0){\n"
" out0=sum[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
" #ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" #endif\n"
" }\n"
"}\n"
"__kernel void gemv_conv_c8_int8_buf_sparse(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
"//#ifdef USE_IMAGE\n"
"// __read_only image2d_t weight,\n"
"//#else\n"
" __global const char *weight,\n"
"//#endif\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef,\n"
" __private const float threshold) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" const int oc8=oc << 3;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop=max((srcChannel+4-1)/4-1,0);\n"
"#else\n"
" const int loop=(srcChannel+4-1)/4;\n"
"#endif\n"
" __local COMPUTE_FLOAT8 sum[WGS];\n"
"//#ifndef USE_IMAGE\n"
" const int weight_offset=oc*srcChannelC4*32;\n"
"//#endif\n"
" COMPUTE_FLOAT8 out0=0;\n"
" for(int j=lid; j<loop; j+=WGS){\n"
" int k2=j << 2;\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" {\n"
" #ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k2/blockDim)*dstChannelC4*8))/coef);\n"
" scale=(COMPUTE_FLOAT8)scaleOffset.s02468ace;\n"
" offset=(COMPUTE_FLOAT8)scaleOffset.s13579bdf;\n"
" #else\n"
" COMPUTE_FLOAT8 scaleOffset=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k2/blockDim)*dstChannelC4*4))/coef);\n"
" scale=(COMPUTE_FLOAT8)scaleOffset;\n"
" offset=0;\n"
" #endif\n"
" }\n"
" COMPUTE_FLOAT4 in=CONVERT_COMPUTE_FLOAT4(vload4(0,input+k2));\n"
" if (fabs(in.x) >= threshold){\n"
" //#ifdef USE_IMAGE\n"
" //COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)(k2*8,oc))))*scale+offset;\n"
" //#else\n"
" COMPUTE_FLOAT8 wei=CONVERT_COMPUTE_FLOAT8(vload8(0,weight+weight_offset+k2*8))*scale+offset;\n"
" //#endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)in.x,wei.s01234567,out0);\n"
" }\n"
" }\n"
" if (fabs(in.y) >= threshold){\n"
" //#ifdef USE_IMAGE\n"
" //COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)((k2+1)*8,oc))))*scale+offset;\n"
" //#else\n"
" COMPUTE_FLOAT8 wei=CONVERT_COMPUTE_FLOAT8(vload8(0,weight+weight_offset+(k2+1)*8))*scale+offset;\n"
" //#endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)in.y,wei.s01234567,out0);\n"
" }\n"
" }\n"
" if (fabs(in.z) >= threshold){\n"
" //#ifdef USE_IMAGE\n"
" //COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)((k2+2)*8,oc))))*scale+offset;\n"
" //#else\n"
" COMPUTE_FLOAT8 wei=CONVERT_COMPUTE_FLOAT8(vload8(0,weight+weight_offset+(k2+2)*8))*scale+offset;\n"
" //#endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)in.z,wei.s01234567,out0);\n"
" }\n"
" }\n"
" if (fabs(in.w) >= threshold){\n"
" //#ifdef USE_IMAGE\n"
" //COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT8(as_char16(read_imagei(weight,SAMPLER,(int2)((k2+3)*8,oc))))*scale+offset;\n"
" //#else\n"
" COMPUTE_FLOAT8 wei=CONVERT_COMPUTE_FLOAT8(vload8(0,weight+weight_offset+(k2+3)*8))*scale+offset;\n"
" //#endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)in.w,wei.s01234567,out0);\n"
" }\n"
" }\n"
" }\n"
" \n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k2=loop << 1;\n"
" COMPUTE_FLOAT16 scale,offset;\n"
" {\n"
" #ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k2/blockDim)*dstChannelC4*8))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset.s02468ace,scaleOffset.s02468ace);\n"
" offset=(COMPUTE_FLOAT16)(scaleOffset.s13579bdf,scaleOffset.s13579bdf);\n"
" #else\n"
" COMPUTE_FLOAT8 scaleOffset=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k2/blockDim)*dstChannelC4*4))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset,scaleOffset);\n"
" offset=0;\n"
" #endif\n"
" }\n"
" //#ifdef USE_IMAGE\n"
" //COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)(loop,oc))))*scale+offset;\n"
" //#else\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(vload16(loop,weight+weight_offset))*scale+offset;\n"
" //#endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)input[k2],wei.s01234567,out0);\n"
" }\n"
" }\n"
"#endif\n"
" sum[lid]=out0;\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" for(int i=WGS/2; i>0; i /= 2){\n"
" if (lid<i)\n"
" sum[lid]=sum[lid]+sum[lid+i];\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" if(lid == 0){\n"
" out0=sum[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
" #ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" #endif\n"
" }\n"
"}\n"
"__kernel void gemv_conv_c8_int8_buf_sparse_group(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
"//#ifdef USE_IMAGE\n"
"// __read_only image2d_t weight,\n"
"//#else\n"
" __global const char *weight,\n"
"//#endif\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef,\n"
" __private const float threshold) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" const int oc8=oc << 3;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop=max((srcChannel+2-1)/2-1,0);\n"
"#else\n"
" const int loop=(srcChannel+2-1)/2;\n"
"#endif\n"
" __local COMPUTE_FLOAT8 sum[WGS];\n"
"//#ifndef USE_IMAGE\n"
" const int weight_offset=oc*srcChannelC4*32;\n"
"//#endif\n"
" COMPUTE_FLOAT8 out0=0;\n"
" for(int j=lid; j<loop; j+=WGS){\n"
" int k2=j << 1;\n"
" COMPUTE_FLOAT16 scale,offset;\n"
" {\n"
" #ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k2/blockDim)*dstChannelC4*8))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset.s02468ace,scaleOffset.s02468ace);\n"
" offset=(COMPUTE_FLOAT16)(scaleOffset.s13579bdf,scaleOffset.s13579bdf);\n"
" #else\n"
" COMPUTE_FLOAT8 scaleOffset=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k2/blockDim)*dstChannelC4*4))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset,scaleOffset);\n"
" offset=0;\n"
" #endif\n"
" }\n"
" COMPUTE_FLOAT2 in=CONVERT_COMPUTE_FLOAT2(vload2(0,input+k2));\n"
" if (fabs(in.s0)+fabs(in.s1) >= 2*threshold) {\n"
" #ifdef USE_IMAGE\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)(j,oc))))*scale+offset;\n"
" #else\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(vload16(j,weight+weight_offset))*scale+offset;\n"
" #endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)in.s0,wei.s01234567,out0);\n"
" }\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)in.s1,wei.s89abcdef,out0);\n"
" }\n"
" }\n"
" \n"
" }\n"
" \n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k2=loop << 1;\n"
" COMPUTE_FLOAT16 scale,offset;\n"
" {\n"
" #ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k2/blockDim)*dstChannelC4*8))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset.s02468ace,scaleOffset.s02468ace);\n"
" offset=(COMPUTE_FLOAT16)(scaleOffset.s13579bdf,scaleOffset.s13579bdf);\n"
" #else\n"
" COMPUTE_FLOAT8 scaleOffset=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k2/blockDim)*dstChannelC4*4))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset,scaleOffset);\n"
" offset=0;\n"
" #endif\n"
" }\n"
" //#ifdef USE_IMAGE\n"
" //COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(as_char16(read_imagei(weight,SAMPLER,(int2)(loop,oc))))*scale+offset;\n"
" //#else\n"
" COMPUTE_FLOAT16 wei=CONVERT_COMPUTE_FLOAT16(vload16(loop,weight+weight_offset))*scale+offset;\n"
" //#endif\n"
" {\n"
" out0=mad((COMPUTE_FLOAT8)input[k2],wei.s01234567,out0);\n"
" }\n"
" }\n"
"#endif\n"
" sum[lid]=out0;\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" for(int i=WGS/2; i>0; i /= 2){\n"
" if (lid<i)\n"
" sum[lid]=sum[lid]+sum[lid+i];\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" if(lid == 0){\n"
" out0=sum[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
" #ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" #endif\n"
" }\n"
"}\n"
"__kernel void gemv_conv_c8_int4_buf_sparse(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
" __global const uchar *weight,\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef,\n"
" __private const float threshold) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" const int oc8=oc << 3;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop=max((srcChannel+4-1)/4-1,0);\n"
"#else\n"
" const int loop=(srcChannel+4-1)/4;\n"
"#endif\n"
" __local COMPUTE_FLOAT8 sum[WGS];\n"
" COMPUTE_FLOAT8 out0=0;\n"
" const int weight_offset=oc*srcChannelC4*16;\n"
" \n"
" for(int j=lid; j<loop/2; j+= WGS){\n"
" //int k4=j << 2;\n"
" int k8=j << 3;\n"
" //int k8=j << 3;\n"
" //COMPUTE_FLOAT4 in=CONVERT_COMPUTE_FLOAT4(vload4(0,input+k4));\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k8/blockDim)*dstChannelC4*8))/coef);\n"
" scale=scaleOffset.s02468ace;\n"
" offset=scaleOffset.s13579bdf;\n"
" }\n"
"#else\n"
" COMPUTE_FLOAT8 scale=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k8/blockDim)*dstChannelC4*4))/coef);\n"
" COMPUTE_FLOAT8 offset=0;\n"
"#endif\n"
" \n"
" COMPUTE_FLOAT8 wei;\n"
" COMPUTE_FLOAT8 in=CONVERT_COMPUTE_FLOAT8(vload8(0,input+k8));\n"
" uchar8 charWeightsInt;\n"
" if (fabs(in.s0) >= threshold){\n"
" uchar4 charWeightsInt=vload4(j*8,weight+weight_offset);\n"
" UCHAR4_TO_CHAR8(charWeightsInt,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s0,wei,out0);\n"
" } \n"
" if (fabs(in.s1) >= threshold){\n"
" uchar4 charWeightsInt=vload4(j*8+1,weight+weight_offset);\n"
" UCHAR4_TO_CHAR8(charWeightsInt,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s1,wei,out0);\n"
" }\n"
" if (fabs(in.s2) >= threshold){\n"
" uchar4 charWeightsInt=vload4(j*8+2,weight+weight_offset);\n"
" UCHAR4_TO_CHAR8(charWeightsInt,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s2,wei,out0);\n"
" }\n"
" if (fabs(in.s3) >= threshold){\n"
" uchar4 charWeightsInt=vload4(j*8+3,weight+weight_offset);\n"
" UCHAR4_TO_CHAR8(charWeightsInt,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s3,wei,out0);\n"
" }\n"
" if (fabs(in.s4) >= threshold){\n"
" uchar4 charWeightsInt=vload4(j*8+4,weight+weight_offset);\n"
" UCHAR4_TO_CHAR8(charWeightsInt,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s4,wei,out0);\n"
" }\n"
" if (fabs(in.s5) >= threshold){\n"
" uchar4 charWeightsInt=vload4(j*8+5,weight+weight_offset);\n"
" UCHAR4_TO_CHAR8(charWeightsInt,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s5,wei,out0);\n"
" }\n"
" if (fabs(in.s6) >= threshold){\n"
" uchar4 charWeightsInt=vload4(j*8+6,weight+weight_offset);\n"
" UCHAR4_TO_CHAR8(charWeightsInt,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s6,wei,out0);\n"
" }\n"
" if (fabs(in.s7) >= threshold){\n"
" uchar4 charWeightsInt=vload4(j*8+7,weight+weight_offset);\n"
" UCHAR4_TO_CHAR8(charWeightsInt,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s7,wei,out0);\n"
" }\n"
" //if (fabs(in.s0) >= threshold || fabs(in.s1) >= threshold){\n"
" ////if (fabs(in.s0)+fabs(in.s1) >= 2*threshold) {\n"
" // charWeightsInt=vload8(j*2,weight+weight_offset);\n"
" // {\n"
" // UCHAR4_TO_CHAR8(charWeightsInt.s0123,scale,offset);\n"
" // out0=mad((COMPUTE_FLOAT8)in.s0,wei,out0);\n"
" // }\n"
" // {\n"
" // UCHAR4_TO_CHAR8(charWeightsInt.s4567,scale,offset);\n"
" // out0=mad((COMPUTE_FLOAT8)in.s1,wei,out0);\n"
" // }\n"
" // \n"
" //}\n"
" //if (fabs(in.s2) >= threshold || fabs(in.s3) >= threshold){\n"
" ////if (fabs(in.s2)+fabs(in.s3) >= 2*threshold) {\n"
" // charWeightsInt=vload8(j*2+1,weight+weight_offset);\n"
" // {\n"
" // UCHAR4_TO_CHAR8(charWeightsInt.s0123,scale,offset);\n"
" // out0=mad((COMPUTE_FLOAT8)in.s2,wei,out0);\n"
" // }\n"
" // {\n"
" // UCHAR4_TO_CHAR8(charWeightsInt.s4567,scale,offset);\n"
" // out0=mad((COMPUTE_FLOAT8)in.s3,wei,out0);\n"
" // }\n"
" // \n"
" //}\n"
" \n"
" \n"
" }\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k4=loop << 2;\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale=scaleOffset.s02468ace;\n"
" offset=scaleOffset.s13579bdf;\n"
" }\n"
"#else\n"
" COMPUTE_FLOAT8 scale=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" COMPUTE_FLOAT8 offset=0;\n"
"#endif\n"
" COMPUTE_FLOAT8 wei;\n"
" uchar16 charWeightsInt40=vload16(j,weight+weight_offset);\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4],wei,out0);\n"
" }\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 2\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+1],wei,out0);\n"
" }\n"
" #endif\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 3\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+2],wei,out0);\n"
" }\n"
" #endif\n"
" }\n"
"#endif\n"
" sum[lid]=out0;\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" for(int i=WGS/2; i>0; i /= 2){\n"
" if (lid<i)\n"
" sum[lid]=sum[lid]+sum[lid+i];\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" if(lid == 0){\n"
" out0=sum[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
" #ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" #endif\n"
" }\n"
"}\n"
"__kernel void gemv_conv_c8_int4_buf_sparse_eager(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
"#ifdef USE_IMAGE\n"
" __read_only image2d_t weight,\n"
"#else\n"
" __global const uchar *weight,\n"
"#endif\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef,\n"
" __private const float threshold) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" const int oc8=oc << 3;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop=max((srcChannel+4-1)/4-1,0);\n"
"#else\n"
" const int loop=(srcChannel+4-1)/4;\n"
"#endif\n"
" __local COMPUTE_FLOAT8 sum[WGS];\n"
" COMPUTE_FLOAT8 out0=0;\n"
"#ifndef USE_IMAGE\n"
" const int weight_offset=oc*srcChannelC4*16;\n"
"#endif\n"
" \n"
" for(int j=lid; j<loop; j+=WGS){\n"
" int k4=j << 2;\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale=scaleOffset.s02468ace;\n"
" offset=scaleOffset.s13579bdf;\n"
" }\n"
"#else\n"
" COMPUTE_FLOAT8 scale=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" COMPUTE_FLOAT8 offset=0;\n"
"#endif\n"
" COMPUTE_FLOAT8 wei;\n"
" COMPUTE_FLOAT4 in=CONVERT_COMPUTE_FLOAT4(vload4(0,input+k4));\n"
" \n"
" if (fabs(in.s0) >= threshold || fabs(in.s1) >= threshold || \n"
" fabs(in.s2) >= threshold || fabs(in.s3) >= threshold)\n"
" {\n"
" \n"
" #ifdef USE_IMAGE\n"
" uchar16 charWeightsInt40=as_uchar16(read_imagei(weight,SAMPLER,(int2)(j,oc)));\n"
" #else\n"
" uchar16 charWeightsInt40=vload16(j,weight+weight_offset);\n"
" #endif\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s0,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s1,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s2,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.scdef,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s3,wei,out0);\n"
" }\n"
" \n"
" }\n"
" }\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k4=loop << 2;\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale=scaleOffset.s02468ace;\n"
" offset=scaleOffset.s13579bdf;\n"
" }\n"
"#else\n"
" COMPUTE_FLOAT8 scale=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" COMPUTE_FLOAT8 offset=0;\n"
"#endif\n"
" COMPUTE_FLOAT8 wei;\n"
" #ifdef USE_IMAGE\n"
" uchar16 charWeightsInt40=as_uchar16(read_imagei(weight,SAMPLER,(int2)(loop,oc)));\n"
" #else\n"
" uchar16 charWeightsInt40=vload16(j,weight+weight_offset);\n"
" #endif\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4],wei,out0);\n"
" }\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 2\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+1],wei,out0);\n"
" }\n"
" #endif\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 3\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+2],wei,out0);\n"
" }\n"
" #endif\n"
" }\n"
"#endif\n"
" sum[lid]=out0;\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" for(int i=WGS/2; i>0; i /= 2){\n"
" if (lid<i)\n"
" sum[lid]=sum[lid]+sum[lid+i];\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" if(lid == 0){\n"
" out0=sum[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
" #ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" #endif\n"
" }\n"
"}\n"
"__kernel void gemv_conv_c8_int4_buf_sparse_for_raster(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
" __global const uchar *weight,\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef,\n"
" __private const float threshold) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1); //oc/16\n"
" const int oc16=oc << 4;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop=max((srcChannel+4-1)/4-1,0);\n"
"#else\n"
" const int loop=(srcChannel+4-1)/4;\n"
"#endif\n"
" __local COMPUTE_FLOAT16 sum[WGS];\n"
" const int weight_offset=oc*srcChannelC4*32;\n"
" COMPUTE_FLOAT16 out0=0;\n"
" //COMPUTE_FLOAT8 out0_1,out0_2;\n"
" for(int j=lid; j<loop; j+=WGS){\n"
" int k4=j << 2;\n"
" COMPUTE_FLOAT16 scale,offset;\n"
" //COMPUTE_FLOAT8 scale1,scale2,offset1,offset2;\n"
"#ifdef ASYMMETRIC\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset1=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc16*2+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" COMPUTE_FLOAT16 scaleOffset2=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc16*2+16+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale=(COMPUTE_FLOAT16)(scaleOffset1.s02468ace,scaleOffset2.s02468ace);\n"
" offset=(COMPUTE_FLOAT16)(scaleOffset1.s13579bdf,scaleOffset2.s13579bdf);\n"
" //scale1=scaleOffset1.s02468ace; \n"
" //scale2=scaleOffset2.s02468ace; \n"
" //offset1=scaleOffset1.s13579bdf;\n"
" //offset2=scaleOffset2.s13579bdf;\n"
" }\n"
"#else\n"
" scale=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc16+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" offset=(COMPUTE_FLOAT16)0;\n"
" //scale1=scaleOffset.s01234567;\n"
" //scale2=scaleOffset.s89abcdef;\n"
" //offset1=(COMPUTE_FLOAT8)(0);\n"
" //offset2=(COMPUTE_FLOAT8)(0);\n"
"#endif\n"
" \n"
" COMPUTE_FLOAT4 in=CONVERT_COMPUTE_FLOAT4(vload4(0,input+k4));\n"
" if (fabs(in.s0) >= threshold){\n"
" uchar8 b=vload8(j*4+0,weight+weight_offset);\n"
" {\n"
" COMPUTE_FLOAT16 wei;\n"
" UCHAR8_TO_CHAR16(b,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT16)in.s0,wei,out0);\n"
" //UCHAR4_TO_CHAR8_FIRST(b,scale1,offset1,wei_local1);\n"
" //out0_1=mad((COMPUTE_FLOAT8)in.s0,wei_local1,out0_1);\n"
" }\n"
" \n"
" //{\n"
" // COMPUTE_FLOAT8 wei_local2;\n"
" // UCHAR4_TO_CHAR8_SECOND(b,scale2,offset2,wei_local2);\n"
" // out0_2=mad((COMPUTE_FLOAT8)in.s0,wei_local2,out0_2);\n"
" //}\n"
" \n"
" //UCHAR8_TO_CHAR16(b,scale,offset);\n"
" //UCHAR8_TO_CHAR16(b,scale,offset);\n"
" }\n"
" if (fabs(in.s1) >= threshold){\n"
" uchar8 b=vload8(j*4+1,weight+weight_offset);\n"
" //{\n"
" // COMPUTE_FLOAT16 wei_local1;\n"
" // UCHAR4_TO_CHAR8_FIRST(b,scale1,offset1,wei_local1);\n"
" // out0_1=mad((COMPUTE_FLOAT8)in.s1,wei_local1,out0_1);\n"
" //}\n"
" //\n"
" //{\n"
" // COMPUTE_FLOAT8 wei_local2;\n"
" // UCHAR4_TO_CHAR8_SECOND(b,scale2,offset2,wei_local2);\n"
" // out0_2=mad((COMPUTE_FLOAT8)in.s1,wei_local2,out0_2);\n"
" //}\n"
" {\n"
" COMPUTE_FLOAT16 wei;\n"
" UCHAR8_TO_CHAR16(b,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT16)in.s1,wei,out0);\n"
" }\n"
" }\n"
" if (fabs(in.s2) >= threshold){\n"
" uchar8 b=vload8(j*4+2,weight+weight_offset);\n"
" //{\n"
" // COMPUTE_FLOAT8 wei_local1;\n"
" // UCHAR4_TO_CHAR8_FIRST(b,scale1,offset1,wei_local1);\n"
" // out0_1=mad((COMPUTE_FLOAT8)in.s2,wei_local1,out0_1);\n"
" //}\n"
" //\n"
" //{\n"
" // COMPUTE_FLOAT8 wei_local2;\n"
" // UCHAR4_TO_CHAR8_SECOND(b,scale2,offset2,wei_local2);\n"
" // out0_2=mad((COMPUTE_FLOAT8)in.s2,wei_local2,out0_2);\n"
" //}\n"
" {\n"
" COMPUTE_FLOAT16 wei;\n"
" UCHAR8_TO_CHAR16(b,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT16)in.s2,wei,out0);\n"
" }\n"
" }\n"
" if (fabs(in.s3) >= threshold){\n"
" uchar8 b=vload8(j*4+3,weight+weight_offset);\n"
" //{\n"
" // COMPUTE_FLOAT8 wei_local1;\n"
" // UCHAR4_TO_CHAR8_FIRST(b,scale1,offset1,wei_local1);\n"
" // out0_1=mad((COMPUTE_FLOAT8)in.s3,wei_local1,out0_1);\n"
" //}\n"
" //\n"
" //{\n"
" // COMPUTE_FLOAT8 wei_local2;\n"
" // UCHAR4_TO_CHAR8_SECOND(b,scale2,offset2,wei_local2);\n"
" // out0_2=mad((COMPUTE_FLOAT8)in.s3,wei_local2,out0_2);\n"
" //}\n"
" {\n"
" COMPUTE_FLOAT16 wei;\n"
" UCHAR8_TO_CHAR16(b,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT16)in.s3,wei,out0);\n"
" }\n"
" }\n"
" }\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k4=loop << 2;\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 scale,offset;\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale=scaleOffset.s02468ace;\n"
" offset=scaleOffset.s13579bdf;\n"
" }\n"
"#else\n"
" COMPUTE_FLOAT8 scale=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" COMPUTE_FLOAT8 offset=0;\n"
"#endif\n"
" COMPUTE_FLOAT8 wei;\n"
" uchar16 charWeightsInt40=vload16(j,weight+weight_offset);\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4],wei,out0);\n"
" }\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 2\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+1],wei,out0);\n"
" }\n"
" #endif\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 3\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+2],wei,out0);\n"
" }\n"
" #endif\n"
" }\n"
"#endif\n"
" //out0=(COMPUTE_FLOAT16)(out0_1.s0,out0_1.s1,out0_1.s2,out0_1.s3,out0_1.s4,out0_1.s5,out0_1.s6,out0_1.s7,out0_2.s0,out0_2.s1,out0_2.s2,out0_2.s3,out0_2.s4,out0_2.s5,out0_2.s6,out0_2.s7);\n"
" //out0.s1=out0_1.s1;\n"
" //out0=(COMPUTE_FLOAT16)(out0_1.s0,out0_1.s1,out0_1.s2,out0_1.s3,out0_1.s4,out0_1.s5,out0_1.s6,out0_1.s7,out0_2.s0,out0_2.s1,out0_2.s2,out0_2.s3,out0_2.s4,out0_2.s5,out0_2.s6,out0_2.s7);\n"
" sum[lid]=out0;\n"
" \n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" for(int i=WGS/2; i>0; i /= 2){\n"
" if (lid<i){\n"
" sum[lid]=sum[lid]+sum[lid+i];\n"
" }\n"
" \n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" \n"
" if(lid == 0){\n"
" out0=sum[0]+CONVERT_COMPUTE_FLOAT16(vload16(0,bias+oc16));\n"
" #ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore16(CONVERT_FLOAT16(out0),0,output+oc16);\n"
" #endif\n"
" }\n"
"}\n"
"__kernel void gemv_conv_c8_int4_buf_sparse_for_raster_v2(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
" __global const uchar *weight,\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef,\n"
" __private const float threshold) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1); // oc/8\n"
" const int oc16=oc << 4;\n"
" const int loop=(srcChannel+4-1)/4;\n"
" __local COMPUTE_FLOAT8 sum_low[WGS];\n"
" __local COMPUTE_FLOAT8 sum_high[WGS];\n"
" const int weight_offset=oc*srcChannelC4*32;\n"
" COMPUTE_FLOAT8 out_low=0;\n"
" COMPUTE_FLOAT8 out_high=0;\n"
" for (int j=lid; j<loop; j += WGS){\n"
" int k4=j << 2;\n"
" COMPUTE_FLOAT8 scale_low,scale_high,offset_low,offset_high;\n"
" COMPUTE_FLOAT4 in=CONVERT_COMPUTE_FLOAT4(vload4(0,input+k4));\n"
" #ifdef ASYMMETRIC\n"
" {\n"
" COMPUTE_FLOAT16 so1=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc*2+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" COMPUTE_FLOAT16 so2=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc*2+16+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale_low=so1.s02468ace;\n"
" scale_high=so2.s02468ace;\n"
" offset_low=so1.s13579bdf;\n"
" offset_high=so2.s13579bdf;\n"
" }\n"
" #else\n"
" {\n"
" COMPUTE_FLOAT16 so=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc*2+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" scale_low=so.s01234567;\n"
" scale_high=so.s89abcdef;\n"
" offset_low=0;\n"
" offset_high=0;\n"
" }\n"
" #endif\n"
" if (fabs(in.s0) >= threshold){\n"
" uchar8 b=vload8(j*4+0,weight+weight_offset);\n"
" {\n"
" COMPUTE_FLOAT8 wei_low,wei_high;\n"
" UCHAR4_TO_CHAR8_FIRST(b,scale_low,offset_low,wei_low);\n"
" UCHAR4_TO_CHAR8_SECOND(b,scale_high,offset_high,wei_high);\n"
" out_low=mad((COMPUTE_FLOAT8)in.s0,wei_low,out_low);\n"
" out_high=mad((COMPUTE_FLOAT8)in.s0,wei_high,out_high);\n"
" }\n"
" }\n"
" if (fabs(in.s1) >= threshold){\n"
" uchar8 b=vload8(j*4+1,weight+weight_offset);\n"
" {\n"
" COMPUTE_FLOAT8 wei_low,wei_high;\n"
" UCHAR4_TO_CHAR8_FIRST(b,scale_low,offset_low,wei_low);\n"
" UCHAR4_TO_CHAR8_SECOND(b,scale_high,offset_high,wei_high);\n"
" out_low=mad((COMPUTE_FLOAT8)in.s1,wei_low,out_low);\n"
" out_high=mad((COMPUTE_FLOAT8)in.s1,wei_high,out_high);\n"
" }\n"
" }\n"
" if (fabs(in.s2) >= threshold){\n"
" uchar8 b=vload8(j*4+2,weight+weight_offset);\n"
" {\n"
" COMPUTE_FLOAT8 wei_low,wei_high;\n"
" UCHAR4_TO_CHAR8_FIRST(b,scale_low,offset_low,wei_low);\n"
" UCHAR4_TO_CHAR8_SECOND(b,scale_high,offset_high,wei_high);\n"
" out_low=mad((COMPUTE_FLOAT8)in.s2,wei_low,out_low);\n"
" out_high=mad((COMPUTE_FLOAT8)in.s2,wei_high,out_high);\n"
" }\n"
" }\n"
" if (fabs(in.s3) >= threshold){\n"
" uchar8 b=vload8(j*4+3,weight+weight_offset);\n"
" {\n"
" COMPUTE_FLOAT8 wei_low,wei_high;\n"
" UCHAR4_TO_CHAR8_FIRST(b,scale_low,offset_low,wei_low);\n"
" UCHAR4_TO_CHAR8_SECOND(b,scale_high,offset_high,wei_high);\n"
" out_low=mad((COMPUTE_FLOAT8)in.s3,wei_low,out_low);\n"
" out_high=mad((COMPUTE_FLOAT8)in.s3,wei_high,out_high);\n"
" }\n"
" }\n"
" }\n"
" sum_low[lid]=out_low;\n"
" sum_high[lid]=out_high;\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" const int half_wgs=WGS/2;\n"
" \n"
" if (lid<half_wgs) {\n"
" // 前一半线程处理sum_low的reduction\n"
" for(int i=half_wgs/2; i>0; i /= 2){\n"
" if (lid<i) {\n"
" sum_low[lid] += sum_low[lid+i];\n"
" }\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" } else {\n"
" // 后一半线程处理sum_high的reduction\n"
" int local_lid=lid-half_wgs;\n"
" for(int i=half_wgs/2; i>0; i /= 2){\n"
" if (local_lid<i) {\n"
" sum_high[half_wgs+local_lid] += sum_high[half_wgs+local_lid+i];\n"
" }\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" }\n"
" \n"
" if(lid == 0){\n"
" COMPUTE_FLOAT8 result_low=sum_low[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc16));\n"
" COMPUTE_FLOAT8 result_high=sum_high[half_wgs]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc16+8));\n"
" \n"
" #ifdef RELU\n"
" result_low=fmax(result_low,(COMPUTE_FLOAT8)0);\n"
" result_high=fmax(result_high,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" result_low=clamp(result_low,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" result_high=clamp(result_high,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" \n"
" vstore8(CONVERT_FLOAT8(result_low),0,output+oc16);\n"
" vstore8(CONVERT_FLOAT8(result_high),0,output+oc16+8);\n"
" }\n"
" \n"
"}\n"
"__kernel void gemv_conv_c8_int4_buf_sparse_for_raster_thread_split(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
" __global const uchar *weight,\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef,\n"
" __private const float threshold) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1);\n"
" const int oc16=oc << 4;\n"
" const int loop=(srcChannel+4-1)/4;\n"
" \n"
" __local COMPUTE_FLOAT8 sum_low[WGS/2];\n"
" __local COMPUTE_FLOAT8 sum_high[WGS/2];\n"
" const int weight_offset=oc*srcChannelC4*32;\n"
" \n"
" const int half_wgs=WGS/2;\n"
" const bool is_low_thread=(lid<half_wgs);\n"
" const int local_lid=is_low_thread ? lid : (lid-half_wgs);\n"
" \n"
" COMPUTE_FLOAT8 out_result=0;\n"
" \n"
" // 每个线程只处理自己负责的部分\n"
" for(int j=local_lid; j<loop; j += half_wgs){\n"
" int k4=j << 2;\n"
" COMPUTE_FLOAT4 in=CONVERT_COMPUTE_FLOAT4(vload4(0,input+k4));\n"
" \n"
" COMPUTE_FLOAT activity=fabs(in.s0)+fabs(in.s1)+fabs(in.s2)+fabs(in.s3);\n"
" if (activity<threshold) continue;\n"
" \n"
" // 根据线程类型计算不同的scale和offset\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" if (is_low_thread) {\n"
" // 处理low部分 (前8个输出通道)\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 so1=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc16*2+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale=so1.s02468ace;\n"
" offset=so1.s13579bdf;\n"
"#else\n"
" COMPUTE_FLOAT16 s=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc16+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" scale=s.s01234567;\n"
" offset=(COMPUTE_FLOAT8)0;\n"
"#endif\n"
" } else {\n"
" // 处理high部分 (后8个输出通道)\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT16 so2=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc16*2+16+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale=so2.s02468ace;\n"
" offset=so2.s13579bdf;\n"
"#else\n"
" COMPUTE_FLOAT16 s=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc16+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" scale=s.s89abcdef;\n"
" offset=(COMPUTE_FLOAT8)0;\n"
"#endif\n"
" }\n"
" // 处理4个输入通道，每个线程只计算自己负责的权重部分\n"
" COMPUTE_FLOAT inputs[4]={in.s0,in.s1,in.s2,in.s3};\n"
" \n"
" for(int ch=0; ch<4; ch++) {\n"
" if (fabs(inputs[ch]) >= threshold) {\n"
" uchar8 w=vload8(j*4+ch,weight+weight_offset);\n"
" COMPUTE_FLOAT8 wei;\n"
" \n"
" if (is_low_thread) {\n"
" // 只处理权重的前半部分\n"
" UCHAR4_TO_CHAR8_FIRST(w,scale,offset,wei);\n"
" } else {\n"
" // 只处理权重的后半部分\n"
" UCHAR4_TO_CHAR8_SECOND(w,scale,offset,wei);\n"
" }\n"
" \n"
" out_result=mad((COMPUTE_FLOAT8)inputs[ch],wei,out_result);\n"
" }\n"
" }\n"
" }\n"
" \n"
" // 分别存储到不同的local memory区域\n"
" if (is_low_thread) {\n"
" sum_low[local_lid]=out_result;\n"
" } else {\n"
" sum_high[local_lid]=out_result;\n"
" }\n"
" \n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" \n"
" // 分别进行reduction，真正并行执行\n"
" if (is_low_thread) {\n"
" // low线程只处理sum_low\n"
" for(int i=half_wgs/2; i>0; i /= 2){\n"
" if (local_lid<i) {\n"
" sum_low[local_lid] += sum_low[local_lid+i];\n"
" }\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" } else {\n"
" // high线程只处理sum_high\n"
" for(int i=half_wgs/2; i>0; i /= 2){\n"
" if (local_lid<i) {\n"
" sum_high[local_lid] += sum_high[local_lid+i];\n"
" }\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" }\n"
" \n"
" // 只有线程0负责最终输出\n"
" if(lid == 0){\n"
" COMPUTE_FLOAT8 result_low=sum_low[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc16));\n"
" COMPUTE_FLOAT8 result_high=sum_high[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc16+8));\n"
" \n"
" #ifdef RELU\n"
" result_low=fmax(result_low,(COMPUTE_FLOAT8)0);\n"
" result_high=fmax(result_high,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" result_low=clamp(result_low,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" result_high=clamp(result_high,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" \n"
" vstore8(CONVERT_FLOAT8(result_low),0,output+oc16);\n"
" vstore8(CONVERT_FLOAT8(result_high),0,output+oc16+8);\n"
" }\n"
"}\n"
"__kernel void gemv_conv_c8_int4_buf_sparse_for_raster_simple(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
" __global const uchar *weight,\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef,\n"
" __private const float threshold) {\n"
" const int lid=get_local_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" const int oc8=oc << 3;\n"
" const int loop=(srcChannel+4-1)/4;\n"
" \n"
" __local COMPUTE_FLOAT8 sum[WGS];\n"
" COMPUTE_FLOAT8 out0=0;\n"
" const int weight_offset=oc*srcChannelC4*16;\n"
" \n"
" // 简化的主循环，专注于高效的内存访问\n"
" for(int j=lid; j<loop; j += WGS){\n"
" int k4=j << 2;\n"
" COMPUTE_FLOAT4 in=CONVERT_COMPUTE_FLOAT4(vload4(0,input+k4));\n"
" \n"
" // 快速活跃度检查\n"
" if (fabs(in.s0)<threshold) \n"
" continue;\n"
" \n"
" // 计算scale和offset\n"
" COMPUTE_FLOAT8 scale,offset;\n"
"#ifdef ASYMMETRIC\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+(k4/blockDim)*dstChannelC4*8))/coef);\n"
" scale=scaleOffset.s02468ace;\n"
" offset=scaleOffset.s13579bdf;\n"
" }\n"
"#else\n"
" scale=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+(k4/blockDim)*dstChannelC4*4))/coef);\n"
" offset=(COMPUTE_FLOAT8)0;\n"
"#endif\n"
" uchar16 weights=vload16(j,weight+weight_offset);\n"
" COMPUTE_FLOAT8 wei;\n"
" if (fabs(in.s0) >= threshold) {\n"
" UCHAR4_TO_CHAR8(weights.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s0,wei,out0);\n"
" }\n"
" if (fabs(in.s1) >= threshold) {\n"
" UCHAR4_TO_CHAR8(weights.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s1,wei,out0);\n"
" }\n"
" if (fabs(in.s2) >= threshold) {\n"
" UCHAR4_TO_CHAR8(weights.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s2,wei,out0);\n"
" }\n"
" if (fabs(in.s3) >= threshold) {\n"
" UCHAR4_TO_CHAR8(weights.scdef,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s3,wei,out0);\n"
" }\n"
" }\n"
" \n"
" // 标准reduction\n"
" sum[lid]=out0;\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" for(int i=WGS/2; i>0; i /= 2){\n"
" if (lid<i)\n"
" sum[lid] += sum[lid+i];\n"
" barrier(CLK_LOCAL_MEM_FENCE);\n"
" }\n"
" \n"
" if(lid == 0){\n"
" out0=sum[0]+CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
" #ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
" #endif\n"
" #ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
" #endif\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" }\n"
"}\n"
"__kernel void gemv_conv_c8_int4_buf_sparse_wo_local(GLOBAL_SIZE_DIM_2\n"
" __global const FLOAT* input,\n"
"#ifdef USE_IMAGE\n"
" __read_only image2d_t weight,\n"
"#else\n"
" __global const uchar *weight,\n"
"#endif\n"
" __global const FLOAT *dequantScaleOffset,\n"
" __global const FLOAT *bias,\n"
" __global FLOAT* output,\n"
" __private const int dstChannelC4,\n"
" __private const int srcChannelC4,\n"
" __private const int srcChannel,\n"
" __private const int blockNum,\n"
" __private const int blockDim,\n"
" __private const float coef,\n"
" __private const float threshold) {\n"
" const int ic=get_global_id(0);\n"
" const int oc=get_global_id(1); //oc/8\n"
" \n"
" UNIFORM_BOUNDRY_CHECK_2(ic,oc);\n"
" const int oc8=oc << 3;\n"
" \n"
" const int loop=(blockDim+4-1)/4;\n"
"#if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" const int loop_end=max(loop-1,0);\n"
"#else\n"
" const int loop_end=loop;\n"
"#endif\n"
" COMPUTE_FLOAT8 out0=CONVERT_COMPUTE_FLOAT8(vload8(0,bias+oc8));\n"
"#ifndef USE_IMAGE\n"
" const int weight_offset=oc*srcChannelC4*16;\n"
"#endif\n"
" for (int i=0; i<blockNum; i++){\n"
"#ifdef ASYMMETRIC\n"
" COMPUTE_FLOAT8 scale,offset;\n"
" {\n"
" COMPUTE_FLOAT16 scaleOffset=CONVERT_COMPUTE_FLOAT16(convert_float16(vload16(0,dequantScaleOffset+oc8*2+i*dstChannelC4*8))/coef);\n"
" scale=scaleOffset.s02468ace;\n"
" offset=scaleOffset.s13579bdf;\n"
" }\n"
"#else\n"
" COMPUTE_FLOAT8 scale=CONVERT_COMPUTE_FLOAT8(convert_float8(vload8(0,dequantScaleOffset+oc8+i*dstChannelC4*4))/coef);\n"
" COMPUTE_FLOAT8 offset=0;\n"
"#endif\n"
" for (int j=0; j<loop_end; j++) {\n"
" int k=i*loop+j;\n"
" COMPUTE_FLOAT8 wei;\n"
" COMPUTE_FLOAT4 in=CONVERT_COMPUTE_FLOAT4(vload4(0,input+(k << 2)));\n"
" if (fabs(in.s0)<threshold) continue;\n"
" #ifdef USE_IMAGE\n"
" uchar16 charWeightsInt40=as_uchar16(read_imagei(weight,SAMPLER,(int2)(k,oc)));\n"
" #else\n"
" uchar16 charWeightsInt40=vload16(k,weight+weight_offset);\n"
" #endif\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s0,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s1,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s2,wei,out0);\n"
" }\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.scdef,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)in.s3,wei,out0);\n"
" }\n"
" }\n"
" #if INPUT_CHANNEL_LEAVES_NUM != 0\n"
" {\n"
" int k=i*loop+loop_end;\n"
" int k4=k << 2;\n"
" COMPUTE_FLOAT8 wei;\n"
" #ifdef USE_IMAGE\n"
" uchar16 charWeightsInt40=as_uchar16(read_imagei(weight,SAMPLER,(int2)(k,oc)));\n"
" #else\n"
" uchar16 charWeightsInt40=vload16(k,weight+weight_offset);\n"
" #endif\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s0123,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4],wei,out0);\n"
" }\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 2\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s4567,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+1],wei,out0);\n"
" }\n"
" #endif\n"
" #if INPUT_CHANNEL_LEAVES_NUM >= 3\n"
" {\n"
" UCHAR4_TO_CHAR8(charWeightsInt40.s89ab,scale,offset);\n"
" out0=mad((COMPUTE_FLOAT8)input[k4+2],wei,out0);\n"
" }\n"
" #endif\n"
" }\n"
" #endif\n"
"}\n"
"#ifdef RELU\n"
" out0=fmax(out0,(COMPUTE_FLOAT8)0);\n"
"#endif\n"
"#ifdef RELU6\n"
" out0=clamp(out0,(COMPUTE_FLOAT8)0,(COMPUTE_FLOAT8)6);\n"
"#endif\n"
" #ifdef OUTPUT_CHANNEL_LEAVES\n"
" vstore4(CONVERT_FLOAT4(out0.s0123),0,output+oc8);\n"
" if(oc8+4<dstChannelC4*4)\n"
" vstore4(CONVERT_FLOAT4(out0.s4567),0,output+oc8+4);\n"
" #else\n"
" vstore8(CONVERT_FLOAT8(out0),0,output+oc8);\n"
" #endif\n"
"}\n"
;
#endif
}
