// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CUDACACHE_CUDACACHE_H_
#define FLATBUFFERS_GENERATED_CUDACACHE_CUDACACHE_H_

#include "flatbuffers/flatbuffers.h"

namespace CudaCache {

struct Autotuning;
struct AutotuningT;

struct Cache;
struct CacheT;

inline const flatbuffers::TypeTable *AutotuningTypeTable();

inline const flatbuffers::TypeTable *CacheTypeTable();

struct AutotuningT : public flatbuffers::NativeTable {
  typedef Autotuning TableType;
  std::vector<int32_t> params;
  std::vector<uint32_t> problemSize;
  std::string threadBlockSize;
  uint32_t timeCost;
  AutotuningT()
      : timeCost(0) {
  }
};

struct Autotuning FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutotuningT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AutotuningTypeTable();
  }
  const flatbuffers::Vector<int32_t> *params() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  const flatbuffers::Vector<uint32_t> *problemSize() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(6);
  }
  const flatbuffers::String *threadBlockSize() const {
    return GetPointer<const flatbuffers::String *>(8);
  }
  uint32_t timeCost() const {
    return GetField<uint32_t>(10, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(params()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(problemSize()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyString(threadBlockSize()) &&
           VerifyField<uint32_t>(verifier, 10) &&
           verifier.EndTable();
  }
  AutotuningT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AutotuningT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Autotuning> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AutotuningT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AutotuningBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_params(flatbuffers::Offset<flatbuffers::Vector<int32_t>> params) {
    fbb_.AddOffset(4, params);
  }
  void add_problemSize(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> problemSize) {
    fbb_.AddOffset(6, problemSize);
  }
  void add_threadBlockSize(flatbuffers::Offset<flatbuffers::String> threadBlockSize) {
    fbb_.AddOffset(8, threadBlockSize);
  }
  void add_timeCost(uint32_t timeCost) {
    fbb_.AddElement<uint32_t>(10, timeCost, 0);
  }
  explicit AutotuningBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AutotuningBuilder &operator=(const AutotuningBuilder &);
  flatbuffers::Offset<Autotuning> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Autotuning>(end);
    return o;
  }
};

inline flatbuffers::Offset<Autotuning> CreateAutotuning(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> params = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> problemSize = 0,
    flatbuffers::Offset<flatbuffers::String> threadBlockSize = 0,
    uint32_t timeCost = 0) {
  AutotuningBuilder builder_(_fbb);
  builder_.add_timeCost(timeCost);
  builder_.add_threadBlockSize(threadBlockSize);
  builder_.add_problemSize(problemSize);
  builder_.add_params(params);
  return builder_.Finish();
}

flatbuffers::Offset<Autotuning> CreateAutotuning(flatbuffers::FlatBufferBuilder &_fbb, const AutotuningT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CacheT : public flatbuffers::NativeTable {
  typedef Cache TableType;
  std::vector<std::unique_ptr<AutotuningT>> tunings;
  CacheT() {
  }
};

struct Cache FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CacheT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CacheTypeTable();
  }
  const flatbuffers::Vector<flatbuffers::Offset<Autotuning>> *tunings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Autotuning>> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(tunings()) &&
           verifier.VerifyVectorOfTables(tunings()) &&
           verifier.EndTable();
  }
  CacheT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CacheT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Cache> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CacheT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CacheBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tunings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Autotuning>>> tunings) {
    fbb_.AddOffset(4, tunings);
  }
  explicit CacheBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CacheBuilder &operator=(const CacheBuilder &);
  flatbuffers::Offset<Cache> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cache>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cache> CreateCache(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Autotuning>>> tunings = 0) {
  CacheBuilder builder_(_fbb);
  builder_.add_tunings(tunings);
  return builder_.Finish();
}

flatbuffers::Offset<Cache> CreateCache(flatbuffers::FlatBufferBuilder &_fbb, const CacheT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AutotuningT *Autotuning::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AutotuningT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Autotuning::UnPackTo(AutotuningT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = params(); if (_e) { _o->params.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->params[_i] = _e->Get(_i); } } };
  { auto _e = problemSize(); if (_e) { _o->problemSize.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->problemSize[_i] = _e->Get(_i); } } };
  { auto _e = threadBlockSize(); if (_e) _o->threadBlockSize = _e->str(); };
  { auto _e = timeCost(); _o->timeCost = _e; };
}

inline flatbuffers::Offset<Autotuning> Autotuning::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AutotuningT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAutotuning(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Autotuning> CreateAutotuning(flatbuffers::FlatBufferBuilder &_fbb, const AutotuningT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AutotuningT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _params = _o->params.size() ? _fbb.CreateVector(_o->params) : 0;
  auto _problemSize = _o->problemSize.size() ? _fbb.CreateVector(_o->problemSize) : 0;
  auto _threadBlockSize = _o->threadBlockSize.empty() ? 0 : _fbb.CreateString(_o->threadBlockSize);
  auto _timeCost = _o->timeCost;
  return CudaCache::CreateAutotuning(
      _fbb,
      _params,
      _problemSize,
      _threadBlockSize,
      _timeCost);
}

inline CacheT *Cache::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CacheT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Cache::UnPackTo(CacheT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tunings(); if (_e) { _o->tunings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tunings[_i] = std::unique_ptr<AutotuningT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Cache> Cache::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CacheT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCache(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Cache> CreateCache(flatbuffers::FlatBufferBuilder &_fbb, const CacheT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CacheT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tunings = _o->tunings.size() ? _fbb.CreateVector<flatbuffers::Offset<Autotuning>> (_o->tunings.size(), [](size_t i, _VectorArgs *__va) { return CreateAutotuning(*__va->__fbb, __va->__o->tunings[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CudaCache::CreateCache(
      _fbb,
      _tunings);
}

inline const flatbuffers::TypeTable *AutotuningTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "params",
    "problemSize",
    "threadBlockSize",
    "timeCost"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CacheTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AutotuningTypeTable
  };
  static const char * const names[] = {
    "tunings"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const CudaCache::Cache *GetCache(const void *buf) {
  return flatbuffers::GetRoot<CudaCache::Cache>(buf);
}

inline const CudaCache::Cache *GetSizePrefixedCache(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<CudaCache::Cache>(buf);
}

inline bool VerifyCacheBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CudaCache::Cache>(nullptr);
}

inline bool VerifySizePrefixedCacheBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CudaCache::Cache>(nullptr);
}

inline void FinishCacheBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<CudaCache::Cache> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCacheBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<CudaCache::Cache> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<CacheT> UnPackCache(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<CacheT>(GetCache(buf)->UnPack(res));
}

}  // namespace CudaCache

#endif  // FLATBUFFERS_GENERATED_CUDACACHE_CUDACACHE_H_
