1. 在脚本相同目录下生成 ".cache" 目录, 该目录用来进行中间文件的缓存

2. 在 ".cache" 目录下生成 "shader" 缓存目录,不在 ".cache" 根目录下生成，".cache" 目录 ”可能&可以” 被其他工具使用

3. 在 ".cache/shader" 目录下生成 "cache" 缓存目录，用来缓存全部的 "glslangValidator" 生成的文件

4. 在 ".cache/shader" 目录下生成 "config" 文件， "config" 文件为整个脚本的缓存控制文件

5. ".cache/shader/config" 文件包含以下内容
	（1）"makeshader.py" 自身的"SHA1","MD5",文件大小,最后修改日期，如果这几个信息任何一个不一致，则缓存无条件作废，原因为我们不确定控制文件究竟修改了什么，如果不作废，可能导致编译出的结果是不正确的
		字段例子如下：
		[makeshader.py] 
			sha1=xxx
			md5=xxxx	
			size=500	-->字节数
			lastmodify=2018-12-24 2:15:45 459 --->年月日，时分秒 微秒
	（2）字段信息，"ini"格式的字段信息，每个字段的字段名，为每个".comp"文件的文件名，每个字段中包含如下信息
		<1> ".comp"文件的 大小
		<2> ".comp"文件的 最后修改时间
		<3> ".comp"文件的 MD5
		<4> ".comp"文件的 SHA1
		<5> ".comp"文件编译出的结果文件在 "cache" 缓存目录中的 文件的大小
		<6> ".comp"文件编译出的结果文件在 "cache" 缓存目录中的 最后修改时间
		<7> ".comp"文件编译出的结果文件在 "cache" 缓存目录中的 MD5
		<8> ".comp"文件编译出的结果文件在 "cache" 缓存目录中的 SHA1
		
	MD5+SHA1+文件大小+最后修改时间相互验证，互相佐证，目的是尽可能的规避可能存在的碰撞问题（MD5存在碰撞问题（大小不同/相同文件存在MD5相同的情况），文件最后修改时间存在更新不及时问题-文件系统设计缺陷，比如FAT格式可能每隔2S才更新一次这个时间）
		字段例子如下：
			[sigmoidbuffer.comp]
				size=500	-->字节数
				lastmodify=2018-12-24 2:15:45 459 --->年月日，时分秒 微秒
				sha1=xxx
				md5=xxxx
				spirv_file=spirv_sigmoidbuffer.spirv --> spirv 文件的名字，不一定是这个样式的，这个样式只是一个例子
				spirv_size=200	-->字节数
				spirv_lastmodify=2018-12-24 2:15:45 459 --->年月日，时分秒 微秒
				spirv_sha1=xxxx
				spirv_md5=xxxx		
	
6. 最后的"AllShader.cpp","AllShader.h" 总是无条件全部更新，避免由于用户误操作或者编辑器IDE自动重新保存导致的问题。并且在更新这两个文件的时候，要求文件以独占方式打开，避免IDE同时打开文件的时候，IDE的保存导致覆盖文件的问题。

	（1）以上的两个文件应当提前锁定，避免后续全部都执行完成了，却无法锁定文件导致的时间浪费。
	（2）目前Python自带的fcntl.flock无法创建系统级别的排他锁，fcntl.lockf(fd,fcntl.LOCK_EX)只能创建劝告锁，导致可能存在潜在的问题，这个需要注意，这部分功能暂时无法达到预期，
		除非使用第三方库，比如：oslo.concurrency
		但是我们仍然需要增加排他锁，即使是只能Python脚本自己之间进行互斥，避免两个脚本同时执行时候可能出现的问题
		
	-- Python 无系统级别锁定，不引入三方插件的情况下，这个功能意义不大，不实现了

7. 脚本增加 "-f" 参数，当使用此参数的时候，脚本无条件忽略缓存文件，全部重新生成。作为一旦缓存出现BUG的最后补救措施。

8. 脚本用到的库 "hashlib"（MD5,SHA1）,"ConfigParser"(ini),"io"(文件操作)，"fcntl"（文件锁）

9. 缓存函数返回缓存命中的文件列表，编译函数根据剩余的文件列表完成文件的编译，并更新缓存信息

10. 增加 -w --weak参数,当指定这个参数的时候，只检验文件大小跟最后修改时间，前提是如果计算HASH非常慢的情况下 -- 实现意义不大，已经很快了

11. 本方案暂时不考虑删除过期文件的情况，比如某次编译产生的中间缓存文件，后续再也用不到了，暂时不进行扫描删除操作	

12. 方案存在一个潜在问题，就是如果“.cache/shader/config”文件被人手工修改过或者损坏，可能会出现意外的编译问题，因此需要增加一个校验和，计算的时候，校验和清空，计算完成后重新写回 -- 这种情况暂时不处理，后续遇到再进行处理吧